# 미니 커뮤니티 플랫폼 에러 내용

### 배포 중 발생한 에러

- 0.0.0.0/0에 바인딩 못하는 에러
  - 에러
    - Render에서 배포할 때 프론트엔드만 배포하려고 Root Directory에 "./frontend" 내용을 추가해준 상태로, 백엔드에 구성된 서버에 접근하지 못하게 되면서 발생하는 에러 발생
  - 해결 방법
    - 문제 해결을 위해서 Root Directory에 빈 내용으로 구성해주고, mini-community-platform 내용이 루트로 지정되도록 구성
    - Start Command를 통해서 프론트엔드에 들어가 실행되고, 백엔드에 들어가서 각각 실행되도록 구성을 변경해 주고 해결

<br />

- vite: not found 에러
  - 에러
    - Render에서 배포할 때 vite 관련 내용이 포함되면 자주 발생하는 에러
  - 해결을 위해 테스트한 과정과 방법
    - 방법 1
      - `npm install --production=false`, `npm ci` 같은 내용이 Start Command를 통해서 실행되도록 구성해 테스트했으나 해결되지 않음
        - ex1) `cd frontend && npm install --production=false && npm run build && cd ../backend && npm start`
        - ex2) `cd frontend && npm ci && npm run build && cd ../backend && npm start`
    - 방법 2
      - 로컬 환경에서 `npm run build`를 통해서 dist 폴더를 생성하고, 빌드 파일을 Render에 업로드해 정적 사이트를 생성
        - 이 방법의 문제점은 매번 업데이트할 때마다 로컬에서 코드를 수정하고 `npm run build`를 통해서 다시 빌드하고 새로운 dist 폴더를 생성해 업로드하는 방식으로 진행되므로 번거로운 과정이 반복되어서 적절하지 못함
        - GitHub와 연동해서 커밋할 때마다 Render가 자동으로 빌드하고 배포하도록 자동화된 배포 방식이 필요
    - 방법 3
      - Render는 기본적으로 `production` 모드로 설치하기 때문에 `devDependencies`에 있는 패키지를 설치하지 않아서 vite 에러가 발생하므로 `production` 모드에서도 vite를 설치하게 하거나 `npm install --production=false`, `npm ci` 명령어를 사용해 모든 패키지를 설치하도록 설정이 필요
        - `cd frontend && npm ci && npm run build && cd ../backend && npm start`
          - 이 명령어로는 해결되지 않음
        - `cd frontend && npm install --production=false && npm run build && cd ../backend && npm start`
          - 이 명령어로는 vite build가 되던 와중에 "JavaScript heap out of memory (메모리 부족)" 이라는 새로운 에러가 발생하므로, 추가 조치가 필요함
  - 결과
    - not found에 대한 에러는 `npm install --production=false`, `npm ci` 같은 내용을 추가해 해결이 된 것 같지만, 추가 오류가 발생하기 때문에 이 부분에 대한 수정이 필요

<br />

- "JavaScript heap out of memory (메모리 부족)" 에러
  - 에러
    - vite를 빌드하는 동안 너무 많은 메모리를 사용해서 Node.js가 메모리 한계를 초과해 발생하는 에러
      - 메모리 제한을 늘려줘야 하는데, 이 때 Render에서 웹 서비스를 배포할 때 Node.js의 메모리 제한을 늘리게 되면 배포 자체에 문제가 생길 수 있다고 생각되었지만, 메모리 제한을 늘리는 방법은 주로 빌드 과정에서 발생하는 메모리 부족 문제를 해결하기 위한 것이기 때문에 실제 웹 서비스가 실행되는 데에는 큰 영향을 주지 않으므로 문제되지 않음
  - 해결을 위해 테스트한 과정과 방법
    - 방법 1
      - `npm install --production=false` 명령어를 빼고 `NODE_OPTIONS="--max-old-space-size=4096` 명령어를 추가해 테스트하면 메모리 부족 에러는 뜨지 않고, vite 관련 오류가 다시 발생
        - `cd frontend && NODE_OPTIONS="--max-old-space-size=4096" npm run build && cd ../backend && npm start`
        - 이 명령어로 테스트하면 vite와 같은 개발 의존성이 설치되지 않아 vite 관련 오류가 다시 발생하므로 `npm install --production=false` 명령어를 포함해 다시 시도해야 함
    - 방법 2
      - `cd frontend && npm install --production=false && NODE_OPTIONS="--max-old-space-size=4096" npm run build && cd ../backend && npm start`
      - 이 명령어로 테스트하면 nodemon 관련 오류가 발생하기 때문에 백엔드에서도 `npm install --production=false` 명령어를 포함해 설치를 시도해봐야 함
  - 결과
    - `NODE_OPTIONS="--max-old-space-size=4096` 명령어를 `npm install --production=false` 명령어와 함께 추가해 테스트하면, vite not found 에러와 메모리 부족 에러가 뜨지 않는 것을 확인
    - 하지만 저 두 개의 명령어로 테스트하면 앞에서 발생한 오류는 해결되지만, 새로운 오류인 nodemon 관련 오류가 발생하기 때문에 백엔드에서 추가 작업이 필요함

<br />

- nodemon 관련 에러
  - 에러
    - nodemon 관련 오류는 nodemon이 devDependencies에 포함되어 있는데, 백엔드에 개발 의존성 내용을 함께 설치하지 않아서 발생하는 에러
  - 해결 과정
    - `cd frontend && npm install --production=false && NODE_OPTIONS="--max-old-space-size=4096" npm run build && cd ../backend && npm install --production=false && npm start`
      - 이 명령어로 시도했을 때 배포에 성공했지만, 메인 페이지에서 리디렉션한 횟수가 너무 많다는 메시지와 "ERR_TOO_MANY_REDIRECTS" 메시지가 뜨는데, 이 내용은 무한 리디렉션 루프가 발생하므로 추가 수정 필요
  - 결과
    - 백엔드에 개발 의존성 내용이 추가되지 않아서 nodemon 에러가 발생하기 때문에 `npm install --production=false` 내용을 추가해 문제를 해결해 주었지만, 무한 리디렉션 루프 문제가 발생하기 때문에 추가 테스트를 진행해서 오류를 고쳐줘야 함

<br />

- 무한 리디렉션 오류와 프론트엔드 내용이 보이지 않고, 백엔드 내용이 보여지는 것에 대한 에러
  - 에러
    - 배포한 페이지에 접속하면 무한 리디렉션 루프로 인해 제대로 내용이 출력되지 않음
    - 다른 페이지에서도 리디렉션 관련 문제가 발생하는 지 확인하기 위해 "/posts"로 이동하고 확인한 결과, 프론트엔드 내용이 아닌 백엔드 내용이 보여지는 문제를 확인
  - 해결을 위해 테스트한 과정과 방법
    - 프론트엔드 내용이 보여지기 위해 시도한 방법 1
      - 백엔드 코드에서 프론트엔드 정적 파일을 서빙하는 부분이 빠져있기 때문에 이와 관련된 내용을 추가
        - `express.static()` 내용을 사용해서 "frontend/dist" 폴더에서 빌드된 정적 파일들을 서빙하도록 설정
        - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/05f54de51d0f65d25293a66d0a9e6ac764a3e482)
        - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/778d65e0849a01d0d37803258b58841a91a1d7eb)
      - 이 방법으로 제대로 해결이 안되기 때문에 다른 방법이 필요
    - 프론트엔드 내용이 보여지기 위해 시도한 방법 2
      - Render에서 빌드 스크립트를 사용
        - Build Command로 npm run build를 설정하고, Start Command로 백엔드 서버를 시작하도록 설정
        - Build Command
          - `cd frontend && npm install --production=false && NODE_OPTIONS="--max-old-space-size=4096" npm run build` 내용으로 구성
        - Start Command
          - `cd backend && npm install --production=false && npm start` 내용으로 구성
      - 이 방법으로도 제대로 해결이 안되기 때문에 다른 방법 필요
  - 결과
    - 첫 번째 방법 결과
      - 백엔드에서 프론트엔드 정적파일을 서빙하는 내용을 추가하고 테스트해도 여전히 백엔드 내용이 보여지는 것을 확인
        - dist 파일이 있음에도 문제가 발생
        - 프론트엔드 경로에는 문제가 없는 것으로 판단
        - 라우팅 설정 문제가 있을 수 있다고 예상
          - "/posts" 경로가 백엔드 API와 충돌할 수 있으므로, API 경로와 프론트엔드 경로를 구분하는 방법도 생각해야 함
    - 두 번째 방법 결과
      - Build Command와 Start Command를 나눠서 명령어를 추가하고 테스트해봐도 여전히 "/posts"에서 백엔드 내용이 보여지므로 다른 방법을 사용해야 함
        - 라우팅 문제
          - 프론트엔드와 백엔드의 라우팅이 겹치거나 잘못 설정되어서, 원하는 동작이 이루어지지 않을 수 있음
          - 이 문제는 유력하다고 생각
        - 빌드 설정 문제
          - 빌드 과정에서 백엔드 파일이 포함되거나, 환경 변수가 잘못 설정되었을 수 있음
          - 이 문제는 확실하지 않음
        - 서버 설정
          - Render에서 서버 설정이 잘못되어 프론트엔드와 백엔드가 같은 포트에서 실행되거나, 잘못된 경로로 요청을 처리할 수 있음
          - 하나의 폴더 안에서 프론트엔드와 백엔드가 포함된 채로 배포하려고 시도했기 때문에 이런 문제가 생긴다고 생각이 됨
    - 테스트해 볼 해결책
      - 프론트엔드와 백엔드를 완전히 분리하여 배포하는 방법
        - 각각의 서비스가 독립적으로 동작하며, 서로 영향 없이 관리할 수 있음
        - 분리해서 배포할 경우, CORS 설정과 API 요청 경로를 명확히 설정해야 함
        - 같은 레포지토리에서 분리 배포 방식을 사용해 볼 생각
        - 프론트엔드 배포
          - Static Site를 선택하고, 같은 레포지토리를 연결
          - Root Directory를 "./frontend"로 설정
          - Build Command에 프론트엔드 빌드를 수행하는 명령어를 입력
            - `cd frontend && npm install --production=false && NODE_OPTIONS="--max-old-space-size=4096" npm run build`
        - 백엔드 배포
          - 웹 서비스로 설정하고, 레포지토리를 "mini-community-platform" 깃허브 레포지토리로 연결
          - Root Directory를 "./backend"로 설정
          - Start Command에 백엔드 서버를 시작하는 명령어를 입력
            - `cd backend && npm install --production=false && npm start`
        - 프론트엔드와 백엔드가 같은 레포지토리 내에서 각각 독립적으로 배포되도록 구성해 볼 생각
      - 라우트 경로가 겹치므로, API 요청에 대한 경로를 수정해서 확실하게 분리하는 것을 고려해야 함
        - 프론트엔드에서 API 경로를 변경하거나, 백엔드에서 API 경로를 변경하는 방향으로 수정해야 함
        - 이건 확실하지 않지만, 프론트엔드에서 API 경로에 대한 수정이 필요할 것으로 예상
  - 해결 방법
    - Render를 통해 프론트엔드와 백엔드 분리 배포
    - 프론트엔드 배포
      - Static site를 선택하고 mini-community-platform 레포지토리를 선택
      - Root Directory를 frontend로 구성
      - Build Command를 구성
        - `npm install --production=false && NODE_OPTIONS="--max-old-space-size=4096" npm run build`
      - Publish directory를 dist로 구성
      - 배포
    - 백엔드 배포
      - Web service를 선택하고 mini-community-platform 레포지토리를 선택
      - Root Directory를 backend로 구성
      - Start Command를 구성
        - `npm install --production=false && npm start`
      - Environment에 두 가지 내용을 추가
        - CORS_URL과 MONGODB_URI 추가
        - CORS_URL은 배포하는 프론트엔드 주소로 구성
        - MONGODB_URI는 연결한 Mongo Atlas 내용을 입력
      - 배포

### 배포 후 발생한 에러

- 로컬 환경의 프론트엔드에서 구성한 fetch 함수가 localhost로 연결되어 발생하는 오류
  - 에러
    - fetch 함수에서 구성한 API 경로가 동적으로 구성되어 있지 않고, localhost로 구성되어 있는 상태로 배포를 했기 때문에 배포한 사이트에서도 로컬 환경의 경로로 연결되어서 오류 발생
  - 해결을 위해 테스트한 과정과 방법
    - 배포한 프론트엔드 정적 사이트의 환경 변수와 로컬 환경의 프론트엔드 내용에서 환경 변수를 추가해 구성
      - 배포한 프론트엔드 정적 사이트에서 환경 변수 추가
        - REACT_APP_API_URL을 추가해서 백엔드와 연결되는 API 서버 주소를 추가
        - 백엔드 주소인 `https://mini-community-platform-backend.onrender.com` 내용을 저장
      - 로컬 환경의 프론트엔드 내용에서 환경 변수 추가
        - env 파일을 추가해 기존의 localhost 내용을 넣어놓고, 테스트를 위해 게시글 페이지에서 환경 변수 내용을 사용할 수 있도록 구성
        - REACT_APP_API_URL을 .env 파일에 추가하고, `http://localhost:3000` 내용이 들어가도록 구성
          - `REACT_APP_API_URL = http://localhost:3000`
        - 게시글 페이지의 fetch 함수 내용에서 환경 변수를 사용할 수 있게, apiURL 라는 변수를 추가하고 `process.env.REACT_APP_API_URL` 내용으로 구성
          - `const apiURL = process.env.REACT_APP_API_URL`
        - fetch 함수 내용의 API 경로에서 localhost 내용 대신에 apiURL 변수를 사용해서 구성
          - ex) `${apiURL}/posts`
  - 결과
    - 배포한 프론트엔드 정적 사이트에서 환경 변수도 추가하고, 그에 맞게 로컬 환경의 프론트엔드 내용에서 환경 변수를 구성해 테스트해 봤지만, 여전히 API 경로를 제대로 읽지 못하기 때문에 추가 수정이 필요

<br />

- 구성한 환경 변수 오류 1, 2
  - 에러
    - 환경 변수 오류 1
      - 게시글 페이지의 loader 함수 내에서 변수를 구성하지 않고 바깥에서 구성한 후, 사용해서 오류 발생
    - 환경 변수 오류 2
      - console.log를 추가해서 오류를 확인해보니, 환경 변수 자체를 읽지 못하는 오류가 발생
  - 해결을 위해 테스트한 과정과 방법
    - 환경 변수 오류 1
      - 문제를 해결하기 위해서 loader 함수 내에서 apiURL 변수를 구성해서 사용할 수 있도록 변경
      - 추가로 .env 파일에서 구성한 환경 변수 내용에 띄어쓰기를 사용하면 문제가 되기 때문에 띄어쓰기가 사용되지 않도록 변경
        - `REACT_APP_API_URL=http://localhost:3000`
    - 환경 변수 오류 2
      - Vite로 구성된 React 앱에서는 create-react-app으로 구성한 React앱과는 다르게 환경 변수 설정을 해줘야 제대로 읽을 수 있기 때문에 Vite 방식으로 환경 변수를 구성
      - .env 파일에서 Vite 방식으로 변경
        - `VITE_API_URL=http://localhost:3000`
      - apiURL 변수도 Vite 방식으로 변경
        - `const apiURL = import.meta.env.VITE_API_URL;`
      - Vite 방식으로 변경하고 확인해 보면 `console.log(import.meta.env)`도 문제없이 작동되어 콘솔에서 확인됨
  - 해결 방법
    - 환경 변수 오류 1
      - 게시글 페이지의 환경 변수 문제는 loader 함수 내에서 변수를 구성해 주면서 해결
      - .env 파일에서 구성한 환경 변수 내용에 띄어쓰기가 포함되지 않도록 변경해 미리 오류 예방
    - 환경 변수 오류 2
      - 구성된 환경 변수 방식을 Vite 방식으로 변경해주면서, 환경 변수를 읽을 수 있게 되고 오류가 해결됨
        - `VITE_API_URL=http://localhost:3000`
        - `const apiURL = import.meta.env.VITE_API_URL;`
      - 일반적인 React와 Vite에서 환경 변수 접근 방식
        - React
          - create-react-app에서는 환경 변수를 `REACT_APP_`으로 시작해야 함
          - REACT_APP_API_URL 라는 네이밍으로 사용 가능
          - `process.env`는 일반적으로 Node.js 환경에서 사용할 수 있고, create-react-app 같은 CRA 도구에서도 환경 변수를 읽는 데 사용되지만, Vite에서는 불가능
            - `process.env.REACT_APP_API_URL` 내용으로 환경 변수를 불러올 수 있음
          - CRA에서는 `REACT_APP_` 접두사를 가진 환경 변수만 읽을 수 있지만, Vite는 `VITE_` 접두사를 가진 변수만 읽을 수 있음
        - Vite
          - Vite에서는 환경 변수를 "VITE\_"로 시작해야 함
          - VITE_API_URL 라는 네이밍으로 사용 가능
          - `import.meta`를 사용하여 모듈 메타 정보를 제공하고, 환경 변수에 접근할 수 있게 해줌
          - `import.meta.env`는 Vite에 의해 제공되는 특수한 객체로, 이 객체를 통해 변수에 접근 가능
            - `import.meta.env.VITE_API_URL` 내용으로 환경 변수를 불러올 수 있음

<br />

- 프론트엔드에서 구성한 동적 API URL 에러 (secretOrPrivateKey must have a value 에러 포함)
  - 에러
    - 프론트엔드 내용에서 구성된 fetch 함수의 API 경로를 동적 API URL 경로로 바꾸고 테스트했지만, 일부는 작동하고 일부는 오류가 발생
      - 회원가입은 성공하고, 로그인은 실패
        - 토큰과 관련된 내용 모두 실패
      - 메인헤더 내용 오류 발생으로 실패
  - 해결을 위해 테스트한 과정과 방법
    - 로그인 실패 관련 테스트
      - 로그인할 때 Auth Context API에서 구성된 토큰이 필요하기 때문에 이 부분에 API URL 동적 구성을 추가
      - verifyUser, refreshTokenHadler, refreshTokenHandler, logoutHandler 함수에서 구성된 fetch 함수 내의 API 경로를 모두 API URL 동적 구성으로 변경
      - 구성해도 여전히 에러가 발생하며, 메인 헤더에서 구성된 fetch 함수 내용이 로그인 상태를 확인하고 유지시켜주는 내용인데, 이 부분에서 제대로 처리가 되지 않아서 추가 확인 필요
    - 메인헤더 내용 오류 관련 테스트
      - 메인헤더에서 구성된 fetch 함수 내의 API 경로에서 동적 API URL 내용이 사용될 수 있도록 구성
      - 로컬에서 테스트했을 때는 문제없이 작동되었으나, 배포 환경에서는 여전히 오류가 발생하기 때문에 추가 확인 필요
  - 해결 방법
    - 추가 확인 결과, 로그인 라우터에서 내용이 통과되지 못하고 오류가 발생하는 것을 확인
    - 오류 확인을 위해 에러 객체, 에러 메시지, 스택 트레이스 내용을 출력하도록 구성하고 확인
      - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/c5196177eef7dc5dfc4b599a889207db08222362)
    - 오류 확인 결과, `secretOrPrivateKey must have a value`라는 에러가 발생하는데, 이 에러는 JWT 토큰을 생성할 때 사용하는 비밀 키가 설정되지 않았다는 오류로, 배포한 백엔드 내용의 환경 변수에서 액세스 토큰, 리프레쉬 토큰 키 관련 설정을 추가해줘야 함
    - 로컬 환경의 .env 파일에서만 환경 변수 설정을 하고 배포한 백엔드 내용의 환경 변수에서 내용을 설정하지 않아서 발생한 오류로, 토큰 키 관련 환경 변수 내용을 추가해 깔끔하게 해결

<br />

- 토큰 키가 쿠키에 저장되지 않고 로그인되는 오류 (secure, sameSite 내용 동적 구성)
  - 에러
    - 로그인이 되지만, 토큰 키가 쿠키에 저장되지 않아서 새로고침 시에 바로 로그아웃 되는 오류가 발생
    - 쿠키에 토큰을 저장할 수 있는 설정을 로컬 환경에서만 저장할 수 있도록 구성해 놓은 상태이기 때문에 이에 대한 설정을 변경해야 함
  - 해결 방법
    - .env 파일에서 새로운 환경 변수인 `NODE_ENV`을 추가
      - 로컬 환경의 `NODE_ENV`에서는 "development" 내용이 들어가도록 구성
      - 배포 환경의 `NODE_ENV`에서는 "production" 내용이 들어가도록 구성
    - 백엔드의 user-routes, jwt-auth 파일에서 쿠키 내용에 사용되는 secure, sameSite 내용 수정
      - 새로운 변수인 isProduction를 추가해 환경 변수인 `NODE_ENV`를 확인하고 "production"과 비교해 일치하면 true, 불일치하면 false가 들어가도록 구성
      - 쿠키 내용의 secure 내용에서 정적 구성이 아닌, isProduction 변수로 동적 구성
        - 배포 환경의 환경 변수 내용이 확인되면 true, 로컬 환경의 환경 변수 내용이 확인되면 false
      - 쿠키 내용의 sameSite 내용에서 isProduction 변수를 확인해 조건부로 내용이 들어가도록 구성
        - true일 경우, "None" 내용이 들어가도록 구성
        - false일 경우, "Lax" 내용이 들어가도록 구성
        - 배포 환경에서는 "None", 로컬 환경은 "Lax"
  - 쿠키 설정 내용 추가
    - secure
      - true 일 때
        - HTTPS 프로토콜을 통해서만 쿠키가 전송되도록 보안 조치를 설정
        - HTTP 요청에서는 쿠키가 전송되지 않으며, HTTPS 연결에서만 쿠키를 주고 받음
        - 배포 환경이 HTTPS인 경우, 이 설정이 없으면 쿠키가 아예 전송되지 않음
        - 배포 환경에서 HTTPS를 사용하는 경우에는 이 설정을 반드시 사용하는 것이 좋음
        - 이 설정으로 쿠키가 암호화된 연결을 통해 안전하게 전송됨
        - 보안이 중요한 인증 토큰(JWT), 세션 등의 쿠키를 안전하게 보호할 수 있음
      - false 일 때
        - HTTP 및 HTTPS 모두에서 쿠키가 전송됨
        - 보안이 설정되지 않은 HTTP 프로토콜을 사용하는 요청에서도 쿠키가 전송될 수 있음
        - 로컬 개발 환경이나 보안이 크게 중요하지 않은 환경에서는 이 설정을 사용 가능
        - 보안 측면 조금 취약함
        - HTTP
      - false로 설정되었으나, 왜 HTTPS 연결에서 쿠키가 전송되지 않는가 ?
        - 이론적으로는 HTTP와 HTTPS에서 모두 전송될 수 있지만, 실제 배포 환경에서의 동작은 다르다.
        - 현대 브라우저들은 보안 강화를 위해 HTTPS 환경에서 false로 설정된 쿠키의 전송을 자동으로 차단하는 경우가 많음
          - HTTPS 연결에서는 쿠키의 보안을 보장하기 위해 true로 설정된 쿠키만 전송하려고 함
        - false로 구성되었을 때는 HTTP에만 적합하며, HTTPS에서 사용할 경우 보안적으로 안전하지 않기 때문에 브라우저에서 이를 차단함
        - 결론은 브라우저에서 false로 설정되면, 보안이 취약하다고 판단하고 사전에 차단해서 HTTPS 연결에서 쿠키가 전송되지 않도록 해줌
      - 로컬 환경에서 개발할 때는 false로 설정하여 HTTPS가 필요 없이 쿠키를 전송하도록 설정할 수 있고, 배포 환경에서 HTTPS를 사용 중이라면 true로 설정하여 보안을 강화해야 한다.
        - HTTP에서는 쿠키가 전송되지만, HTTPS에서는 브라우저가 보안상의 이유로 차단할 수 있음
        - 배포 환경이 HTTPS일 경우, 반드시 true로 설정해야 쿠키가 HTTPS 연결을 통해 전송됨
    - httpOnly
      - 쿠키를 클라이언트 측 JS에서 접근하지 못하게 보호하는 기능을 제공
      - true일 때
        - 쿠키가 오직 서버에서만 접근할 수 있도록 설정
        - 브라우저의 JS 코드로는 해당 쿠키에 접근할 수 없기 때문에, XSS 공격으로부터 쿠키를 보호할 수 있음
        - 주로, 액세스 토큰이나 세션 쿠키와 같은 민감한 정보를 보호하기 위해 사용
        - 보안 강화
      - false일 때
        - 쿠키가 JS에서 접근 가능함
        - ex) document.cookie로 쿠키를 읽거나 수정할 수 있음
        - 그러나, 위 같이 하면 XSS 공격에 취약해지기 때문에 민감한 정보를 저장할 때는 추천되지 않음
        - 보안 취약
      - true로 설정하는 것이 특히 인증 정보를 안전하게 유지하는데 필수적인 보안 조치임
    - sameSite
      - 프론트엔드와 백엔드가 서로 다른 도메인에 있을 경우, "None" 설정을 추가해야 함
        - 해당 설정을 통해 쿠키가 서로 다른 도메인 간에도 주고받을 수 있게 됨
      - "None"일 경우, 서로 다른 도메인 간 요청을 허용하는 쿠키 정책으로 프론트엔드와 백엔드가 동일한 도메인이 아니라면 "None" 옵션이 필요함
        - "None" 옵션으로 구성하지 않으면 브라우저가 보안 정책에 의해 쿠키를 차단할 수 있음
      - 동일한 도메인에서만 동작한다면 "strict"나 "Lax"도 가능
        - 하지만, 대부분의 배포 환경에서는 프론트엔드와 백엔드가 다른 도메인에 있을 가능성이 높아서 "None"이 적합함
      - 로컬 환경에서도 프론트엔드와 백엔드가 다른 포트를 사용하면 "None"으로 설정해야 쿠키가 프론트엔드에서 제대로 전송되고, 백엔드에서도 처리됨
      - sameSite가 설정되지 않은 경우, 기본값은 "Lax"
        - 명시적으로 설정하지 않으면 기본값은 "Lax"이며, "None"은 자동으로 적용되지 않는다.
      - 로컬 환경에서 sameSite 속성을 명시하지 않고도 정상적으로 작동한 이유는 브라우저의 기본 동작 때문임
        - 로컬 환경에서는 "localhost"가 동일한 출처로 간주되기 때문에, 포트가 다르더라도 대부분의 브라우저에서는 이 요청을 안전하다고 판단하고 쿠키 전송을 허용함
        - 개발 중에 사용되는 "localhost"는 대부분의 브라우저에서 특별한 취급을 받기 때문에 sameSite 속성이 없는 경우에도 쿠키가 정상적으로 작동할 수 있음
      - 배포 환경에서는 CORS 및 보안 정책이 엄격하게 적용되므로, 쿠키가 제대로 전달되도록 sameSite 설정을 명시적으로 정의해야 함
  - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/5e5c2de0bc4190d2f488fcae2e557409f64dd423)

<br />

- 로그아웃 한 후에 쿠키에 저장된 토큰이 삭제되지 않는 오류
  - 에러
    - 로그인 한 후에 로그아웃을 하면 로컬 스토리지에 저장된 내용만 삭제되고, 쿠키에 저장된 토큰은 삭제되지 않는 오류가 발생
  - 해결 방법
    - user-routes.js 내용의 로그아웃 라우터 수정
      - isProduction 변수를 추가
      - clearCookie 내용에 secure과 sameSite 내용 추가
        - secure
          - 토큰을 쿠키에 저장할 때 구성해준 내용과 마찬가지로, 로컬 환경에서는 false가 적용되고, 배포 환경에서 true가 적용되도록 구성
        - sameSite
          - 여기서도 토큰을 쿠키에 저장할 때 구성해준 내용과 마찬가지로, 로컬 환경에서는 "Lax"가 들어가도록 해주고, 배포 환경에서는 "None"이 들어가도록 구성
    - 쿠키에 토큰을 저장할 때와 마찬가지로, 쿠키에 저장된 내용을 삭제할 때 secure, sameSite, domain, path 같은 옵션들을 확인해 문제가 없을 때 삭제되도록 구성
    - 쿠키에 토큰을 저장할 때 domain, path 옵션은 사용하지 않고 secure, sameSite만 설정했기 때문에 이 두 가지 내용만 추가해 오류가 발생하지 않도록 구성
    - res.clearCookie 내용은 res.cookie에서 설정한 속성들과 동일하게 구성해 오류가 발생하지 않도록 구성
  - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/96fca6893e6b44316043cf682615a5ce7246a13b)

<br />

- Not Found 에러 (Rewrite 설정)
  - 에러
    - 홈 페이지를 제외한 게시글 페이지나 게시글 세부 페이지, 프로필 페이지 등 여러 페이지에서 새로고침을 하거나, URL에 입력해 이동하려고 할 때 "Not Found"라는 메시지가 보여지며 존재하지 않는 페이지로 이동하는 오류가 발생
  - 에러 발생 이유
    - 클라이언트 측에서 URL을 관리하고 페이지를 렌더링
    - 처음에 접속할 때는 index.html 파일을 로드하고 그 후에 내부적으로 라우팅을 처리
    - 사용자가 페이지를 새로고침하면 서버는 그 경로에 대한 직접적인 요청을 받음
    - 서버에는 해당 경로에 대한 처리가 없기 때문에 404에러가 발생
    - 서버는 경로에 대해 알고 있지 않고, 그 경로가 클라이언트 측에서만 정의되어 있기 때문임
    - SPA에서 서버가 클라이언트 라우터를 처리하지 못할 때 발생하는 문제로, Vite로 빌드한 프로젝트는 기본적으로 정적 파일을 제공하지만, 서버가 라우팅을 처리하지 않아서 발생
      - 해결을 위해서는 서버에서 모든 경로를 index.html로 리디렉트하여 클라이언트 측 라우터가 경로를 처리하도록 해야 함
      - Render와 같은 배포 환경에서는 "Rewrite" 또는 "Fallback" 설정을 추가하여 모든 경로가 index.html로 리디렉션되도록 해줘야 함
  - 해결 방법 (Netlify, Vercel 등 다른 배포 사이트)
    - Express 서버 설정 (Vite + Express)
      - 서버쪽 설정에서 프론트엔드 정적 파일을 제공하고, 모든 경로를 index.html로 리다이렉트 되도록 해줘야 함
      - Express 서버에서는 app.get("\*")을 사용하여 모든 경로가 index.html로 리다이렉트
    - Vite 배포 설정 (Netlify, Vercel 등)
      - Netlify
        - Netlify에서는 "\_redirects" 파일을 사용하여 모든 경로를 리디렉트
        - "\_redirects" 파일을 프로젝트의 dist 폴더에 추가하여 모든 경로를 index.html로 리디렉트하는 규칙을 설정해서 해결 가능
        - `/* /index.html 200`
      - Vercel
        - Vercel에서는 vercel.json 파일에 rewrite 규칙을 추가
        - vercel.json 파일에 rewrite 설정을 추가하여 모든 경로가 index.html로 리디렉트되도록 할 수 있음
        - `{ "rewrites": [ { "source" : "/(.*)", "destination": "index.html" } ]}`
      - Nginx
        - Nginx를 사용한다면 "try_files $uri /index.html;" 설정을 추가
        - Nginx를 사용하여 정적 파일을 제공하는 경우, 모든 경로를 index.html로 리디렉트하는 규칙을 추가해야 함
        - `location / { try_files $url /index.html }`
  - 해결 방법 (Render에서 배포한 경우)
    - Express 서버 설정은 동일
    - Vite 배포 설정 (Render)
      - 기본 설명
        - Render의 리디렉션 설정을 통해 모든 경로를 index.html로 리디렉트하는 설정을 추가해야 함
        - 이 설정은 서버가 클라이언트 라우팅을 처리할 수 있도록 하여 SPA에서 URL을 직접 입력하거나 새로고침할 때 오류를 방지함
          - Render에서는 "rewrites" 설정을 통해 이 문제를 해결할 수 있음
        - 프론트엔드를 배포한 곳에서 "Redirect and Rewrite Rules" 설정을 수정해야 함
        - 프론트엔드의 모든 경로를 index.html로 리디렉트하여, 클라이언트 사이드 라우터가 경로를 처리하도록 해야 함
      - 설정 방법
        - Render 대시보드에서 Static Site로 배포한 프론트엔드 프로젝트로 이동
        - Redirects/Rewrites (Redirect and Rewrite Rules)에서 규칙 추가
        - Source
          - "/\*"
        - Destinaton
          - "/index.html"
        - Action (Type)
          - Rewrite
        - 이 설정으로 모든 경로(/posts, /posts/1, /profile 등)를 index.html로 리다이렉트 되도록 해주며, Vite와 같은 클라이언트 사이드 라우터가 해당 경로를 처리할 수 있게 됨
        - Redirect and Rewrite Rules에서 /\*를 /index.html로 Rewrite하는 규칙을 추가하면, 프론트엔드의 모든 경로가 index.html로 리다이렉트 되어 클라이언트 사이드 라우터가 동작하게 됨
    - 추가 정리
      - Redirects/Rewrites (Redirect and Rewrite Rules) 내용에서 Action 항목을 Rewrite로 선택하는 이유는 ?
        - Rewrite
          - 클라이언트가 요청한 URL을 서버 내부에서 다른 경로로 매핑
          - URL이 브라우저 주소창에서 변경되지 않음
            - "/posts/1"을 요청해도 내부적으로는 "/index.html"을 서버에서 전달하지만, 사용자는 여전히 "/posts/1" URL을 보게 됨
          - 클라이언트 사이드 라우터가 해당 경로를 처리하도록 하는데, 이는 SPA의 본질에 맞는 방식임
        - Redirect
          - 서버가 클라이언트에게 다른 URL로 이동하라는 응답을 보냄
          - URL이 브라우저 주소창에서 변경됨
            - "/posts/1"를 요청하면 클라이언트가 "/index.html"로 리다이렉트되고, 사용자는 브라우저 주소창에서 "/index.html"을 보게 됨
          - SPA에서 원치 않는 동작으로, 클라이언트 사이드 라우터가 아니라 서버가 라우팅을 처리하게 되어, SPA의 장점인 빠르고 동적인 페이지 전환이 사라짐
      - 간단 요약
        - Rewrite
          - 브라우저 주소창의 URL은 유지하면서 요청을 서버 내부적으로 index.html로 매핑하고, 클라이언트 사이드 라우터가 경로를 처리할 수 있도록 함
          - SPA에 적합한 방식
        - Redirect
          - 브라우저 주소창의 URL을 강제로 변경하고, 서버에서 다시 요청을 받음
          - SPA에 적합하지 않는 방식이며, 불필요한 서버 요청이 발생할 수 있음
        - SPA 프로젝트에서는 반드시 "rewrite"를 선택해야 올바르게 동작하며, URL 새로고침이나 경로 이동 시 문제가 발생하지 않음

<br />

- 로컬 스토리지 초기화 오류
  - 에러
    - 배포한 사이트에서 로그인하고 일정 시간이 지난 후에 자동으로 로그아웃 되면서 쿠키에 저장된 데이터는 삭제되지만, 로컬 스토리지에 저장된 데이터는 삭제되지 않는 오류가 발생
  - 해결을 위해 테스트한 과정과 방법
    - 방법 1
      - 백엔드
        - 액세스 토큰 갱신 유효시간 1분으로 구성해 테스트
        - 액세스 토큰 만료 시간 1분, 리프레쉬 토큰 만료 시간 5분으로 수정해 테스트
        - 쿠키에 토큰이 저장되어 있는 시간도 1분, 5분으로 수정해 테스트
      - 프론트엔드
        - 인터벌 시간을 1분으로 수정해 테스트
        - 로그인 만료 시간 1분으로 수정해 테스트
      - 테스트 결과
        - 리프레쉬 토큰 만료 시간을 초과하게 되면 정상적으로 로컬 스토리지를 초기화하고 쿠키에 저장된 토큰도 삭제해 로그아웃되는 것을 확인
        - 시간을 대폭 줄여서 테스트할 때는 문제가 없는 것을 확인했는데, 무료 서버와 무료 백엔드를 사용해 자동으로 중간에 일시 정지되거나 리소스를 절약하기 위해 중간되어 오류가 발생한 것으로 추측
    - 방법 2
      - 백엔드
        - 액세스 토큰 갱신 유효시간 30분으로 구성해 테스트
        - 액세스 토큰 만료 시간 30분, 리프레쉬 토큰 만료 시간 2시간으로 수정해 테스트
        - 쿠키에 토큰이 저장되어 있는 시간도 30분, 2시간으로 수정해 테스트
      - 프론트엔드
        - 인터벌 시간을 15분으로 수정해 테스트
        - 로그인 만료 시간 30분으로 수정해 테스트
      - 테스트 결과
        - 브라우저가 열린 상태에서 2시간이 지난 후에 리프레쉬 토큰이 만료되며, 자동으로 로그아웃 되는 것을 확인
        - 브라우저가 닫힌 상태에서 2시간이 지난 후, 그대로 로그인이 되어 있으며 여전히 쿠키만 초기화되고 로컬 스토리지는 초기화 되지 않는 것을 확인
        - 만료 시간 문제가 아닌 것으로 추측, 근본적인 원인은 브라우저가 열린 상태와 닫힌 상태로 추측
      - 테스트 결과로 예상하는 원인
        - 문제 원인은 브라우저가 닫힌 상태에서는 useEffect가 작동하지 않아서, 브라우저가 꺼진 상태에서는 토큰의 만료 시간이 지나면 쿠키만 삭제되고 로컬 스토리지 그대로 유지되는 문제가 발생
        - 무료 서버나 백엔드는 해당 문제와 관련이 없고, 클라이언트 측 로컬 스토리지는 브라우저 내부의 JS로 처리되기 때문에 서버가 유료인지 무료인지는 영향을 주지 않음
      - 해결 방안
        - 브라우저가 꺼진 상태에서는 useEffect가 실행되지 않기 때문에 만료 시간을 체크할 수 없으므로, 다시 브라우저가 열렸을 때 바로 만료 시간을 체크하고 만료 되었으면 자동으로 로그아웃하는 로직을 구성하는 방법을 생각
    - 방법 3
      - 테스트를 위한 내용 수정
        - 로그인 여부에 따라 사용자 인증 및 토큰 갱신을 하는 useEffect 내부의 로직을 수정
        - 마운트 되면 토큰 만료 시간을 확인하는 if문이 먼저 실행되고, 유효하면 로그인 유지하고 만료되었다면 로그아웃 되도록 수정
        - 토큰 만료 여부를 먼저 확인하고, 그 다음 로그인 여부를 확인하도록 코드 순서 변경
      - 테스트 결과
        - 토큰 만료 시간이 지난 후에 확인해 보면 로그아웃이 되어 있지 않은 것을 확인
        - 만료 시간을 짧게 조절하고 다시 확인한 결과, 브라우저를 닫고 토큰 만료 시간이 지난 후에 확인해 보면 로그아웃 되어 있는 것을 확인
        - 만료 시간을 길게 조절하고 다시 확인한 결과, 토큰 만료 여부를 확인하는 if문이 true로 나오는 것을 확인했으나 쿠키에 토큰이 추가되지 않고 뒤늦게 추가되어 사용자 정보가 보여지는 것을 확인했으며, 결과적으로 좀 더 테스트가 필요
      - [코드 내용](https://github.com/jeongsangtae/mini-community-platform/commit/6beb26ee655d6b92786fb31a6cf10ebfc1cfa3dd)
    - 방법 4
      - 백엔드
        - 액세스 토큰 갱신 유효시간 4분으로 구성해 테스트
        - 액세스 토큰 만료 시간 4분, 리프레쉬 토큰 만료 시간 20분으로 수정해 테스트
        - 쿠키에 토큰이 저장되어 있는 시간도 4분, 20분으로 수정해 테스트
      - 프론트엔드
        - 인터벌 시간을 2분으로 수정해 테스트
        - 로그인 만료 시간 4분으로 수정해 테스트
        - 로그아웃 함수에서 코드 순서를 조금 변경해, role 항목을 변수에 저장하는 내용이 제일 앞 쪽에 위치하고, 로컬 스토리지 초기화 내용이 쿠키 삭제 내용보다 앞에 위치하며 role 변수 다음에 위치하도록 구성
        - 최종적으로 role 변수 - 로컬 스토리지 초기화 - 로그아웃 fetch 함수 순서로 작동하도록 수정
      - 테스트 결과
        - 만료 시간이 짧은 상태에서 확인해 보면 브라우저를 닫은 상태로 리프레쉬 토큰 만료 시간이 지난 후에 다시 접속하면 로그아웃이 되어 있고, 쿠키에 저장된 토큰 또한 삭제되어 있는 것을 확인
          - 로컬 스토리지 내용이 초기화되어 있고, 쿠키 내용 또한 초기화된 것을 확인
        - 다시 브라우저에 접속했을 때 만료 시간을 확인하는데, 이 때 로그아웃 함수가 작동은 했지만 뒤늦게 작동하기 때문에 로컬 스토리지 내용이 즉시 초기화 되지 않았던 것 같은데, 이번 테스트에서는 한참 시간이 지난 후에 브라우저를 접속해도 로그아웃이 되어 있고 로컬 스토리지와 쿠키가 초기화된 것을 확인
        - 이 테스트로 문제없이 작동하는 것 같기에, 만료 시간을 길게 설정해 다시 확인 필요
    - 방법 5
      - 백엔드
        - 액세스 토큰 갱신 유효시간 30분으로 구성해 테스트
        - 액세스 토큰 만료 시간 30분, 리프레쉬 토큰 만료 시간 2시간으로 수정해 테스트
        - 쿠키에 토큰이 저장되어 있는 시간도 30분, 2시간으로 수정해 테스트
      - 프론트엔드
        - 인터벌 시간을 15분으로 수정
        - 로그인 만료 시간 30분으로 수정해 테스트
      - 테스트 결과
        - 토큰 만료 시간을 짧게 구성하고 테스트 했을 때와 동일하게 브라우저를 닫고 만료 시간이 한참 지난 후에 다시 접속하면, 로그아웃 되어 있고 로컬 스토리지와 쿠키 내용이 초기화 되어 있는 것을 확인
    - 방법 6
      - 백엔드
        - 액세스 토큰 갱신 유효시간 1시간으로 구성해 테스트
        - 액세스 토큰 만료 시간 1시간, 리프레쉬 토큰 만료 시간 6시간으로 수정해 테스트
        - 쿠키에 토큰이 저장되어 있는 시간도 1시간, 6시간으로 수정해 테스트
      - 프론트엔드
        - 인터벌 시간을 30분으로 수정
        - 로그인 만료 시간 1시간으로 수정해 테스트
      - 테스트 결과
        - 처음에 사용하던 토큰 만료 시간으로 변경하고 테스트해본 결과, 리프레쉬 토큰이 만료 되고 배포한 사이트에 접속하면 로그아웃 되어 있고 로컬 스토리지와 쿠키가 모두 초기화 되어 있는 것을 확인
        - 토큰 만료 시간이 늘어나도 문제없이 로그아웃 되며, 로컬 스토리지와 쿠키 내용이 초기화 되기 때문에 오류 해결
  - 해결 방법
    - 배포된 사이트에 처음 접속하면 바로 로그인 여부를 확인하고, 토큰 만료 시간을 확인해 이미 지났다면 바로 로그아웃 함수를 작동해 로컬 스토리지 내용을 먼저 지우고, 그 다음 쿠키에서 토큰이 삭제되도록 수정
    - 로그아웃 함수에서 쿠키에서 토큰을 삭제하는 fetch 함수 내용과 로컬 스토리지 내용을 지우는 로직 순서를 바꿔서 문제를 해결
    - [코드 내용 1](https://github.com/jeongsangtae/mini-community-platform/commit/b28fd3c980b43b110cfdde4efe189c1b12784e2e)
    - [코드 내용 2](https://github.com/jeongsangtae/mini-community-platform/commit/9d5fcbd72b3f884dd363b7a4a5933f15b1c5e1e5)
