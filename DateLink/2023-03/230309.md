# 오늘 한 일

### 100일 코딩 챌린지 (97일차)

- 분리된 프론트엔드/SPA를 사용하는 이유는 ?

  - 클래식 웹 사이트 대신 API 사용하기위해서, 클라이언트도 갖고 싶기 때문에 그리고 API와 통신하는 모바일 앱을 구축하고 있을 수 도 있기 때문이다.
  - 분리된 프론트엔드는 다른 서버에서 제공되고, 브라우저 측 JS가 사용자 인터페이스 업데이트를 담당하는 곳에서 더 나은 사용자 경험을 제공할 수 있다.
  - 더 나은 경험을 제공할 수 있는데 브라우저 측 JS 코드를 사용하기 때문에 서버의 응답을 기다릴 필요가 없어진다.
  - 사용자의 경우엔 사용자가 버튼을 클릭할 때 페이지가 새로 고쳐지는 것을 보거나 사용자가 응답을 기다리면서 빈 페이지를 보고 있어야 하는건 아니기 때문이다.
  - 하지만 대신 사용자는 사용자 인터페이스만 보고 사용자가 페이지에서 방문자를 다시 로드하지 않고 HTML 파일이 하나만 있기 때문에 다른 페이지를 로드하지 않게 된다.

  <br />

- CORS

  - CORS (Cross-Origin Resource Sharing) : 교차 출처 리소스 공유
  - 단순히 도메인을 의미하는 어떤 출처가 서버에서 제공하는 리소스에 액세스할 수 있는지 서버가 표시할 수 있도록 하는 브라우저 매커니즘이다.
  - 일종의 보안 매커니즘이지만 브라우저에만 적용되고, 클라이언트를 통해 요청을 보낼 수 있기 때문에 실제로 의존해야 하는 보안 매커니즘은 아니다.
  - 사이트를 구축하는 경우에 다른 사이트에서 사용하기 위해 API와 서비스를 잠금 해제하지 않는 한 다른 사용자와 다른 개발자가 제공하는 웹 API 또는 서비스를 사용할 수 없다.
  - 기본적으로 서버 A가 있고, 백엔드 서버인 localhost:3000이 있다고 하면 해당 서버의 리소스는 이 동일한 도메인에서만 요청할 수 있으므로 작동한다.
  - 따라서 서버 A에서 프론트엔드를 실행하는 경우엔 프론트엔드는 서버 A가 제공하는 엔드포인트로 라우트에 JS 기반 요청을 보낼 수 있으며, 거기에서 데이터를 요청할 수 있다.
  - 다른 경우로 localhost:5500에서 프론트엔드를 제공하는 다른 서버가 있는 경우 예를 들어 로컬 호스트는 다른 포트이기 때문에 다른 도메인이다. 이런 로컬 호스트 도메인을 실제 도메인으로 변환할 수도 있다. 실제 호스팅 공급자에게 이런 웹 사이트를 호스팅하려는 경우에 가능 example.com mypage.com 이런 식으로
  - 서버 A는 백엔드를 호스팅하고 있기 때문에 이 경우 서버 B는 기본적으로 해당 서버에서 제공하는 리소스를 요청할 수 없다.
  - 이건 기본값이다. 개발자로서 변경할 수 있지만 오직 백엔드 코드의 개발자만 변경할 수 있다. 그 이유는 브라우저가 즉 다른 사이트가 해당 개발자의 허가 없이 다른 개발자의 API 사용을 시작할 수 없도록 보장하기 때문이다.
  - 물론 여기서 이런 권한을 부여하는 것도 API 백엔드 개발자이다.
  - 따라서 백엔드 코드에서만 CORS 동작을 변경할 수 있다.
  - 또한 다른 응답 헤더를 설정하고 다른 응답 헤더를 설정해야만 변경할 수 있다.
  - 리소스에 액세스하려는 프론트엔드 사이트에서 원하는 모든 요청 헤더를 설정할 수 있다. 거기에서 잠금을 해제할 순 없다. 백엔드만 적절한 응답 헤더를 설정해서 액세스를 허용할 수 있다.
  - 백엔드에서 설정할 수 있는 세 가지 주요 헤더
    - Access-Control-Allow-Origin : 액세스 제어 허용 원본
      - 다른 도메인에서 리소스를 요청할 수 있는 출처를 제어해야한다.
    - Access-Control-Allow-Methods : 액세스 제어 허용 메서드
      - GET, POST, PATCH 와 같이 허용하려는 HTTP 메서드를 설정해서 백엔드 API로 보낼 수 있는 일종의 요청을 서버에서 제어할 수 있다.
    - Access-Control-Allow-Headers : 액세스 제어 허용 헤더
      - 항상 허용되는 기본 헤더 외에 백엔드에서 허용하려는 추가 헤더를 설정할 수도 있다.
    - 참고로 헤더를 추가하는 순서는 중요하지 않다.

  <br />

- setHeader()

  - 응답에 헤더를 추가하기 위해 사용하는 백엔드 프레임워크인 ExpressJS에서 제공하는 메서드이다.
  - 두 개의 매개변수 값이 필요
    - 첫 번재 값은 설정하려는 헤더
      - Access-Control-Allow-Origin
      - Access-Control-Allow-Methods
      - Access-Control-Allow-Headers
    - 두 번째 값은 해당 헤더의 값
      - Access-Control-Allow-Origin
        - 특정 도메인을 지정할 수도 있지만 `*`을 넣어 모든 페이지에서 요청을 보낼 수 있다.
        - 많은 프로젝트에서 작업하는 많은 개발자가 액세스해야 하는 스트라이프 같은 API 구축하는 경우엔 `*`을 넣어 일반적인 유형의 액세스를 제공할 수 있기 때문이다.
      - Access-Control-Allow-Methods
        - 허용하려는 HTTP 메서드를 지정할 수 있다.
        - GET, POST, PATCH, DELETE, PUT
        - 그리고 OPTIONS
          - 어느 곳에서나 직접 보내는 요청이 아니고, 또한 백엔드에서 직접 처리하지 않고 자동으로 전송되는 요청이다.
          - Ajax 요청을 사용할 때 브라우저가 이를 전송한다.
          - 브라우저는 기본적으로 요청을 실제로 전송하려는지 여부를 평가한다.
      - Access-Control-Allow-Headers
        - ex) Content-Type
    - ex) res.setHeader('Access-Control-Allow-Origin', '\*')
    - ex) res.setHeader('Access-Control-Allow-Methods', "GET,POST,PATCH,DELETE,OPTIONS")
    - ex) res.setHeader('Access-Control-Allow-Headers', 'Content-Type')

  <br />

- [CORS와 헤더에 대한 추가 공식문서](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#the_http_response_headers)

<br />

# 오늘 느낀 점

- SPA를 사용하는 이유는 간단하게 말하면 사용자가 더 나은 경험을 할 수 있게 해주는게 가장 큰거같다. 페이지가 새로고침 되는 화면을 보지않아도 되며, 응답을 기다리면서 빈 페이지를 안봐도 된다. HTML파일이 하나만 있기 때문에 다른 페이지를 로드하지 않아도 된다는게 큰 장점인거같다.

- CORS는 결국 브라우저에만 적용되는 보안 매커니즘이며, 다른 사이트에서 함부로 API나 서비스를 사용하지 못하게 막아두는 시스템이다. 결국 사용하고 싶은 리소스가 있는 서버의 백엔드 개발자가 제어를 해제해줘야 사용할 수 있다. 사용하려는 서버의 백엔드 개발자가 권한을 주지않는다면 사용할 수 없게 막아두는 브라우저 보안 매커니즘이라는 걸 기억하고 넘어가야한다고 생각한다.

- setHeader는 결국 백엔드 개발자가 제어를 설정하기 위해 사용하는 ExpressJS 메서드이다. 그 내용에는 특정 도메인을 지정하거나 전체를 지정, 허용하려는 HTTP 메서드를 지정할 수 있고, 추가 헤더도 설정할 수 있는데 이렇게 도메인지정, HTTP 메서드 지정, 추가 헤더 설정 3가지를 제어해 CORS 동작을 변경할 수 있는데 결국 백엔드 개발자의 재량에 따라 제어가 가능한게 핵심인 거 같다.

<br />

# 내일 할 일

- 100일 코딩 챌린지 계속 진행하기 (속도보단 복습과 꾸준한 연습으로 튼튼하게 다지기)

- ExpressJS에 대해 더 깊게 공부하기 (EJS와 함께)

- Advanced-js(고급 JS)에 대해 공부하며 이해하기

- 배포 시작해보기 (정적 웹 사이트 배포 Render와 MongoDB atlas 사용해서 해보기)
