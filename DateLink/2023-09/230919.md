# 오늘 한 일

### React 공부

- HTTP 요청 보내기 (백엔드, DB 연결)

  - 모듈 소개
    - HTTP 요청을 React 어플리케이션에서 백엔드로 보내는 방법을 배우게 될 것
    - React 어플리케이션이 DB와 어떻게 소통하는지도 보게 될 것
    - HTTP 요청을 보내는 방법과 이에 대한 응답을 처리하는 방법, 그리고 어플리케이션에서 로딩에 대한 상태와 오류를 처리하는 방법을 배우게 될 것이다.

  <br />

  - DB에 연결하지 않는 방법 (좀 더 정확히는 직접 연결하지 않는 방법)
    - React 앱이나 일반적인 브라우저 앱에서는, 즉 브라우저에서 실행되는 JS 코드가 DB와 직접 통신하면 절대 안된다.
    - React 앱이 있고 SQL DB, Mongo DB와 같은 DB를 DB 서버에서 실행하는 것은 문제가 안되지만, 매우 불안정하거나 잘못 작성된 어플리케이션이 아니고서야 앱으로 직접 데이터를 가져오거나 저장하고, 연결을 맺는 행위는 외부 환경에서는 절대 해서는 안된다.
    - 기술적으로는 어려울 수 있겠지만 클라이언트 내부에서 DB에 직접 연결을 하게 된다면, 또는 브라우저의 JS 코드를 통해 직접 연결을 한다면 코드를 통해 DB의 인증 정보를 노출시키는 행위가 된다.
    - 브라우저에서 실행되는 모든 JS 코드는 브라우저뿐만이 아니라, 웹 사이트의 사용자들도 접근하고 읽을 수 있기 때문이다.
    - 간단하게 개발자 도구를 열어서 코드를 모두 볼 수 있기 때문이다.
      - 일반적으로 이 부분은 문제가 되지 않는다.
    - 하지만, 코드를 통해 보안과 관련된 세부 사항을 노출하는 것은 문제가 될 수 있다.
      - 예로 DB 접근을 허가하는 인증 정보와 같은 내용
    - 추가로, DB에 직접 접근하는 것은 성능 문제와 같은 다른 문제를 발생시킬 수 있지만 그 무엇보다 보안 이슈 사항이 가장 큰 문제이다.
    - React 앱 코드 내부에서 DB에 직접적으로 통신하는 것 대신에 다른 방법을 사용해야 한다.
      - 예로 백엔드 어플리케이션을 사용하는 것
      - 백엔드는 브라우저 안에서 실행되지 않고, 다른 서버에서 실행되곤 한다.
      - DB와 같은 서버일 수도 있고, 보통은 다른 서버인 경우가 많다.
    - 백엔드 어플리케이션은 내 선택에 따른 모든 서버측 언어를 통해 만들 수 있다.
      - NodeJS, PHP, ASP.NET 등
    - DB와 통신하는 백엔드 어플리케이션은 사용자가 이 백엔드 코드를 확인할 수 없기 때문에 DB의 인증 정보를 안전하게 저장할 수 있다.
      - 다른 서버에 있으므로 웹 사이트 사용자는 이 코드를 절대 볼 수 없다.
    - React 앱은 일반적으로 백엔드 서버, 또는 백엔드 API라고 불리는 서로 다른 URL로의 요청을 전송하는 서버와 통신하게 된다.
    - 이제 인증 정보는 백엔드 앱에 저장되어있고, 백엔드 앱과의 통신은 보안에 관련된 세부 사항이 필요 없으므로 DB와 안전하게 통신을 주고 받을 수 있다.

  <br />

  - [Star War API](https://swapi.dev/)
    - 더미 API로, 전송 요청을 해서 각종 실습을 해볼 수 있는 더미 데이터들이 있다.
    - API로, 백엔드 앱이다. DB가 아님
    - 여기의 백그라운드에서는 아마도 스타워즈 영화에 대한 데이터를 저장하기 위해 DB를 사용할 것이다.
    - 하지만, 강의에서는 백엔드 앱과 소통할 용도로 사용한다.
    - API
      - 어플리케이션 프로그래밍 인터페이스 (Application Programming Interface)
      - 이 용어는 매우 넓은 개념인데, 단순히 React나 HTTP 요청만 있는 것이 아니다.
      - 코드를 통해 명확하게 정의된 인터페이스를 다루며 또 어떤 결과를 얻기 위한, 작업에 대한 규칙이 명확하게 정의된 것을 다루고 있다는 뜻이다.
      - HTTP 요청에 대한 API를 말할 때는 보통 REST, 또는 GraphQL API를 말하게 된다.
        - 이 두 개는 서버가 데이터를 노출하는 방식에 대한 서로 다른 표준이다.
      - Star War API는 REST API로 구성되어 있으며, 아래 쪽의 URL 같은 곳에 내가 요청을 전송하게 되면 특정한 형식에 맞춰서 데이터를 전달해준다.
      - 서로 다른 URL에 각각 다른 요청을 보내게 되면 그에 맞는 서로 다른 데이터들을 제공한다. 이것이 API
      - 접근 위치가 다르면 결과도 서로 다르다.
    - 기본적으로, 이 URL에 요청을 보내게 되면 스타워즈 영화에 출연한 등장 인물에 대한 정보를 얻을 수 있다.
    - 그 외에도 여기 URL을 가져와서 https://swapi.dev/api/films/ 에 요청을 전달하면 지금까지의 서로 다른 스타워즈 영화에 대한 오프닝 크롤 텍스트와 해당 영화의 제목, 그리고 에피로스 번호 등에 대한 정보를 응답을 통해 받을 수 있다.
    - 단순히 더미 API로, HTTP 전송 요청에 대한 소개 정도로 보면 된다.
    - 이제 React 앱에서 Star War API로 요청을 보내서 더미 데이터에 있는 영화 대신에 실제 데이터를 표시하는 걸 연습

  <br />

  - GET 요청 보내기
    - axios 패키지
      - axios 패키지를 통해 어떤 JS 라이브러리를 사용하는가에 관계없이 HTTP 요청 전송을 하고 이에 대한 반응을 매우 간단하게 할 수 있는 패키지
      - 심지어 라이브러리 없이도 사용할 수 있다.
    - Fetch API
      - JS 내에서 HTTP 요청을 전송하는 내장 메커니즘
      - 브라우저 내장형으로, 데이터를 불러오고 이름과는 다르게 데이터 전송도 가능하다.
      - 이 API를 통해 HTTP 요청을 전송하고 응답을 처리할 수 있다.
    - 이번 React에서 GET 요청을 보내는데 사용할 내용은 Fetch API
      - Fetch API를 통해 영화 정보를 가져오도록 구성
    - 사용 방법
      - 새로운 함수 추가
        - fetchMoviesHandler라는 이름의 새로운 함수를 생성
      - 함수 안에 fetch() 함수 추가
        - fetch()
          - fetch는 브라우저가 사용할 수 있게 해준 함수이다.
          - Fetch API를 사용하는 것
          - 이에 대한 가장 단순한 형태는 내가 요청을 전송하려는 URL을 문자열로 전달하기만 하면 된다.
          - `fetch("https://swapi.dev/api/films/");`
          - 이 함수에 두 번째 인자를 전달할 수 있는데 이 인자를 통해 다양한 선택사항을 지정할 수 있는 JS 객체를 전달할 수 있다.
            - 예로, 여기에 추가적인 헤더나 바디 또는 HTTP 요청 메소드의 변경 등
          - 하지만 여기에서는 기본적으로 get() 메소드를 사용하기 때문에, 이 get 요청으로 원하는 걸 할 수 있으므로, 지금은 두 번째 인자가 필요가 없다.
        - 이제 fetch 함수가 호출될 때마다 매 번 HTTP 요청이 전송될 것이다.
        - 하지만 호출에 대한 응답 역시 처리해야 하는데, 이 fetch 함수는 프로미스라는 객체를 반환하는데 이 객체는 잠재적으로 발생할 수 있는 오류나 호출에 대한 응답에 반응할 수 있게 해준다.
        - 프로미스 객체가 반환되었는데, 이는 어떤 즉각적인 행동 대신 어떤 데이터를 전달하는 객체이다.
          - HTTP 요청 전송은 비동기 작업이다. 즉각 끝나는 작업이 아니다.
          - 밀리초, 또는 몇 초가 걸리는 작업이고 당연히 실패할 가능성도 있다.
          - 따라서 코드 다음 줄로 작업을 계속하고 코드의 결과를 바로 사용할 수는 없다.
          - 대신 코드 실행의 결과는 미래의 어느 시점에서 확인할 수 있다.
          - JS에 프로미스 객체가 있는 이유가 이 때문이다.
      - fetch 함수에 then() 추가
        - 이렇게 추가하면 fetch 함수는 응답을 받을 때 호출된다.
        - catch문을 추가해서 잠재적 오류를 처리할 수 있지만, 지금은 무시하고 then에 집중
        - `fetch("https://swapi.dev/api/films/").then();`
      - then의 괄호 안에 response 추가
        - response를 추가하고, 화살표 함수를 사용해 응답을 받은 뒤에 이 함수 본문에서 이 응답을 사용할 수 있다.
        - 여기에 인자로 들어온 response는 객체이며, 요청 응답에 대한 많은 데이터를 갖고 있다.
          - 예로 응답 헤더를 읽거나, 상태 코드를 얻을 수도 있다.
          - ok 영역은 모든 것이 정상이면 true를 반환, 그렇지 않으면 false를 반환한다.
        - 현재 봐야 할 것은 response의 본문으로, API는 데이터를 JSON 형식으로 전송한다.
          - JSON은 데이터 교환에 사용하는 간단하지만 매우 유명한 형식이다.
          - URL 주소로 이동해 내용을 살펴보면, 내용이 마치 JS 객체 같지만 키 값은 큰 따옴표로 묶여 있다.
          - 이 외에도 염두해둬야 하는 규칙들이 존재하는데, 여기에는 메소드가 없고 모두 데이터로 구성되어 있다.
          - JSON 데이터의 또 다른 이점은 JS로의 변환 작업이 필요하지만 그럼에도 불구하고 파일에서 JS 객체로의 변환이 매우 쉽다는 것이다.
          - 다행히 response 객체에는 내장 메소드가 있어서 JSON response의 본문을 코드에서 사용할 수 있는 JS 객체로 자동 변환해준다.
          - 이를 수행하는 방법은 json()
            - response 객체에 있는 내장 메소드
            - 이 메소드가 변환 작업을 해준다.
            - 이 메소드 역시 프로미스 객체를 반환하므로 여기서 내가 해야 할 것은 프로미스를 반환하고 추가적인 then() 구역을 생성해야 한다.
            - 이렇게 하면 이 데이터 변환 작업이 끝날 때 작동하게 된다.
        ```
        const fetchMoviesHandler = () => {
          fetch("https://swapi.dev/api/films/").then((response) => {
            return response.json()
          });
        };
        ```
      - then 구역 추가 및 변환된 데이터 가져오기
        - 여기선 URL이며, 아까 봤던 JSON 구조를 그대로 가질 것이다.
        - 즉, count 영역과 next 영역, previous를 갖고 있고 result 영역은 배열 형식으로 되어 있다.
        - 여기서 원하는 부분은 배열 영역이므로, data.results에 접근해서 해당 배열에 접근하고 이 결과를 상태에 저장하면 된다.
        - 그 뒤에 `data.results` 영역에서 갱신되고 이를 MoviesList에서 사용하는 것
        ```
        const fetchMoviesHandler = () => {
          fetch("https://swapi.dev/api/films/").then((response) => {
            return response.json()
          }).then((data) => {
            data.results
          });
        };
        ```
      - useState 추가해 저장후 전달
        - useState를 import
        - useState 초기 값을 빈 배열로 초기화
        - `data.results` 이 부분에서 파싱 후 추출된 영화를 전달받으면 setMovies를 호출해서 `setMovies(data.results)`로 설정한다.
        - JSON의 배열이 movies에 대한 새로운 상태가 된다.
        - 그 다음 MoviesList로 movies를 props로 전달한다.
        - `<MoviesList movies={movies} />`
      - 들어오는 데이터의 형식 변환
        - 사용하는 MoviesList에서 데이터 형식 이름이 다르게 작성되어 있기 때문에, props를 사용하는 내용의 이름을 바꾸거나, 들어오는 데이터의 형식을 바꿔서 어플리케이션 안에서 원하는 형식으로 변환해야 한다.
          - 현재 진행하는 연습 앱에서는 들어오는 데이터의 형식을 바꿔서 변환해주는 방식을 사용
        - HTTP 요청을 생성하는 App.js에서 data.results를 새로운 상태로 만들기 전에 변수를 추가해 변환 과정을 추가
        - 변수에 전달받는 배열인 data.results로 설정하고, 끝에 map()을 붙여 넘겨받은 배열의 모든 객체를 새로운 객체로 변환한다.
          - `const transformedMovies = data.results.map()`
        - 새로운 객체는 새로운 객체로 채워진 배열이 된다. 그 다음 변수에 저장이 된다.
        - map() 로직은 간단하게 구성
          - 데이터를 가져와, 새로운 객체를 반환하고 id, title, openingText, releaseDate 라는 새로운 키 이름을 지정해 구성해준다.
        ```
        const transformedMovies = data.results.map((movieData) => {
          return {
            id: movieData.episode_id,
            title: movieData.title,
            openingText: movieData.opening_crawl,
            releaseDate: movieData.release_date,
          };
        });
        setMovies(transformedMovies);
        ```
      - 버튼에 이벤트 핸들러 추가
        - 정상적으로 작동하는지 확인하기 위해 버튼에 onClick을 추가해 앞에서 구성한 함수를 추가
        - `<button onClick={fetchMoviesHandler}>Fetch Movies</button>`
    - 정리하면 React 앱 내에서 Fetch API를 사용해, 백엔드로 HTTP 요청을 보내는 연습을 해본 것

  <br />

  - 비동기/대기 사용
    - 프로미스를 다룰 때, then 체인, 즉 then 호출 뒤에 then을 재차 호출할 수 있지만, async와 await라는 다른 문법을 사용할 수도 있다.
    - 함수 앞에 async 예약어를 추가하고, 프로미스를 반환하는 작업 앞에 await 예약어를 사용한다.
    - 이 것은 단순히 코드 변환이며, 백그라운드에서는 then 블록을 사용한 것과 같은 일을 한다.
    - 하지만 좀 더 읽기 편하게 앞에서 미리 `const response = await fetch`라고 하면 앞에 있는 then 블록을 삭제할 수 있으며, `const data = response.json()`이라고 하고 앞에 await를 추가해 구성할 수 있다.
    - 그리고 then 블록에 엮여 있던 중괄호들을 지우게 되면 코드가 더 단순해지게 된다.
    - 이것이 비동기화 코드
    - 겉보기엔 단계적으로 실행이 되는 동기화 작업으로 보이지만 백그라운드에서는 앞에서 했던 방법인 then 호출로 코드가 변환되고 있다.
    - async, await를 추가한 이유는 코드를 읽기 더 쉬워지기 때문이다.
    - 프로미스를 다룰 때는 이런 방법도 선택할 수 있다.
    - 이 기능은 React 특화 기능이 아닌, JS의 기본 기능이다.
    - [async/await로 변경한 내용 코드](https://github.com/jeongsangtae/react-complete-training-http-db/commit/0c0de65f565a52efdccb82619147fa2d3e9b33f3)
      - 코드 내용을 보면 훨씬 읽기 쉽고 단순해진 것을 볼 수 있다.
      - 그리고 강의에서는 화살표 함수를 사용하지 않고, 일반 함수를 사용해서 function 앞에 async를 사용, 하지만 화살표 함수에서 async를 추가하려면 `const fetchMoviesHandler = async () => {}`와 같이 추가를 해야 한다.

  <br />

  - 로딩 및 데이터 state 처리하기
    - 실제로 로딩 과정 중에 로딩 아이콘이나, 로딩 텍스트를 표시해서 사용자에게 현재 데이터를 불러오고 있다는 신호를 보내기도 하는데, 그러한 내용을 추가하는 파트
      - 이 내용은 상태 관리를 통해 할 수 있다.
    - 새로운 상태를 추가
      - `const [isLoading, setIsLoading] = useState(false)`
    - fetchMoviesHandler를 호출해서 해당 함수가 실행될 때 setIsLoading가 true로 변경되게 구성
      - 이렇게 하면 로딩을 시작할 때 상태 변화가 발생한다.
    - await 블록이나, setMovies 이후에 setIsLoading을 다시 호출해 false로 값을 변경
      - 사실 "이후"라는 말이 이상한데, 이유는 이 작업들은 비동기화 작업이기 때문이다.
      - 데이터 로딩이 끝났고, 데이터를 정상적으로 가져왔기 때문이다.
    - 이제 isLoading의 상태를 이용해 로딩 아이콘이나 로딩 텍스트를 렌더링할 수 있게 됨
    - MovieList에서 로딩중이 아닐 때만 MovieList를 렌더링하도록 구성
      - 앞에서 배운 것처럼 구문을 중괄호로 감싸고 isLoading이 false일 때 렌더링하게 하면 된다.
      - 즉, 로딩 중이 아니라면 렌더링하게 된다.
      - 초기 값으로 false, !false가 되어 true가 되면서 뒤에 있는 구문이 보이게 되는 방식
      - 반대로 로딩중이면 화면에 "Loading..." 이라는 문구를 표시하게 구성
      ```
      {!isLoading && <MoviesList movies={movies} />}
      {isLoading && <p>Loading...</p>}
      ```
    - 물론 사용할 수 있는 상태가 "로딩중인", "로딩 중이 아닌"만 있는 것이 아닌, 로딩이 완료되었으나 영화가 없을 때를 위한 또 다른 내용을 표시할 수도 있다.
      - movies가 빈 배열이라서 화면에 표시할 것이 없을 때 같은 경우
    - 영화 내용을 보여주는 조건 추가
      - MoviesList를 렌더링하는데 로딩 중이 아닐 때와 movies.length가 0 이상일 때면 로딩이 완료되고, 영화가 1편 이상 존재한다는 뜻으로, 이럴 때만 MoviesList를 표시하게 할 수도 있다.
      - `{!isLoading && movies.length > 0 && <MoviesList movies={movies} />}`
    - 로딩이 끝났는데 영화가 없는 경우, 이에 대한 대체 텍스트 표시
      - `{!isLoading && movies.length === 0 && <p>Found no movies</p>}`
    - 이 내용은 UI 구축 과정에서 매우 중요한 부분으로, 사용자에게 어플리케이션의 현재 상태를 알려야 하기 때문이다.

<br />

# 오늘 느낀 점

- 오늘 스타 워즈 API를 연결해 더미 API 데이터로, HTTP GET 요청을 연습해볼 수 있었다. 예전에 JS, NodeJS 공부할 때 정말 많이 연습을 했었던 내용인데, 최근에 React만 해서 그런지 내용들이 조금 어색하게 느껴졌다. 그래도 계속 듣다보니, fetch 함수도 기억이 나고, then 함수에 대한 내용도 기억이 났으며, reponse를 사용하는 것도 기억이 났다. 그리고 async/await 내용은 정말로 NodeJS로 게시판을 만들 때 자주 사용해서 너무 친근하게 느껴졌다. 오늘 배운 내용은 React에서 특화된 기능이 아닌, JS의 기본 기능이라서 React를 공부하기 전에 JS 공부할 때 배우고, 사용해본 내용이라서 좀 더 수월했던 거 같다. 단지, 이 내용을 JS가 아닌 React에서 적용하는게 처음에는 어디 위치에서 추가를 해야 하는지, 일반 함수가 아닌 화살표 함수에서 async를 어디에 추가해야 하는지 이러한 부분이 조금 헷갈렸던 거 같다. 확실히 좀 사용해보니 적응이 되어가는 것 같다. 그리고 로딩 및 데이터 state 처리 부분도 정말 도움이 많이 된 거 같은데, 내가 React 완주하고 나서 개인 프로젝트로 영화 API를 가져와서 저런식으로 보여지도록 하는 것을 구상 중인데, 데이터가 로딩중일 때 로딩중이라는 내용이 보여지고, 검색 결과가 없을 때 없다고 보여지는 화면을 구성하는 것을 사실 다 알려준 것이나 다름이 없기 때문에 나중에 활용할 수 있을 거 같아서 좋다고 생각이 된다. 이제 React에서 HTTP POST 요청을 접목시키는 방법이나, useEffect를 사용해 처리하는 방법 등 내용이 좀 남았는데 마무리하고, 커스텀 React Hook 내용으로 넘어갈 예정이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
