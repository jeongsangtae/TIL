# 오늘 한 일

### React 공부

- 클래스 기반 컴포넌트

  - 무엇을 & 왜
    - 클래스 기반 컴포넌트는 함수 컴포넌트에 대한 대안이다.
    - 최근의 기본 값은 함수형 컴포넌트를 사용하고, 대부분의 React 프로젝트에서 함수형 컴포넌트만을 사용한다.
      - 클래스 기반 컴포넌트는 하나도 사용하지 않을 수도 있다.
      - 최근, 오류 경계의 예외 때문에라도 클래스 기반 컴포넌트를 사용할 이유가 없다.
      - 개인적으로 선호하는 것이 아니라면, 굳이 클래스 기반 컴포넌트를 사용할 필요가 없다. 그냥 클래스 기반 컴포넌트를 선호할 수도 있는데 전혀 문제될 것은 없다.
      - 함수형 컴포넌트를 통해 만들 수 있는 건 클래스 기반 컴포넌트도 마찬가지다.
      - 단지, 서로 다른 멘탈 모델을 요구할 뿐이다.
    - 클래스 기반 컴포넌트가 존재하는 이유는 과거 React 16.8 이전에 이러한 것들을 사용하는 시나리오와 유스 케이스 같은 것들이 존재했었다. 특히 상태를 처리하고 side effect를 다룰 때 클래스 기반 컴포넌트를 사용했어야 했다.
      - 16.8 이전에는 함수 컴포넌트에서는 상태 변경이 불가능했고 side effect 역시 다룰 수 없었다.
      - 16.8 이후 React에서 React Hook 이라는 Hook에 대한 모든 개념을 도입한 후 함수형 컴포넌트를 사용하기 시작했다.
      - useState, useEffect 같은 것들이 사용되기 시작함
      - React Hook의 useState, useEffect와 같은 것들이 함수형 컴포넌트에서 사용할 수 있는 특징들이었고, 예전에는 클래스 기반 컴포넌트에서만 가능했던 것들이다.
    - React Hook은 클래스 기반 컴포넌트에서는 사용이 불가능
      - 매우 중요!
    - render 방식으로 정의해서 사용
      - render는 예약어로, 반드시 이런 단어를 사용해야 한다.
    - React가 render 메소드를 호출해서 무엇이 스크린에 렌더링되어야 하는지를 평가하는 식으로 작동

  <br />

  - 함수형 컴포넌트에서 클래스 기반 컴포넌트로 변경 및 클래스 기반 컴포넌트 추가

    - Uses 컴포넌트를 클래스 기반 컴포넌트로 변경 및 클래스 기반 컴포넌트 추가
    - class 예약어 입력
      - 이건 단순히 JS에 빌드하는 것이다.
      - React가 아니다.
      - 모던 JS는 클래스를 지원한다.
    - class 예약어와 클래스의 이름, 클래스 정의 내용이 있는 중괄호로 구성
      - `class User {}`
    - 중괄호 안에는 메소드를 추가하는 것으로 시작
      - `constructor() {}`
      - 여기에는 초기화 작업이 들어가면 된다.
      - 현재 연습하는 컴포넌트에서는 초기화 작업이 필요가 없으니 굳이 추가히지 않아도 된다. 나중에 다시 살펴볼 예정
    - 중괄호 안에 render() 메소드 추가
      - `render() {}`
      - render 메소드는 React에 필요한 특정 메소드로 React가 JSX 코드 안에 컴포넌트가 사용된 것을 확인하면 그 때 호출하는 메소드이다.
      - React가 render 메소드를 호출해서 무엇이 화면에 렌더링되어야 하는지 찾는다.
      - 따라서, render 메소드는 함수형 컴포넌트에서의 반환 문장(return)과 동일하다.
      - render 메소드 안에는 렌더링할 것을 알려주는 반환 값이 필요하다.
      ```
      class User {
        render() {
          return <li className={classes.user}>{props.name}</li>;
        }
      }
      ```
    - 이론상으로는 클래스에 원하는 만큼 메소드를 여러 개 추가할 수 있고 이름도 원하는 대로 지을 수 있다.
    - 함수형 컴포넌트에서는 props를 매개변수로 전달받는데, 이 props는 React가 자동으로 전달을 해줬었다. 하지만 클래스형 컴포넌트에서는 그렇지 않다.
      - render 메소드는 props를 받지 않는다.
      - 대신 다른 것을 필요로 한다.
    - React에서 component를 import
      - `import { Component } from 'react';`
      - Component를 import하고, class (이름)에 extends Component를 추가
      - 이 확장이란 것은 모던 JS의 내장 개념이다.
      - 클래스를 만들고, 이를 확장하는 기능
      - 이 방법으로 다른 클래스로부터 상속받는 것이다.
      - 이제 Component 클래스로부터 상속을 받은 User 클래스는 React를 통해 정의한 클래스이다.
      - props로 접근할 수 있도록 `this`를 추가
        - 이게 가능한 이유는 컴포넌트를 확장했기 때문에 가능하다.
        - 이를 통해 예약어 this라는 것을 가지고 props에 접근할 수 있게 된다.
        - this는 컴포넌트로 받은 모든 props를 포함한다.
      ```
      class User extends Component {
        render() {
          return <li className={classes.user}>{this.props.name}</li>;
        }
      }
      ```
    - 클래스 기반 컴포넌트는 함수형 컴포넌트와 함께 작업이 가능하다.
      - Users는 함수형 컴포넌트지만, 이 것이 렌더링하는 User는 클래스 기반 컴포넌트이다.
      - 전혀 문제가 되지 않는다.
      - 클래스 기반 컴포넌트 역시 함수형 컴포넌트를 렌더링할 수 있다.
      - 결론적으로, 둘은 모두 컴포넌트이다. 필요하다면 둘을 섞어서 쓸 수 있다.
    - 실제로 프로젝트를 빌드할 때 대부분의 경우에는 함수형 컴포넌트를 쓰겠지만, 클래스 기반 컴포넌트도 쓸 수 있다.
      - 섞어서 사용해도 되지만, 대부분은 현재 존재하는 어플리케이션에 새로운 기능을 추가하고 클래스 기반 컴포넌트에서 함수형으로 이관을 하는 방식을 사용한다.
    - Component 클래스에 컴포넌트로서 작업을 할 수 있게 해주는 중요한 기능 추가

  <br />

  - 클래스 기반 컴포넌트에서 state 및 이벤트 작업하기

    - Users 컴포넌트를 클래스 기반 컴포넌트로 바꾸는 작업도 포함
    - User 컴포넌트와 마찬가지로 Component import
    - render 메소드 추가
    - this라는 props를 통해 props에 접근하는 것 대신 state를 이용해 구성
    - 클래스 컴포넌트에서는 render 메소드 안에 함수를 추가하지 않는다.
      - 기술적으로는 가능하지만 올바르게 작동하지 않을 수 있다.
      - 클래스이기 때문에 클래스 전체를 그룹화해서 내부의 기능을 그룹화할 수 있다.
    - render 메소드 밖에서 이벤트 핸들러 메소드를 추가해 구성
      - 클래스의 메소드를 정의하는 방법은 여러 가지 방법이 있지만, 보편적으로 사용하는 방법이 있다.
        - `toggleUsersHandler() {}`
        - 이와 같은 방식으로 사용
    - state를 추가하는데 2가지 작업이 필요하다.
      - 초기화
        - useState 첫 호출시 하는 것과 같다.
      - state 정의
        - 함수형 컴포넌트의 toggleUsersHandler처럼 필요할 때 업데이트하는 것을 말한다.
        ```
        const toggleUsersHandler = () => {
          setShowUsers((curState) => !curState);
        };
        ```
    - 클래스 컴포넌트에서 상태를 정의할 때는 생성자라는 것을 사용
      - constructor
        - `constructor() {}`
      - 생성자 함수는 해당 구문이 인스턴스화될 때, React가 컴포넌트로 사용되는 클래스를 만날 때 자동적으로 호출된다.
      - 그 뒤, 생성자에서는 상태 초기화와 같은 초기화 작업을 할 수 있다.
      - this.state에 접근해서, state 객체와 같게 설정한다.
        - 이 부분은 매우 중요한데, 클래스 컴포넌트에서는 state가 항상 중요하고 객체 형태이다.
        - 함수형 컴포넌트에서는 불리언이나 문자열, 또는 숫자와 같이 어느 형태든 될 수 있다. 심지어 객체도 될 수 있을 정도로 유연하다.
        - 하지만 클래스 컴포넌트는 그렇지 않으므로, 항상 객체 형태로 구성해야 한다.
        - 그리고 state라는 이름의 속성이 되어야 하며, 이 이름은 내가 수정할 수 없다.
        - 상태에 필요한 라이센스나 조각들을 하나의 상태 객체로 만들기 때문에 항상 객체로 구성해야 한다.
        - 클래스 컴포넌트에서는 이것이 강제되어, 무조건적으로 컴포넌트를 구성하는 모든 상태를 하나의 객체로 만들어야 한다.
        - 상태 조각들의 관련 여부와는 상관 없이 꼭 이렇게 해야 한다.
        ```
        constructor() {
          this.state = {
            showUsers: true,
            more: "Test",
          };
        }
        ```
      - 상태를 변경하려고 할 때 사용 방법
        - this.state에 접근해서 변경하면 안된다.
        - this.setState라는 특수한 메소드를 사용한다.
          - 이 메소드는 Component를 상속받은 모든 클래스에서도 사용할 수 있다.
          - setState 역시 항상 객체를 사용한다.
          - 이 객체는 설정하려는 새로운 상태를 포함한다.
          - 하지만, 기존의 상태를 오버라이드하지 않고 React가 백그라운드에서 현재 존재하는 상태와 setState에 전달하려는 객체를 결합시킨다.
            - 이 내용은 매우 중요
          - 만약 state에서 또 다른 상태가 있는 경우
            - 변경한 상태의 내용은 적용되지만, 변경하지 않은 다른 상태는 가려지게 된다.
            - React가 이 갱신 내용을 기존 상태에 오버라이드하지 않고, 기존의 상태와 병합을 하기 때문이다.
          - 클래스의 setState와 함수의 useState와는 분명히 다른 행동이다.
            - 함수형 컴포넌트의 useState는 상태 갱신 함수를 호출하게 되면 기존의 상태를 갱신 함수에 전달한 값으로 오버라이드 하기 때문이다.
          ```
          toggleUsersHandler() {
            // this.state.showUsers = false // 틀린 방법
            this.setState({showUsers: false})
          }
          ```
      - setState에서 갱신 함수 사용
        - 항상 showUsers 값을 false로 둘 필요가 없기 때문에 이전 값의 반대값으로 지정하기 위해서 갱신 함수를 사용
        - useState에 있는 갱신 함수를 setState 또한 사용 가능하다.
        - setState 또한 갱신 함수를 지원한다.
        - 새로운 상태를 갖는 객체 대신에 갱신 함수를 setState에 전달
        - 만약 새로운 상태가 이전 상태에 의존한다면 useState와 동일한 방법을 사용해야 한다.
        - useState와 비슷하게 갱신 함수를 사용하지만, setState에서는 객체를 전달하듯이 새로운 객체를 반환하도록 해야 한다.
        - setState에서 반환하는 것은 기존 상태와 결합된 것
          - 따라서 state에서 또 다른 상태 값이 있다면 그 값은 손실되지 않는다.
        ```
        toggleUsersHandler() {
          // this.state.showUsers = false // 틀린 방법
          this.setState((curState) => {
            return { showUsers: !curState.showUsers };
          });
        }
        ```
      - 업데이트한 state를 사용
        - state가 필요한 render 메소드에서 `this.state`를 앞에 추가해 state 객체에 접근해 사용
          - `{this.state.showUsers ? "Hide" : "Show"} Users`
          - `{this.state.showUsers && usersList}`
          - 이렇게 함으로써 showUsers 프로퍼티에 접근할 수 있다.
      - 추가한 이벤트 핸들러 메소드를 사용하는 방법
        - `<button onClick={toggleUsersHandler}>`
          - toggleUsersHandler를 위와 같이 써서 호출하는 것은 잘못된 방법이다.
        - `<button onClick={this.toggleUsersHandler}>`
          - 위와 같이 클래스의 메소드 부분을 가리켜야 한다.
          - 하지만, 이 역시 JS의 작동 방식 때문에 정확히 작동하지는 않는다.
          - 이 this 예약어가 JS에서 좀 까다로운 부분이고, React와는 관련이 없다.
        - 메소드 안의 this 예약어가 주위를 둘러싼 클래스를 참조하고 있는지를 확인해야 한다.
          - 클릭과 같은 이벤트를 통해 메소드가 호출되어도 기본적으로 위 예시와 같은 동작은 하지 않는다.
          - 그렇기 때문에 해당 문제를 해결하기 위해 bind, 또는 bind(this)라는 것을 이용해야 한다.
          - `<button onClick={this.toggleUsersHandler.bind(this)}>`
          - 코드가 평가될 시점의 동일한 값이나 동일한 내용을 갖도록 설정된다.
          - `bind(this)` 여기의 this 예약어는 이 클래스를 참조한다는 의미가 된다.
        - 다시 강조하지만, 위의 방식은 JS의 방식이다.
        - 함수형 컴포넌트는 클래스를 가리키기 직전에 함수를 정의하기 때문에 이런 작업이 필요하지 않다.
          - 클래스 안에서 작업하는 것이 아니기 때문에 this와 같은 예약어를 쓸 필요가 없다.
      - 클래스에 생성자를 추가하고 이를 다른 클래스로 확장하게 되면 `super()`라는, 상위 클래스의 생성자를 호출하는 메소드를 사용해야 한다.
        ```
        class Users extends Component {
          constructor() {
            super();
            this.state = {
              showUsers: true,
              more: "Test",
            };
          }
        ```

  - 컴포넌트 생명 주기
    - 클래스 컴포넌트에만 해당되는 내용으로, 함수형 컴포넌트와는 관계 없다.
    - 클래스 컴포넌트에서는 React Hook을 사용할 수 없기 때문에 useEffect를 사용할 수 없다.
      - 대신 클래스 컴포넌트는 컴포넌트 생명 주기라는 개념이 존재한다.
    - 좀 더 정확히 말하면 모든 컴포넌트는 생명 주기를 가진다.
      - 예로, DOM에 렌더링되거나 DOM에서 삭제될 때, 특정 메소드를 통해 생명 주기가 다른 2개의 클래스 컴포넌트를 서로 다른 시점에서 추가할 수 있다.
    - 클래스 컴포넌트에 추가할 수 있는 생명 주기 메소드는 `componentDidMount()` 메소드
      - render 메소드와 같은 내장 함수로 React에서 import 해온 내장 컴포넌트를 확장하면 바로 사용할 수 있다.
      - 이 메소드를 추가하면, React가 컴포넌트가 마운트된 직후에 이 메소드를 호출한다.
      - 즉, 컴포넌트가 평가되고 DOM에 렌더링될 때 호출
      - useEffect를 사용한 것과 같다.
        - effect 함수가 있고, 의존성 배열도 있음
        - 모든 effect 함수는 컴포넌트가 처음 마운트 될 때 실행된다.
        - 하지만 의존성이 없다면, 즉 의존성 배열이 비어있다면 effect 함수는 딱 한 번만 실행된다.
        - effect를 빈 의존성 배열과 함께 추가한다면 이는 componentDidMount()와 같은 역할을 수행한다.
        - `useEffect(..., [])`
    - 추가할 수 있는 또 다른 생명 주기 메소드는 `componentDidUpdate()`와 `componentWillUnmount()`
      - componentDidUpdate()
        - 컴포넌트가 갱신되면 호출된다.
        - 무언가, 상태 같은 것이 변경되거나 하면 컴포넌트가 재평가, 재 렌더링되면 그 때 호출된다.
        - 이 것은 의존성 배열이 있는 useEffect와 동일하다.
        - 의존성 배열이 변경되면 useEffect 함수 역시 재실행되고, 의존성 배열은 컴포넌트가 재평가 및 재 렌더링될 때 재평가된다.
        - `useEffect(..., [someValue])`
      - componentWillUnmount()
        - 컴포넌트가 DOM에서 삭제되기 직전에 호출되며 이 것은 useEffect에 있는 cleanup 함수와 같다.
        - cleanup 함수는 effect 함수가 다시 실행되기 직전에 호출되며, 항상 컴포넌트가 DOM으로부터 삭제되기 전에 다시 호출된다.
        - `useEffect(() => { return () => {...}}, [])`
    - `componentDidMount()`, `componentDidUpdate()`, `componentWillUnmount()` 이렇게 3개가 가장 보편적이고 가장 중요한 메소드이다.
      - 이 외에 좀 덜 중요한 생명 주기 메소드들도 있지만 이 3개가 제일 중요하다.

  <br />

  - [함수형 컴포넌트에서 클래스형 컴포넌트로 바꾼 전체 코드](https://github.com/jeongsangtae/react-complete-training-class-component/commits/main)

<br />

# 오늘 느낀 점

- 클래스형 컴포넌트를 소개하는 모듈 소개에서 클래스형 컴포넌트 때문에 의욕을 잃기 전에 100% 선택 사항이라고 말을 해주었다. 최근의 React 프로젝트에서는 거의 이 방법을 사용하지 않는다고 한다. 그래서 클래스형 컴포넌트를 생략할 수도 있지만, 아직 여전히 많은 서드 파티 라이브러리나 내가 일할 수 있는 프로젝트에서 클래스형 컴포넌트를 볼 수 있기 때문에 클래스형 컴포넌트에 대해 설명을 해준다고 한다. 더 이상 클래스형 컴포넌트 방법을 사용하지 않지만, 그래도 알아둬서 손해보는 건 없다고 생각이 되어 넘기지 않고 진행하기로 결정하였다.

- 오늘 클래스형 컴포넌트를 배우고 구성 변경을 실습 해본 결과 느낀점은 정말로 클래스형 컴포넌트의 코드는 복잡하고, 어지럽고, 어렵다는 생각이 들었다. 함수형 컴포넌트보다 코드도 훨씬 길어지고, 구성도 복잡하고 어렵게 되어있다는 생각이 들었는데 좀 더 간단하게 될 수 있는 코드를 너무 복잡하고 길게 늘어진 느낌을 받았다. 왜 많은 개발자들이 이제 클래스형 컴포넌트보다 함수형 컴포넌트를 사용하는지 확실하게 알게 되었다. 함수형 컴포넌트에서 React Hook이 없을 때는 어쩔 수 없이 상태 관리를 하기 위해 클래스형 컴포넌트를 사용했지만, 이제는 React Hook을 통해 함수형 컴포넌트에서 상태 관리를 할 수 있기 때문에 굳이 복잡하고 어려운 클래스 컴포넌트로 구현을 할 필요가 없어진 것 같다. 상태 관리, 라이프사이클 메서드, 가독성, 재사용성 이런 측면들을 비교했을 때 더 이상 클래스형 컴포넌트가 함수형 컴포넌트보다 더 나은 점이 없다고 생각이 되며, 무엇보다 가독성과 재사용성이 더 뛰어난 함수형 컴포넌트를 사용하는 것이 맞다고 생각이 된다. 그렇지만 앞에서 말했듯이 예전에 만든 React 프로젝트나, 일할 수 있는 프로젝트에서 클래스형 컴포넌트를 볼 수 있기 때문에, 클래스형 컴포넌트를 구성하는 내용에 대해 듣고 정리한 다음 넘어갈 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
