# 오늘 한 일

### React 공부

- HTTP 요청 보내기 (백엔드, DB 연결)

  - HTTP 오류 처리하기
    - 요청이 전송되고, 오류 응답 코드를 넘겨받은 기술적인 오류를 처리하는 파트
      - 404, 500, 401과 같은 오류를 말함
    - 이와 같은 경우에는 많은 정보를 제공하지 않으므로,위키피디아와 같은 문서를 찾아봐서 각각에 대한 응답 코드를 알아봐야 한다.
    - 200이나 201같이 2xx로 시작하는 코드는 정상적인 응답을 뜻한다.
      - 즉, 요청이 전송되고, 서버가 성공적으로 반응한 것
    - 요청을 보낼 때 400이나 500과 같은 반응도 얻을 수 있다.
    - 접근을 허가받지 못한 자원에 대해서 요청을 할 때도 있다.
    - 요청이 성공적으로 전송되었고 이 과정에서 아무런 기술적인 문제가 없는데 서버가 401, 또는 403과 같은 응답을 한다면 서버가 요청을 받았으나, 내가 원하는 응답을 주지 않았음을 의미한다.
      - 기술적으로는 성공적으로 응답을 받았으나, 응답에 오류 상태 코드가 포함되어 있어서 오류 문자를 받는 것
    - 5xx대와 같은 응답은 서버에 오류가 있을 때 발생
    - [더 많은 자세한 에러 참조 페이지](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    - 유효하지 않은 URL로 요청을 보내서 HTTP 오류를 확인하고 처리해보는 연습
    - 어플리케이션을 사용하는 사용자에게 오류 메시지와 같은 것을 표시해서 문제가 발생했음을 보여주도록 처리하는 연습
    - 오류 처리 방법
      - error useState를 추가
        - error 초기 값은 null로 설정
      - 함수가 작동하면 해당 error를 null로 되돌려야 한다.
        - 이전에 받았을 수도 있는 오류를 초기화하는 작업
      - 실제로 오류가 발생했다면 null 이외의 값을 사용해야 한다.
      - async/await를 사용하지 않고, then을 이용해 작업한다면 `.catch()`를 추가해 오류를 확인해야 한다.
      - 하지만 async/await를 사용한다면 try-catch를 사용해야 한다.
        - 코드를 실행 시도(try)해서 잠재적인 오류를 포착(catch)하는 방식
        - 어떤 오류가 발생했다면 catch에서 확인할 수 있게 된다.
      - fetch API는 이러한 에러 상태 코드를 실제 에러로 취급하지 않는다.
        - 실제로 오류 상태 코드를 받아도 기술적인 오류로서 처리하지 않는다.
        - 따라서 어떤 문제가 발생해도 이를 실제 오류로 처리하지 않는다.
        - 가져오지 못한 데이터로 어떤 작업을 하려고 할 때만 오류가 발생한다.
      - axios는 요청 전송에 성공한다면 오류 상태 코드에 맞는 오류를 만들어서 전달한다.
        - 하지만, 현재 axios를 사용하지 않고 fetch API를 사용하고 있으니 직접 만들어서 사용해야 한다.
      - 전달받게 되는 response 객체에는 ok라는 필드가 있는데, 이걸 사용해 구성
        - 요청이 성공적인지 그렇지 않은지를 표시하는 부분으로, 응답이 ok가 아닌지 확인하고 이에 대해서 자체적인 오류를 만들어서 표시하면 된다.
        - 적당한 오류 메시지를 만들어서 새로운 오류를 만들어낸다.
        - 서버에서 돌아오는 오류 응답으로부터 오류 메시지를 읽어들일 수도 있고, 내가 만든 메시지를 사용할 수도 있다.
        ```
        if (!response.ok) {
          throw new Error("Something went wrong!")
        }
        ```
      - 오류를 응답에 문제가 있을 때 표시하도록 구성
        - 오류가 발생하면 그 다음 단계의 코드는 진행이 안될 테니, 대신에 catch 블록을 만들어두는 방식
        - catch 블록에서 setError를 호출해 error.message로 설정
        - `setError(error.message)`
      - 설정한 오류를 표시되도록 구성
        - 먼저 로딩 중이 아닌지를 확인, 로딩 중이면 이에 대한 결과를 기다려야 하기 때문이다.
        - 로딩중이 아니고, 오류가 있다면, 즉 Error가 null이나 undefined가 아니고 값이 존재한다면 해당 오류를 표시해야 한다.
        - `{!isLoading && error && <p>{error}</p>}`
      - 오류가 발생하게 되면 더 이상의 로딩은 필요가 없기 때문에 로딩이 중단되도록 해야 한다.
        - setIsLoading(false)을 catch 블록 안에 추가 하는 방법
          - catch 블록 안에서 setIsLoading(false) 추가
        ```
          setMovies(transformedMovies);
          setIsLoading(false);
        } catch (error) {
          setError(error.message);
          setIsLoading(false);
        ```
        - setIsLoading(false)을 try-catch 블록 뒤로 설정하는 방법
          - 응답을 성공적으로 받았거나 오류를 받았든 간에 상관없이 setIsLoading이 false가 되어 로딩이 끝났음을 알리는 방식
          ```
            setMovies(transformedMovies);
          } catch (error) {
            setError(error.message);
          }
          setIsLoading(false);
          ```
      - 이렇게 구성하면 메시지가 뜨는데 코드 안에서 설정한 것이 아닌, JSON에 대한 응답을 호출했는데 해당 구문이 실패해 다른 메시지가 뜨는 것
        - 유효하지 않은 API 엔드 포인트에 대해 요청을 했고 따라서 JSON 데이터를 받지 못했기 때문이다.
      - reponse 바디 부분을 파싱하기 전에 response의 응답이 ok인지를 확인하도록 변경
      - 오류 응답을 다루는 좀 더 확실한 방법은 어떤 API와 통신하는지에 달려 있다.
        - 몇몇 API는 요청이 성공적이지 못해도 JSON 데이터를 보내고 이와 같은 API는 JSON 데이터를 보내지 않는다.
        - 따라서 파싱 전에 이에 대한 처리를 해야 한다.
        ```
        const response = await fetch("https://swapi.dev/api/film/");
        if (!response.ok) {
          throw new Error("Something went wrong!");
        }
        const data = await response.json();
        ```
      - 영화 정보를 찾을 수 없다는 메시지와 에러 메시지가 함께 출력되기 때문에 변경
        - `{!isLoading && movies.length === 0 && !error && <p>Found no movies</p>}`
    - 어떤 백엔드 어플리케이션과 통신하든 간에 서로 다른 state들을 맞다뜨릴 수 있으므로 처리 방법을 아는 것은 중요하다.
    - 항상 응답을 기다리게 되다 보면 오류를 받을 수도 있고, 데이터를 받을 수도 있는데 이 데이터가 비어있을 수도 있다.
      - 사실 대부분은 빈 상태일 것이다.
    - 이런 여러 가지의 시나리오를 다룰 줄 알아야 한다.
    - 코드 안에서 모든 조건을 확인하는 대신 다른 방법도 사용 가능
      - content라는 새로운 변수를 추가
      - 변수의 기본 값은 "Found no movies"
        - `let content = <p>Found no movies</p>`
      - state에 따라 해당 변수의 값이 다르게 되도록 변경
      - 요청을 통해 데이터를 받아올 때의 경우
      ```
      if (movies.length > 0 ){
        content = <MoviesList movies={movies} />
      }
      ```
      - 오류가 있는지 확인해서 오류가 있다면 content의 값은 `{error}`가 되도록 구성
      ```
      if (error) {
        content = <p>{error}</p>
      }
      ```
      - if문을 추가해 현재 로딩 중에 있다면 content의 값을 "Loading..."과 같이 변경하거나 내가 원하는 값으로 변경되도록 설정
      ```
      if (isLoading) {
        content = <p>Loading...</p>
      }
      ```
      - 이제 JSX 코드에 추가해놓은 조건 코드를 제거하고 앞에서 설정한 변수 `{content}`만 렌더링한다.
      - 이렇게 하면 content 변수에 있는 값은 각각의 state에 따라 달라지게 된다.

  <br />

  - 요청에 useEffect() 사용하기
    - 데이터를 즉시 fetch 하기 위해 useEffect 사용
    - 이게 가능한 이유는 HTTP 요청 전송은 일종의 사이드 이펙트로 컴포넌트의 상태를 바꿔버리기 때문이다.
      - 이러한 사이드 이펙트는 useEffect에 들어가야 한다.
    - 함수로 집어넣는 것 역시 상관은 없다. 그 함수를 메인 컴포넌트의 함수 일부분으로 호출하지 않으면 문제없다.
      - 함수 호출이 되는 순간 상태의 갱신이 발생하고 컴포넌트 함수가 재 렌더링, 재평가되면서 함수가 다시 호출되는 무한 루프가 발생하여 문제가 되기 때문이다.
      - 이러한 상황을 피하기 위해 useEffect를 사용하는 것
    - useEffect는 컴포넌트가 렌더링되는 주기 안에서 사용되어야 하는 코드가 있을 때 유용하다.
    - 사용 방법
      - useEffect를 import
      - useEffect에서 fetchMoviesHandler()를 호출
        - 이제 fetchMoviesHandler 함수는 버튼을 클릭하면 호출되지만, 동시에 컴포넌트 재평가가 발생할 때도 호출된다.
      - 무한 루프 문제가 발생할 수 있으므로, 컴포넌트 재평가가 발생할 때마다 이를 호출하지 않게 두 번째 인자 추가
        - 의존성 배열 호출
        - fetchMoviesHandler를 포인터를 통해, 의존성으로 가리키도록 한다.
        - 이 함수가 변경되면 effect는 재실행되고 외부 상태를 이용한다면 해당 함수도 바뀔 수 있기 때문이다.
        - 문제는 fetchMoviesHandler는 함수이고, 당연히 객체이기 때문에 컴포넌트가 재 렌더링될 때마다 함수 역시 바뀌게 된다.
        - 따라서 이를 의존성으로 추가하게 되면 무한 루프가 발생한다.
        - 이에 대한 해결책 중 하나는, fetchMoviesHandler를 의존성 배열에서 제거하는 것
          - 배열에서 제거되어도, 원하는 결과는 나오기 때문에 문제없다.
        - 하지만 함수가 외부 상태를 사용한다면 의도치 않은 버그가 발생할 수도 있다.
        - 따라서, 가장 좋은 해결책은 useCallback Hook을 사용하는 것
        ```
        useEffect(() => {
          fetchMoviesHandler();
        }, [fetchMoviesHandler]);
        ```
      - useCallback 추가
        - useCallback를 import한 뒤 fetchMoviesHandler 함수를 감싸도록 구성
        - 이를 위해서, fetchMoviesHandler는 useCallback의 결과를 저장하는 상수가 되어야 하므로 상수 형태로 변경하고, 화살표 함수를 통해 이를 감싸준다.
        - useCallback에 대한 의존성 배열도 추가
        - async가 추가되어 있기 때문에 async 예약어를 익명 화살표 함수 앞에 추가하고, async 뒤에 여기에서 가져올 매개변수들 그리고 화살표, 함수 본문 순으로 추가하면 된다.
          - 아니면, 화살표 함수 대신 일반 함수 방식으로 작성할 수도 있다.
          - 둘 모두 정상 작동하고, 차이점 역시 없다.
      - 이제 fetchMoviesHandler가 불필요하게 재생성되는 것을 막았으니, 테스트를 해보면 문제가 한 가지 발생한다.
        - 여기서 발생한 문제는 함수의 키워드 순서가 잘못되었기 때문인데, JS의 호이스팅 때문에 발생한 문제로, fetchMoviesHandler 상수가 전체 코드를 파싱하기 전에 함수를 호출하기 때문에 문제가 발생한 것이다.
        - 그래서, useEffect 호출을 함수 정의 구문의 뒤로 옮기면 해결이 된다.
      - 자세한 내용의 코드는 [깃 허브](https://github.com/jeongsangtae/react-complete-training-http-db/commit/ade91db5bf2e1eac1085dd6f3d773aba6501cc53)에서 확인 가능
    - 이렇게 useEffect를 이용해, 컴포넌트가 로드될 때 즉각적으로 HTTP 요청을 보내도록 추가해보고, useEffect를 올바르게 사용하는 방법과 필요한 경우에만 실행하고, 그렇지 않을 때는 실행하지 않는 방법을 연습

  <br />

  - 다음 단계를 위한 프로젝트 준비하기
    - 실제 환경에서는, 많은 어플리케이션들이 데이터 fetch만으로 끝나지 않고, 서버로 데이터를 보내는 작업도 필요로 한다.
      - 새로운 사용자를 만드는 좋은 예
    - 새로운 컴포넌트를 하나 추가
      - AddMovie 컴포넌트로, 사용자 입력 양식을 렌더링하고 사용자 입력을 받는 컴포넌트
      - 입력 form이 기본 값을 제출하는 것을 막고 있으며, movie 객체를 만들고, onAddMovie를 통해 props로 전달
    - 현재 사용중인 스타워즈 API는 데이터 수신을 위한 더미 API로, 현재 필요한 새 데이터 저장에 사용하는 POST 요청은 불가능하다.
      - 스타워즈 API는 단순한 더미용 실습 API에 불과하다.
      - 외부에서 들어오는 데이터를 받을 이유가 없다.
      - 따라서 이를 통한 POST 요청은 할 수가 없다.
    - 다른 더미 API인 **Firebase** 사용
      - 이 서비스는 구글이 제공하며 코드 작성 없이도 사용 가능한 백엔드이다.
      - Firebase는 이름과는 다르게, DB가 아니다.
      - DB에 딸린 백엔드지만, 요청을 주고받을 수 있는 완전한 REST API를 제공하는 풀 백엔드 어플리케이션이다.
      - 또한 좋은 점은, 이 서비스는 무료로 사용이 가능하다.
      - 과금 페이지를 보면 더미 백엔드를 이용해 서버 기반 코드 없이 무료 실습이 가능하다고 한다.
      - 해당 강좌는 React에 대한 강의이므로, React 자체에 집중해야 하겠지만, Firebase를 통해 데이터를 가져오고 저장하는 것이 가능하다.
      - Firebase는 구글에서 제공하는 서비스이며, 전체 서비스를 구성하고 있는 다양한 제품군과 서비스가 존재한다.
        - 그 중 일부분만을 사용할 예정
        - 복잡한 Firebase 어플리케이션을 만들지는 않을 것이다.
      - Firebase를 사용하는 이유는 무료이고, 코드도 필요 없는 백엔드이기 때문이다.
    - **Firebase** 사용 방법
      - Firebase를 사용하기 위해선 구글 계정이 필요하고, 이 계정으로 로그인한 다음에 Firebase 콘솔로 이동해야 한다.
      - 로그인 후, 새로운 프로젝트를 추가하고 프로젝트 이름을 정하고 구글 통계는 비활성화 해준 다음, 프로젝트 생성해주면 된다.
      - Firebase 콘솔에 들어가면 실시간 DB가 있는데 Firebase는 DB가 아니고, 제공하는 기능 중 일부가 DB이다.
      - 두 개의 DB가 있는데, 클라우드 Firestore가 기능상 더 강력하지만 실시간 DB가 사용하기에 더 쉽고, 사실 더미 백엔드면 충분하기 때문에 실시간 DB를 사용
        - REST API가 상대적으로 더 좋기도 하다.
      - 메뉴로 돌아와 DB를 생성하고, 반드시 "Start in Test Mode"를 눌러야 한다. 그렇지 않으면 요청 전송이 불가능하다.
        - 한글에서는 테스트 모드를 클릭하면 된다.
        - 추가로 국가 선택도 있는데 이 내용은 강의에서는 선택하는 항목이 없었는데, 그냥 아시아인, 싱가포르로 선택을 했다.
      - 간단한 DB가 만들어지고, 이 DB와 통신할 URL이 제공된다.
        - 사실 이 URL은 허구인게, 프론트엔드 어플리케이션은 DB와 직접 통신이 불가능하고, 그렇게 해서는 안된다. 여기서도 마찬가지이다.
        - 이 URL은 Firebase REST API에 대한 URL이며, 이 API는 들어오는 요청을 받고 백그라운드의 DB와 통신을 한다.
        - 보기에 DB와 직접 소통하는 것처럼 보일 뿐이다. 실제로는 그렇지 않다.
        - 이 URL을 통해 Firebase 백엔드, 내 DB로 데이터를 보낼 수 있다.
        - 하지만 앞에서와 같은 영화 목록 fetch는 불가능하다.
      - App.js로 가서 스타워즈 URL을 Firebase DB URL로 바꾸고 뒤에 movies.json이라는 세그먼트를 추가
        - 이 movies라는 이름은 내가 마음대로 정하면 되고, 이렇게 하면 DB에 새로운 노드가 만들어지게 된다.
        - 이 것은 동적 REST API로, 서로 다른 세그먼트를 사용해 DB의 서로 다른 노드들에 데이터를 저장할 수 있게 설정해주는 것이다.
        - 다시 말하지만, movies라는 이름은 내 마음대로 정해도 문제 없고, 중요한 건 `.json` 확장자이다.
        - 이는 Firebase의 요구 사항으로, 요청을 전달하려는 URL 끝에 `.json`을 추가해야 한다. 그렇지 않으면 요청은 실패한다.
        ```
        const response = await fetch(
          "https://react-http-c566b-default-rtdb.asia-southeast1.firebasedatabase.app/movies.json"
        );
        ```
    - 이제 Firebase에서 데이터를 가져올 수 있지만, 실제로 URL을 사용하면 실패한다.
      - 결과적으로 가져올 수 없는 결과를 읽으려고 했기 떄문이다.
      - 오류 응답 코드를 받지 못했기 때문에 앞에서 오류 응답 코드 관련 if 문에도 도달하지 못한다.
      - 200 응답 코드는 받았으나, 이 안에 내용물은 없는 셈이다. 결국 데이터를 못 받은 것
        - 당연하게도 이 안에는 데이터가 아무 것도 저장되어있지 않기 때문이다.
    - Firebase의 실시간 DB로 변경했으니, POST 요청을 보내고 데이터를 저장할 수 있다.
      - 이와 같은 작업이 자주 있기 때문에 알아 두는 것이 좋다.

  <br />

  - POST 요청 보내기
    - App 컴포넌트에서 영화 객체를 가져오는데, 이 객체에는 title, openingText, releaseDate가 있다.
      - ID는 Firebase에 의해 자동적으로 추가된다.
    - App 컴포넌트의 addMovieHandler에서는 fetch API를 사용해 또 다른 HTTP 요청을 전송해야 한다.
    - fetch라고 하지만, 사실 데이터를 가져오기만 하는 건 아니다. 데이터를 전송하는 데에도 사용할 수 있다.
      - 어떤 코드의 일부를 다른 함수에 아웃소싱할 수도 있다.
      - 다른 파일에 저장해서 특정 파일을 깔끔하게 유지할 수 있다.
      - 이번에는, 강의 목적상 파일 하나를 계속 사용할 예정
    - 이번 목표는 요청 전송으로, 데이터를 가져오는 URL에 반대로 요청을 보내는 것
      - 그렇지 않으면 데이터를 가져올 수 없다.
    - fetch를 통해 POST 요청을 하기 위한 방법
      - fetch API에 두 번째 인자를 전달하면 된다.
        - 이 인자를 이용해 외부로 전송하는 요청을 지정할 수 있는데 method 키와 같은 걸 지정하면 된다.
      - method 키
        - 기본 값은 GET이지만, 현재 원하는 것은 POST이므로 POST로 지정
        - 이렇게 Firebase 서비스에 POST 요청을 보내면 Firebase는 DB에 리소스를 만든다.
        - POST 요청을 보냈을 때 어떤 일이 발생하는지는 내가 사용하는 백엔드에 달려 있다.
          - POST 요청을 보내면 리소스가 생성된다는 것은 일반적으로 그렇다는 말이고, 어떤 법칙 같은 건 아니다.
          - 모두 API에 달려 있다.
        - Firebase 에서는, POST 요청을 보내면 리소스를 만들어둔다.
        - `method: "POST"`
      - body
        - 저장해야 하는 리소스를 만들기 위해, fetch API 구성 객체에서 body라는 옵션을 추가
        - 여기에서는 영화를 추가하려 하기 때문에, movie를 전달
        - body는 JS의 객체가 아닌, JSON 데이터를 필요로 한다.
          - JSON은 데이터 형태로 FE와 BE간의 데이터 교환에 사용되는 유형
        - JS 객체를 JSON으로 바꾸려면 JS에 있는 `utility` 메소드를 사용하면 된다.
        - JS의 브라우저 안에 내장된 JSON 객체를 사용한 뒤에 `stringify`를 호출한다.
        - 이러면, JS 객체나 배열을 JSON 형식으로 바꿔주게 된다.
        - `body: JSON.stringify(movie)`
      - headers
        - 좀 더 명확히 하기 위해 headers 추가
        - headers 키를 추가하고 값으로 객체를 지정하면 된다.
        - Content-Type이라고 쓰고, 내용에는 application/json이라고 작성하면 된다.
        - Firebase에는 이 헤더가 필요한 것은 아니다.
          - 헤더가 없다 할 지라도 요청은 정상적으로 처리해주지만 요청을 받는 대다수의 API들은 이러한 헤더를 필요로 한다.
          - 이 헤더를 통해 어떤 컨텐츠가 전달되는지 알 수 있기 때문이다.
          - 이렇게 지정해주는 것은 Firebase에서는 필요없는 과정이긴 하지만, 명확하게 해주는 것이 좋은 방법일 수 있기 때문에 해준 것
        ```
        headers: {
          "Content-Type": "application/json"
        }
        ```
      - 이 작업은 비동기 작업이고, 프로미스를 돌려받기 때문에 async/await를 추가해준다.
      - 오류 처리도 추가할 수 있는데, 구문 전체를 try-catch로 감싸서 이전에 했던 것처럼 처리하면 된다.
        - 오류가 발생했을 때 setError를 설정하던가 하는 방식으로 가능
      - 이제 이 내용으로 URL에 POST 요청을 보낼 수 있다.
    - 내용을 작성하고, Firebase 백엔드를 살펴보면 자동 생성된 암호화된 ID가 있고, 그 안에는 전송된 데이터가 있다.
    - POST 요청한 데이터가 보이도록 하기 위해 데이터를 변환하는 작업 추가
      - 더 이상 map은 필요하지 않으므로, 앞에서 loadMovies라는 배열을 만들어준다.
        - 내부는 빈 배열로 둔다.
      - for 루프를 추가해 data 안의 모든 키를 확인한다.
        - 여기서 data는 객체로 구성되어 있다.
        - key는 각 영화의 ID
      - for 루프 안에서, loadMovies에 push를 사용해 전달받은 데이터의 키와 값들의 조합에 대해 새로운 객체를 push한다.
        - id는 기존 `key` 값으로, title은 `data[key].title` 이런식으로 구성하면 response로 받은 중첩 객체를 타고 들어가게 된다.
        - 이 방법은 JS의 속성에 대한 동적 접근 방법이다.
        - openingText 역시 `data[key].openingText`
        - releaseDate도 마찬가지로 `data[key].releaseDate`와 같은 방식으로 가져올 수 있다.
      - 변환 로직에 대해 다른 작성 방식도 있지만, 이 방식이 가장 이해하기 쉬울 것으로 생각되기 때문에 이 방법을 사용
      - loadMovies는 내부에 객체가 있는 배열이며, 각 객체는 내가 원하는 구조를 갖고 있다.
      - 따라서 아래의 map을 사용하는 코드 부분은 더 이상 필요 없고, setMovies 부분에서 방금 만들어낸 배열인 loadMovies로 바꿔준다.
    - 이 어플리케이션에 대한 수정도 가능하다. 매번 영화가 입력될 때마다 자동적으로 영화들을 가져오게 할 수도 있으며, addMovieHandler를 통해 오류 처리도 가능하다. 모든 것을 할 수 있지만, HTTP 요청 전송에 대한 핵심적인 것들만 연습해본 것
      - GET 요청을 설정하고 데이터를 가져오는 것과 POST 요청을 통한 데이터 저장에 대한 핵심 내용을 주로 연습
    - 자세한 내용의 코드는 [깃 허브](https://github.com/jeongsangtae/react-complete-training-http-db/commit/bed0d6396064f9e32b036925ad8027a31b787278)에서 확인 가능
    - 추가 내용 Firebase POST 요청중에 발생한 오류
      - `ERROR in ./node_modules/body-parser/lib/read.js 20:11-26` 등 수 많은 오류가 갑자기 발생해서 당황했는데 확인해보니, 중간에 내가 자동완성 기능을 잘못 사용하면서 application을 import 해버리면서 발생한 오류였다.
      - headers의 Content-Type 내용인, application/json을 작성하는데 여기서 application을 자동 완성하면서 application이 import 되어버려서 발생한 오류였다.
      - application import된 부분인 `import { application } from "express";`를 삭제하니 문제가 해결되었다.

<br />

# 오늘 느낀 점

- 오늘 HTTP 내용을 마무리 했는데, 내용을 정리하면 React는 백엔드와 통신할 수 있지만 보안이나 성능상 문제로 인해 DB와의 직접적인 통신은 불가능하다. 하지만 백엔드 API를 통한 요청 전송은 가능한데 대부분은 REST API에 전송하게 된다. 그리고 fetch API나 axios와 같은 서드 파티 라이브러리를 통해 요청을 전송하는 방법도 배웠고, 응답을 받아오고 이를 분석하거나 필요에 따라 오류를 전달하고 발생시키는 방법도 배우고, 응답을 통해 받아온 데이터를 다루는 방법 또한 배웠다. GET과 POST 요청을 보내는 방법, 그리고 요청 전송으로 인한 로딩 상태나 오류 상태 또는 데이터가 없는 상태나 데이터가 있는 상태와 같이 다양한 상태를 관리하는 방법도 알아볼 수 있었다. 여기에서 배운 모든 것들, 그리고 HTTP 요청 전송 작업은 매우 중요한 작업으로 이를 통해 사용자 경험인 UX를 더욱 풍부하게 만들 수 있고, 대부분의 어플리케이션이 지향하는 것과 같기 때문에 React 어플리케이션에서 HTTP가 일반적으로 어떤 방식으로 작동하는지 알아보는 아주 의미있는 데모 프로젝트였다고 생각이 된다.

- Firebase에 대해 얘기만 들어보고 오늘 처음 사용해봤는데, 구글에서 제공해주며 코드 작성 없이도 백엔드를 사용할 수 있어서 정말 좋다고 생각이 되었다. 그리고 더미 백엔드를 이용해 서버 기반 코드 없이 무료로 실습도 가능하고, 백엔드와 요청을 주고받을 수 있는 REST API를 제공하는 풀 백엔드 어플리케이션이라서 더 좋았던 거 같다. 앞에서 말한 것 중에 역시 제일 좋은 장점은 무료로 사용이 가능하다는 점이 제일 메리트 있다고 생각이 된다. 그리고 생각보다 사용하기에 간편하다고 느껴졌고, 따로 백엔드 코드를 작성안해도 되는게 너무나도 좋다고 생각이 된다. Firebase POST 요청에 대해 배울 때 실수로 자동 완성 기능으로 인해 application이 import되어 오류가 발생했는데, 그래도 바로 찾아보고 해결할 수 있어서 다행이라고 생각이 되었다. 생전 처음보는 오류였기에 많이 당황을 했지만 해당 내용을 찾아보고 문제를 해결하면서 다시 한 번 느낀게 있다면, 자동 완성 기능은 항상 조심을 해야 한다고 생각이 되었다. 자동 완성 기능이 간편하긴 하지만 잘못된 내용이 자동 완성되거나, 또는 import 되어 그로 인해 오류가 발생할 수도 있기 때문에 항상 자동 완성 기능을 사용할 때는 조심해서 사용을 해야 할 것 같다고 생각이 되었다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
