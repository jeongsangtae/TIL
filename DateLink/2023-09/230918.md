# 오늘 한 일

### React 공부

- 클래스 기반 컴포넌트

  - 클래스형 컴포넌트 추가 및 클래스형 컴포넌트에서 생명 주기 추가
    - 상태를 초기화하는 과정이 필요하기 때문에 constructor 추가
      - 생성자를 추가할 때는 super()를 추가하는 것을 잊어선 안된다.
    - this.state를 추가해 상태 관리 구성
      - 2개의 상태 조각이 있기 때문에 2개의 속성을 추가
      - filterUsers, searchTerm
      - filterUsers에는 더미 데이터를 값으로 추가, searchTerm에는 빈 문자열을 값으로 추가
    - 이벤트 핸들러 메소드 추가
      - 상태 갱신을 위해 사전 실행되어야 하는 메소드
      ```
      searchChangeHandler(event) {
        this.setState({searchTerm: event.target.value})
      }
      ```
      - 이렇게 구성해 filteredUsers가 손실되지 않도록 한다.
    - render 메소드 구성
      - JSX 코드에 있는 반환문을 가져와 사용
      - 이벤트 핸들러 메소드를 사용하는 곳에서 this.을 붙여서 가리키게 해주고, this 예약어가 메소드 안에서 올바르게 작동하도록 bind(this)를 통해 바인딩해준다.
    - state를 사용
      - state를 사용하는 곳에서는 this.state를 추가해 참조하도록 한다.
    - 생명 주기 메소드 추가
      - componentDidUpdate
        - React에 의해, 상태 변화로 인해 컴포넌트가 재평가되게 되면 자동적으로 호출된다.
        ```
        componentDidUpdate() {
          this.setState({
            filteredUsers: DUMMY_USERS.filter((user) =>
              user.name.includes(this.state.searchTerm)
            ),
          });
        }
        ```
        - 위와 같이 구성하면 무한 루프가 만들어지는데, 이유는 componentDidUpdate는 컴포넌트가 변경될 때마다 실행되기 때문이다.
          - 상태를 설정하면 컴포넌트가 변경되고, 따라서 함수가 재실행되고 그러면 상태 역시 다시 변경된다. 이렇게 계속 실행되면 이 것이 무한 루프
        - 그래서 관심 있는 상태가 바뀌었는지에 대한 확인이 필요하다.
          - 여기서는 searchTerm의 변경 여부가 필요함
        - prevProps, prevState 이렇게 두 개의 인자를 전달받도록 구성
          - 현재 컴포넌트의 갱신 직전 시점의 props와 스냅샷을 갖고 있는 인자이다.
          - 이를 가지고 if문을 작성
          - `prevState.searchTerm !== this.state.searchTerm`
            - 이 둘을 비교해서 searchTerm이 바뀌었다면 해당 로직을 실행하게 된다.
        - prop 변경을 기반으로 갱신을 하려 한다면 새로운 prop 값이 들어와 컴포넌트를 업데이트하려고 한다면 이전 prop 값과 현재의 prop 값을 비교하면 된다.
          - 즉, prevProps를 사용해 `prevProps.searchTerm` 이런식으로 사용하는 것을 말함
        - 하지만 이 것은 상태 변경에 대한 것이기 때문에, 컴포넌트 안의 상태 변경이 더 중요하다. 따라서 이전 상태와 현재 상태의 비교를 위해, 각 상태의 특정 부분을 비교한다.
          - prevState를 사용해 `prevState.searchTerm`로 구성
          ```
          componentDidUpdate(prevProps, prevState) {
            if (prevState.searchTerm !== this.state.searchTerm) {
              this.setState({
                filteredUsers: DUMMY_USERS.filter((user) =>
                  user.name.includes(this.state.searchTerm)
                ),
              });
            }
          }
          ```
      - 이 내용과 비교해보면 useEffect가 얼마나 좋은지를 보여주는데, 굉장히 짧고, 의존성을 명시함으로서 코드 안에 조건문을 추가할 필요가 없다.
        - componentDidUpdate에는 앞에서 작성된 코드와 같은 무한 루프 방지를 위해 조건문을 사용해야 한다.
        - 하지만 useEffect에서는 searchTerm을 의존성 지정을 했으므로 조건문과 같은 작업이 필요가 없다.
        - 따라서 자동적으로 effect 함수는 의존성 배열이 변경된 경우에만 React에 의해 실행된다. 그리고, 컴포넌트를 재 렌더링시키는 이외의 변경 사항이나, 변경 이유는 의존성 배열 덕분에 무시된다.
      - componentDidMount
        - 보통 HTTP 요청과 같은 작업이 있을 때 사용하고, 조건문을 통한 확인은 필요가 없다.
        - 이유는 componentDidMount가 컴포넌트가 초기 렌더링될때만 실행되므로 필요가 없다.
        - 이 이후에 갱신이 이루어져도 componentDidMount는 실행되지 않고, 대신 componentDidUpdate가 실행된다.
        - 함수형 컴포넌트에서 이와 같은 기능을 하는 것은 useEffect를 의존성없이 호출하는 것이다. 의존성 배열이 있더라도 실행 시점은 컴포넌트가 처음 마운트되는 시점이다. 왜냐하면 해당 의존성을 처음에는 의존성이 없는 것과 같이 처리하기 때문이다.
        ```
        componentDidMount() {
          // HTTP 요청을 보내는 곳
          this.setState({ filteredUsers: DUMMY_USERS });
        }
        ```
      - componentWillUnmount
        - User 컴포넌트에서 componentWillUnmount를 추가하고 실행 시 3번 실행되는데, 그 이유는 User 컴포넌트를 3번 사용했기 때문이다.
        - 3명의 사용자를 렌더링했고 각각의 인스턴스들이 모두 삭제되기 때문이다.
      - 모든 생명 주기 메소드는 모든 컴포넌트 인스턴스, 즉 useEffect와 같은 것들이다. 이들에 대해 각각의 상태가 독립적으로 작동한다.
      - 클래스형 컴포넌트에서 생명 주기 메소드를 추가하면 로직에 제약을 걸기 위해 조건문 검사를 수행할 수 있는데, useEffect를 사용하게 되면 컴포넌트가 언제 처음으로 렌더링되는지 또는 갱신이 되는지 등에 대해서는 신경쓰지 않아도 된다. 오로지 의존성 배열만 보면 되고, 이 것이 바뀌면 그 때 로직을 실행하는 방식으로 작동한다.

  <br />

  - 클래스형 컴포넌트 및 context
    - 클래스 컴포넌트에서 context를 사용하는데 가능한 2가지 방법이 있다.
      - Context.consumer 컴포넌트
        - 이 방법은 함수형, 그리고 클래스 컴포넌트 모두 쓸 수 있다.
        - 이 방법은 JSX에서만 사용 가능한데, 함수형 및 클래스 컴포넌트 모두에서 사용 가능하다.
        - 하지만, user Hook이 사용되기 때문에 Consumer 컴포넌트는 굳이 사용할 필요가 없다.
        - Context.consumer를 사용하려면, render 메소드에서 UserSContext를 import해서 사용해야 한다.
          - 여기서 UserSContext는 먼저 앞에서 추가해놓은 context를 import해서 사용하는 것
        - 다른 방법으로 Consumer 컴포넌트에 접근해서 사용하면 된다.
          - 강의 초반에 봤던 것을 말하는 것으로 봐선, Component를 import하고 확장해서 사용하는 방식을 말하는 것 같음
        - `<UserContext.Consumer></UserContext.Consumer>`
      - Context.consumer에 대응하는 다른 방법은 ?
        - 사실 완벽하게 들어맞는 방법은 없다.
        - useContext를 이용하면 useContext를 여러 번 호출하고 매 번 다른 컴포넌트를 가리킴으로써 하나의 컴포넌트에서 여러 개의 context를 받아올 수 있다.
        - 당연하겠지만, 클래스 컴포넌트는 한 번에 하나의 context만 연결할 수 있으므로 useContext 방법은 불가능하다.
        - 정적 프로퍼티를 추가하면 가능한데 static 예약어를 사용하고, 이를 통해 contextType이라는 프로퍼티를 만들 수 있다.
          - `static contextType = UsersContext`
          - React에게 이 컴포넌트는 UsersContext라는 context에 접근할 수 있다고 전달하는 것이다.
          - 하지만 이 정적 프로퍼티, 즉 static contextType은 단 한 번만 설정할 수 있으므로, 동시에 연결해야 하는 2개의 context가 있다면 이 겻이 아닌, 다른 방법을 찾아야 한다.
          - 다른 컴포넌트로 래핑을 한다거나 그런 방법을 찾아야 함
    - 클래스 컴포넌트에서 context를 사용하는 방법은 굉장히 간단하지만, 함수형 컴포넌트 중에서는 유연함이 좀 떨어지긴 한다.
      - 당연하겠지만 항상 2개 이상의 context를 써야 하는 건 아니다. 보통 1개면 충분하다.
      - 하지만 컴포넌트에 2개 이상의 context를 연결해야 한다면 이 제약조건은 부담이 클 수 밖에 없다.

  <br />

  - 클래스 컴포넌트 vs 함수형 컴포넌트 요약
    - 클래스 컴포넌트는 과거에 특정 상황에서 반드시 사용해야 했다. 하지만 최근의 React 앱에서는 배우기 쉽고, 또 유연성이 좋기 때문에 함수형 컴포넌트를 대신 사용한다.
    - 강조하고 싶은 것은 무조건 함수형 컴포넌트를 쓸 필요는 없다.
    - 클래스 형식이 좋다면 그걸 써도 된다.
    - 하지만 함수형 컴포넌트의 장점이 충분히 있기 때문에, 클래스 컴포넌트는 무시해도 괜찮다. 단, 하나의 예외가 있는데 이 부분은 나중에 설명해준다고 함
      - 아마 오류 경계에 대한 내용 같음
    - 어떤 방법을 써야 할 지 모르겠다면 의사 결정 트리를 확인해보는게 좋다.
      - 일반적으로는, 함수형 컴포넌트를 사용하고, 개인적인 취향의 이유로 클래스 컴포넌트를 사용하면 된다.
      - 단순히 클래스 컴포넌트가 좋아서 사용하는 것도 괜찮고, 쓰기 싫으니 다른 걸 쓰는 것도 문제될 것이 없다.
      - 가령 프로젝트나 어떤 팀에 속해있고 그들이 클래스 컴포넌트를 더 많이 사용한다면 선택지는 존재하지 않을 것이다.
      - 그리고 클래스 컴포넌트를 써야만 하는 경우도 있다.
        - 오류 경계를 빌드할 때 필요하다.

  <br />

  - 오류 경계
    - 어플리케이션에서는 가끔 문제가 발생하는데, 개발자의 관점에서 보는 버그를 의미하는 것이 아니다.
    - 가끔 예방할 수 없는 오류도 있으며, 어떤 오류는 어플리케이션의 어떤 부분에서 다른 부분으로 무언가가 잘못되었다는 것을 전달할 때 사용되기도 한다.
    - HTTP 요청 전달을 예로 들면, 서버가 일시적으로 응답이 없을 경우에는 이 요청에 대해 응답할 수 없으며 따라서 어플리케이션에서는 오류가 발생된 것을 보게 된다.
      - 이 경우 개발자가 뭘 할 수 있을까?
        - 서버가 오프라인 상태이기 때문에 처리할 수가 없다. 이와 같이 막을 수 없는 오류는 분명 존재한다.
    - 오류를 테스트 하기 위해 Users 컴포넌트에서 오류 발생 코드 추가
      ```
      componentDidUpdate() {
        if (this.props.users.length === 0) {
          throw new Error("No users provided!");
        }
      }
      ```
      - 어플리케이션 전체를 중단시킬 생각이 없는데, 현재는 전체를 중단시킨다. 이런 상황에서 JS에서는 try-catch문을 사용한다.
      - React에서도 당연히 JS를 쓰지만, 컴포넌트 안에서 오류가 발생하고 이를 처리할 수 없는 상황에서는 try-catch문을 사용할 수 없다.
        - 현재 컴포넌트 안에서 오류를 해결하지 않고, 부모 컴포넌트에서 처리하고 싶다면 try-catch문을 사용할 수 없다는 말
        - try-catch문은 정규 JS 문장을 사용하는 곳에서만 쓸 수 있기 때문이다.
        - 이럴 때 "오류 경계"라는 것을 만들어서 처리할 수 있다.
    - 오류 경계 사용 방법
      - 먼저 따로 js파일을 생성한다.
        - 이름은 상관없다. 내가 하고 싶은 이름으로 작성해도 무관함
        - .js로 JS 파일로만 구성해주면 된다.
      - 생성한 js파일을 정규 컴포넌트로 만들어준다.
        - 여기서 정규 컴포넌트는 클래스 컴포넌트 방식으로 구성
      - 특별한 메소드를 추가하는데 바로 `componentDidCatch`
        - 정규 클래스 컴포넌트지만, 해당 클래스 컴포넌트는 componentDidCatch 생명 주기 메소드를 활용하는 컴포넌트가 된다.
      - render 메소드 추가
        - 오류 경계에서도 다른 컴포넌트에서 그러했듯이 render 메소드를 추가해야 한다.
        - 그리고 `this.props.children`를 반환해야 한다. 이 것이 특별한 점이다.
        - `this.props.children`를 반환하는 이유는 이 오류 경계 컴포넌트를 보호하려고 하는 컴포넌트로 둘러싸야 하기 때문이다.
      - 오류 경계를 사용하려는 위치에서 Wrapper 형식으로 감싸서 사용할 수 있다.
        - 당연하지만, 오류 경계를 import 하는게 선행되어야 한다.
        - 처리해야 할 오류가 발생 가능한 어떤 컴포넌트든 이를 감싸면 된다.
        - 당연히 2개 이상의 컴포넌트를 감쌀 수도 있다.
        ```
        <ErrorBoundary>
          <Users uesrs={this.state.filteredUsers} />
        </ErrorBoundary>
        ```
      - 오류 경계 클래스 컴포넌트에서 오류가 발생했을 때의 조치 사항 추가
        - 이를 위해 error 객체를 매개변수로 가져온다.
          - 이 error 객체는 React가 자동적으로 전달해준다.
        - 이제 오류를 확인해서 무엇이 문제인지 확인하고 개별 오류마다 서로 다른 로직을 실행하게 할 수 있다.
          - 물론 각 오류마다 개별 오류 경계가 필요하다는 것을 기억해야 한다.
          - 어쨌든, 내가 원하는 대로 개별 오류마다 로직을 추가해 작업할 수 있다.
        - 생성자를 추가
          - super를 추가해준다.
          - this.state를 추가해 error의 초기 상태를 설정할 수 있다.
            - 여기서는 `hasError: false`로 초기 설정을 해준 상태
            - hasError와 같은 이름이 아니어도 되고, 내가 원하는 상태로 만들어도 된다.
        - this.setState를 호출해서 error의 값을 변경
          - 여기서는 hasError의 값을 true로 바꿔주었다.
          - `this.setState({hasError: true})`
        - 그 다음 render 메소드에서는 error가 true인지 확인하는 조건문 추가
          - this.state.hasError가 true인지 확인하고 이 조건이 맞다면 원하는 메시지와 같은 내용이 반환되도록 구성
          ```
          render() {
            if(this.state.hasError) {
              return <p>Something went wrong!</p>
            }
            return this.props.children;
          }
          ```
        - 물론 이 오류를 분석하기 위해 로깅하거나, 서버로 전송한다던가 하는 작업 역시 가능하다.
    - `componentDidCatch` 메소드
      - 어느 클래스 컴포넌트에도 추가할 수 있으며, 컴포넌트에 이를 추가하게 되면 클래스 컴포넌트를 오류 경계로 만들게 된다.
      - "오류 경계"란 단어는 이런 생명 주기 메소드를 갖는 컴포넌트를 지칭하는 용어이다.
      - 2개의 함수형 컴포넌트를 편집할 수 없으며, 현재 이 오류 경계에 해당하는 함수형 컴포넌트는 존재하지 않는다.
      - 따라서, 이 오류 경계를 빌드하려면 클래스 컴포넌트여야 하고 동시에 생명 주기 메소드를 갖는 컴포넌트여야 한다.
    - 생명 주기 메소드의 특별한 점은 무엇일까?
      - componentDidCatch 이 생명 주기 메소드는 하위 컴포넌트 중 하나가 오류는 만들거나 전달할 때 발동된다.
      - 따라서 오류 경계에서도 다른 컴포넌트에서 그러했듯이 render 메소드를 추가한다.
    - 오류 경계를 사용하는 이유는 무언가가 잘못되더라도 어플리케이션 전체가 작동 중단되지 않고, 오류를 확인한 뒤에 이를 JS의 try-catch문과 같이 좀 더 세련된 방식으로 처리할 수 있기 때문이다.
    - ~~오류 경계를 추가하려면 클래스 컴포넌트를 사용해야 한다. 함수형 컴포넌트에서는 아직 사용이 불가능하다.~~
      - 찾아본 결과 함수형 컴포넌트에서도 오류 경계를 추가할 수 있으며, try-catch문을 통해 componentDidCatch를 사용하는 것과 유사한 방식으로 개별 컴포넌트에서 오류 처리를 할 수 있다고 하며, react-error-boundary 와 같은 라이브러리를 사용하거나 커스컴 오류 경계 컴포넌트를 작성해 함수형 컴포넌트 내에서 오류를 처리할 수 있다고 한다.

<br />

# 오늘 느낀 점

- 클래스형 컴포넌트에서 생명 주기 메소드를 써본 결과 코드가 좀 길고, 조금 어렵다는 생각이 들었다. 확실히 함수형 컴포넌트의 useEffect가 훨씬 간단하고 직관적이며, 성능 및 코드 관리 측면에서도 좋다고 생각이 된다. 클래스 컴포넌트는 처리해야 하는 내용에 따라 일치하는 생명 주기 메소드를 사용해야 하지만, 함수형 컴포넌트에서는 useEffect 하나로 처리할 수 있다. 클래스 컴포넌트에서 여러 개의 생명 주기 메소드를 사용해야 할 때가 있지만, 함수형 컴포넌트에서는 여러 개의 useEffect Hook을 사용하여 여러 부수 효과를 하나의 컴포넌트에서 효율적으로 처리할 수도 있다. 그리고 useEffect는 코드 분리 및 재사용에서도 뛰어나기 때문에 다른 컴포넌트에서 재사용하기 쉽고, 클래스 컴포넌트에서 클로저 문제로 인해 예상치 못한 동작이 발생할 수 있지만, useEffect 내에서 변수를 사용할 때 클로저 문제가 발생하지 않는다.

- 클래스형 컴포넌트에서 context를 사용할 때도 불편한 점이 존재했는데, 한 번에 하나의 context만 연결할 수 있다는 점이 불편하다고 생각이 된다. 클래스 컴포넌트에서 context를 사용하는 방법은 굉장히 간단하지만, 함수형 컴포넌트에 비해 유연성이 좀 떨어지는 부분이 아쉽다고 생각이 된다. 항상 2개 이상의 context를 사용하는 것은 아니지만, 필요할 때 사용하지 못한다면 그건 여러모로 많이 불편할 것 같다. 그리고 컴포넌트에서 2개 이상의 context를 연결해야 하는 경우에 제약조건도 있기 때문에 이런 부분에서 유연성이 많이 떨어지는 것 같다. 그래도 장점으로 1개의 context를 사용한다면 굉장히 간단하게 사용할 수 있다는게 장점이라고 생각이 된다.

- 오류 경계는 클래스 컴포넌트에서만 사용하는 것으로 오류 경계를 사용하면 개별 컴포넌트에서 발생한 오류가 전체 앱을 중단시키지 않고 오류 처리를 할 수 있다. 그리고 오류 경계를 통해 사용자에게 오류 메시지를 표시하거나 대체 컴포넌트를 렌더링하여 사용자 경험을 향상시킬 수도 있다. 이런식으로 사용자가 오류로 인한 애플리케이션 중단을 보다 부드럽게 처리할 수 있게 해준다. 그리고 오류 경계를 사용하면 컴포넌트 내부에서 발생한 오류를 캐치하고 이를 로깅하거나 서버로 전송해 디버깅 및 오류 추적을 용이하게 만들 수 있다. 오류 경계로 인해 애플리케이션의 안정성을 높이고 문제를 신속하게 해결할 수 있다. 주로 try-catch문을 사용해 구현되고, componentDidCatch 생명 주기 메소드를 사용해 컴포넌트 수준에서 오류를 처리하는데 사용된다. 이를 통해 React 애플리케이션은 더욱 안정적이고 견고한 것으로 유지될 수 있다. 이와 같은 내용을 보면 오류 경계가 중요하다는 것을 알 수 있는데 강의에서는 클래스 컴포넌트에서만 사용이 가능하다고 했지만, 정보를 좀 찾아보니 함수형 컴포넌트에서도 비슷하게 try-catch문을 사용하거나, react-error-boundary와 같은 라이브러리로 처리할 수 있다고 한다.

- 클래스형 컴포넌트에 대해 알아보는 시간이 끝났는데, 함수형 컴포넌트에 비해 좀 더 복잡하고 어렵다는 생각이 들었다. 과거에는 특정 상황에서 반드시 클래스 컴포넌트를 사용해야 했지만, 최근의 React 앱에서는 배우기 쉽고, 또 유연성이 좋은 함수형 컴포넌트를 사용하는 것이 요즘 추세이다. 그렇다고 무조건 함수형 컴포넌트를 쓸 필요는 없고, 클래스 컴포넌트 형식이 좋다면 그 방식을 사용해도 전혀 문제가 없다고 한다. 하지만 내 생각에는 함수형 컴포넌트의 장점이 뚜렷하게 있기 때문에, 굳이 클래스 컴포넌트를 사용할 이유는 없다고 생각이 된다. 그래서 나는 별 다른 이유가 없다면 함수형 컴포넌트로 React 앱을 구성할 생각이고, 만약 프로젝트나 회사에서 클래스 컴포넌트를 더 많이 사용한다면 그 때 클래스 컴포넌트를 사용할 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
