# 오늘 한 일

### React 공부

- React의 백그라운드 작업에 대해 알아보기 & 최적화 테크닉 살펴보기

  - React.memo()
    - 불필요한 재평가 방지하는 방법
    - React.memo는 인자로 들어간 해당 컴포넌트에 어떤 props가 입력되는지 확인하고 입력되는 모든 props의 신규 값을 확인한 뒤 이를 기존의 props의 값과 비교하도록 React에게 전달
      - props의 값이 바뀐 경우에만 컴포넌트를 재실행 및 재평가하게 된다.
      - 부모 컴포넌트가 변경되었지만 해당 컴포넌트의 props의 값이 바뀌지 않았다면 컴포넌트 실행은 건너뛴다.
    - props가 바뀌었는지 확인할 컴포넌트를 지정한 뒤에 export default 부분에서 랩해주면 된다.
      - `export default React.memo(DemoOutput);`
    - 이 방법은 함수형 컴포넌트에만 가능하다. 클래스 기반 컴포넌트의 경우 이 방법은 작동하지 않는다.
    - React.memo는 함수형 컴포넌트를 최적화할 수 있다.
    - React.memo를 사용 시 불필요한 재렌더링을 피하기 위해서 최적화가 이루어진다. 그렇다면 이렇게 최적화가 가능하다면 React.memo를 모든 컴포넌트에 적용하지 않는 이유는 ?
      - 최적화에는 비용이 따른다.
      - memo 메소드는 App.js에 변경이 발생할 때마다 해당 컴포넌트로 이동해 기존 props 값과 새로운 값을 비교하게 한다.
      - React가 두 가지 작업을 할 수 있어야 하는데 기존의 props 값을 저장할 공간이 필요하고 비교하는 작업도 필요하다. 이 각각의 작업은 개별적인 성능 비용이 필요하다.
      - 따라서 이 성능 효율은 어떤 컴포넌트를 최적화하느냐에 따라 달라지게 된다.
      - 컴포넌트를 재평가하는데 필요한 성능 비용과 props를 비교하는 성능 비용을 서로 맞바꾸는 것이다.
      - 그리고 props의 개수와 컴포넌트의 복잡도, 그리고 자식 컴포넌트의 숫자에 따라 달라지므로 어느 쪽의 비용이 더 높다고 말하는 것은 불가능하다.
      - 물론 자식 컴포넌트가 많아서 컴포넌트 트리가 매우 크다면 React.memo는 매우 유용하게 쓰일 수 있다.
      - 그리고 컴포넌트 트리의 상위에 위치해있다면 전체 컴포넌트 트리에 대한 쓸데없는 재렌더링을 막을 수 있다.
      - 예로, 하위 컴포넌트의 재평가를 피함으로서 자동적으로 하위 컴포넌트의 하위 컴포넌트 재평가 역시 피할 수 있다. 컴포넌트 트리 전체의 가지를 잘라냈기 때문에 가능하다.
    - 반대로 부모 컴포넌트를 매 번 재평가할 때마다 컴포넌트의 변화가 있거나 props의 값이 변화할 수 있는 경우라면 React.memo는 크게 의미를 갖지 못한다.
      - 이유는 컴포넌트의 재렌더링이 어떻게든 필요하기 때문이다. 이럴 때는 props 값의 추가적인 비교에 대한 비용을 아낄 수 있겠지만, 오버헤드로 발생하는 코스트는 아낄 만한 가치가 없다.
      - 당연하게도 앱 크기에 따라서도 달라지는데 매우 작은앱, 매우 작은 컴포넌트 트리의 경우에는 이런 과정을 추가하는 것이 필요가 없다.
      - 하지만 불필요한 재평가를 잘라내버릴 수 있는 큰 큐모의 앱이라면 그럴 만한 가치가 있다.
    - 모든 컴포넌트를 React.memo로 래핑할 필요는 없다. 그 대신, 컴포넌트 트리에서 잘라낼 수 있는 몇 가지의 주요 컴포넌트 부분을 선택해서 사용하면 된다. 모든 자식 컴포넌트에 대한 작업보다 훨씬 효과적이다.
    - React.memo가 최종적으로 하는 일은 props의 값을 확인하고 이전 값과 현재의 값을 비교하는데 이 작업은 일반 비교 연산자 `===`를 통해 비교한다.
      - 값이 원시 값이라면 `false === false`, `'hi' === 'hi'`와 같이 비교해서 trur가 나왔다면 이는 같은 문자열이다.
      - 기술적으로, 예시의 두 불리언은 서로 다른 불리언이고 문자열도 마찬가지로 서로 다른 문자열이다. 원시 값이라면 이런 비교가 가능하다.
      - 그러나, 배열이나 객체, 함수를 비교한다면 말이 달라진다.
      - `[1, 2, 3] === [1, 2, 3]` 이 배열을 비교한다면 사람의 눈에는 같아보이지만 JS에서는 이 둘은 같지 않다.
      - JS에서 함수는 하나의 객체에 불과하다. 이전 객체와 현재 객체, 두 함수 객체는 같은 내용을 갖고 있다 해도 JS에서 이 둘을 비교하면 결코 동일하지 않다.
      - 따라서, React.memo는 JS의 이러한 작동방식 때문에 값이 변경되었다고 인식한다.
    - React.memo는 props를 통한 객체나 배열 또는 함수를 가져오는 컴포넌트에는 사용할 수 없는가?
      - 다행히, 그렇지 않다. 사용할 수 있다.
      - useCallback Hook을 사용해서 가능

  <br />
    
  - useCallback Hook
    - React.memo가 객체 외에 prop 값에도 작동하게끔 도와주는 Hook
    - 객체를 생성하고 저장하는 방식만 조금 변경해주면 된다.
    - 기본적으로 컴포넌트 실행 전반에 걸쳐 함수를 저장할 수 있게 하는 Hook으로 React에 함수를 저장할 것이고 매번 실행때마다 이 함수를 재생성할 필요가 없다는걸 알릴 수 있다.
    - 동일한 함수 객체가 메모리의 동일한 위치에 저장되므로 이를 통해 비교 작업을 할 수 있다.
    - obj1 = {}, obj2 = {} 이 둘은 비슷해보일지 모르지만, JS에서 이 둘은 같은 것이 아니다.
      - 하지만, 객체 2가 객체 1과 같은 메모리 안의 같은 위치를 가리키고 있다면 이 두 객체는 같은 객체로 간주한다.
      - 이 것이 useCallback이 하는 일이다.
      - 우리가 선택한 함수를 React의 내부 저장 공간에 저장해서 함수 객체가 실행될 때마다 이를 재사용할 수 있게 된다.
    - 사용법은 매우 간단
      - 저장하려는 함수를 래핑하기만 하면 된다.
      - 함수를 첫 번째 인자로 전달하면 useCallback은 저장된 함수를 반환해준다.
      - 그리고 App 함수가 다시 실행되면 useCallback이 React가 저장한 함수를 찾아서 그 같은 함수 객체를 재사용한다.
      - 따라서, 어떤 함수가 절대 변경되어서는 안된다면 useCallback을 사용해 함수를 저장하면 된다.
      - useCallback은 useEffect와 마찬가지로, 두 번째 인자가 필요하며 useEffect보다 더 많은 인자가 있어야 한다.
      - 두 번째 인자는 배열이어야 한다. useCallback 호출에 대한 의존성 배열
      - 의존성은 useEffect와 같은 것을 의미한다.
      - 함수를 감싼 컴포넌트로부터 전달받는 모든 것을 사용할 수 있다.
        - 즉, state나 props, context를 지정할 수 있다.
      - 의존성 배열에서는 업데이트 함수의 상태만을 명시하면 된다.
      - 의존성 배열로 `setShowParagraph`를 추가할 수도 있지만, React가 useCallback을 통해 해당 함수는 절대 바뀌지 않으며 이전과 동일한 함수 객체임을 보장하므로 추가할 필요는 없다.
        - 따라서, 이런 예외는 추가할 필요가 없다.
      - 비어있는 의존성 배열은 해당 배열은 React에 해당 함수에 저장하려고 하는 이 콜백 함수는 절대 변경되지 않을 것이라고 React에 알려주는 배열이다.
        - 따라서, App 컴포넌트가 다시 렌더링되어도 항상 같은 함수 객체가 사용되게끔 한다.
      ```
      const toggleParagraphHandler = useCallback(() => {
        setShowParagraph((prevShowParagragh) => {
          return !prevShowParagragh;
        });
      }, []);
      ```

  <br />
    
  - useCallback의 해당 종속성
    - useCallback을 사용하는 함수는 모든 렌더링 주기마다 항상 똑같은 로직을 쓰는데, 왜 의존성 배열이 필요한가? 라는 의문을 가질 수 있다.
    - JS 함수는 클로저이다.
      - 함수가 정의가 되면 JS는 해당 함수에서 사용되는 모든 변수를 잠그게 된다.
      - 함수 외부에서 사용하는 모든 변수라고 해야 좀 더 정확하다.
    - 이 내용은 JS의 클로저에 대해 알아본 후 다시 듣고 정리를 추가해야 함, 그래야 정확하게 이해할 수 있을 거 같음

  <br />

  - state 및 컴포넌트 자세히 알아보기
    - 관리 프로세스의 일부로 React는 useState와 여기에 전달된 기본 값에 대해서는 한 번만 고려되도록 처리한다.
    - 컴포넌트가 처음 렌더링될 때, 즉 ex) App 컴포넌트가 최초 실행될 때 useState가 실행되면 React가 관리하는 새로운 상태 변수를 만들게 된다.
      - 그 뒤에 React는 해당 변수가 어느 컴포넌트에 속하는지를 기억해둔다.
      - 그 다음 기본 값을 사용해서 상태 값을 초기화한다.
      - 이후의 ex) App 함수 호출, 즉 ex) App 컴포넌트를 재평가하는 과정에서 useState가 호출되면 새로운 상태는 생성되지 않는다.
      - React는 해당 컴포넌트에 대한 state가 이미 존재함을 깨닫고 필요할 경우 해당 state를 업데이트하게 된다.
        - ex) App 함수가 재실행되고 몇몇 상태는 변경될 수 있기 때문이다.
    - 따라서, React는 state의 관리와 갱신만을 담당한다.
    - 컴포넌트가 DOM에서 완전히 삭제되거나 하지 않는 이상 상태의 초기화는 이루어지지 않는다.
    - App 컴포넌트는 루트 컴포넌트이므로 DOM이 완전히 삭제되는 경우와 같은 일이 아예 발생하지 않는다.
    - 하위 컴포넌트의 경우, 조건에 따라 렌더링될 수 있다.
      - 예로, 컴포넌트가 삭제되고 다시 연결되었다면 새로운 상태가 초기화될 수 있다.
      - 하지만 DOM에 컴포넌트가 연결되고 유지되는 동안, 상태는 최초의 초기화 이후에는 갱신만 된다.
    - 이 내용은 useReducer의 경우에도 마찬가지이다.

<br />

# 오늘 느낀 점

- React.memo나 useCallback의 내용에 대해서 어느정도 이해했는데 여기서 useCallback의 종속성에 대해 배울 때 JS 함수의 클로저를 얘기해주며 설명해주었는데, 이해하지 못해서 이 부분은 한 번 쭉 듣고 일단 넘어갔다. JS 함수의 클로저는 큰 틀은 알겠는데 세부적인 내용에서 제대로 이해를 하지못해서 내일 JS 함수의 클로저에 대해서 알아보고 정리를 하고 난 후에 다시 useCallback의 종속성에 대한 강의를 들어야 할 것 같다. JS 함수의 클로저 개념에 대해 기본적으로 알아야 한다고 생각하는데 왜 지금까지 몰랐을까 하는 생각이 좀 들었다. 내일 차분히 클로저에 대한 내용을 알아보고 공부해서 정리하고 useCallback 종속성에 대해 이해하고 난 후에, state 및 컴포넌트의 내용인 state 스케줄링에 대한 내용을 배우고, useMemo로 최적화 하는 방법도 배운 다음에, 이제까지 함수 컴포넌트에 대한 내용만 배웠기 때문에 클래스 컴포넌트에 대한 내용도 배우고 공부할 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- JS의 클로저(Closure)에 대해 공부가 필요함

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
