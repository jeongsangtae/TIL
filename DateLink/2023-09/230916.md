# 오늘 한 일

### React 공부

- React의 백그라운드 작업에 대해 알아보기 & 최적화 테크닉 살펴보기

  - JS 함수의 클로저
    - 클로저에 대해 이해하면 변수의 스코프, 메모리 관리, 함수의 동작 등 다양한 측면에서 더 나은 코드 작성이 가능해진다.
    - 클로저란 ?
      - 클로저는 함수가 다른 함수 내부에서 정의되고, 해당 함수가 자신이 정의된 외부 스코프의 변수에 접근할 수 있는 기능을 의미한다.
    - 왜 클로저를 사용하는가?
      - 클로저를 사용하면 함수 내에서 상태를 유지하고, 비공개 변수(private variables)를 구현하거나 데이터 은닉을 달성할 수 있다.
      - 함수 팩토리 패턴, 모듈 패턴, 비동기 작업에서 상태 관리 등 다양한 상황에서 유용하게 활용된다.
    - 클로저의 작동 원리
      - 함수 내부에서 함수가 정의되면, 내부 함수는 외부 함수의 스코프에 대한 참조를 유지한다.
      - 외부 함수가 실행을 마치더라도 내부 함수가 외부 함수의 스코프에 접근할 수 있으며, 이로인해 클로저가 형성된다.
      - 클로저는 내부 함수와 그가 접근하는 외부 스코프 변수를 포함한 렉시컬 스코프를 만든다.
    - 클로저 사용 사례
      - 함수 팩토리
        - 매번 다른 초기 상태를 가진 함수를 생성할 때 사용한다.
      - 비동기 작업
        - 콜백 함수에서 외부 변수에 접근하여 상태를 관리한다.
      - 모듈 패턴
        - 비공개 변수와 메서드를 구현하여 데이터 은닉을 제공한다.
      - 이벤트 핸들러
        - 이벤트 리스너 함수에서 클로저를 사용하여 특정 상태를 유지한다.
    - 클로저를 간단하게 요약해서 설명하면 ?
      - 함수 내부에서 다른 함수를 정의하고, 그 내부 함수가 외부 함수의 변수에 접근할 때, 그 내부 함수는 클로저이다.
      - 클로저를 사용하면 외부 함수의 변수를 기억하고, 나중에도 그 변수에 접근할 수 있다.
      - 함수 내에서 정의된 함수가 외부 변수를 기억하고 사용할 수 있다.
      - 클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있다.
      - 클로저는 이처럼 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용할 수 있게하는 폐쇄성을 갖는다.
    - 추가로 예시와 함께 더 자세한 설명은 [생활코딩 클로저](https://opentutorials.org/course/743/6544) 내용 참고

  <br />

  - useCallback 종속성 추가 정리

    - 함수가 정의될 때 JS는 해당 함수 안에서 사용되는 모든 변수를 잠그게 된다.
      - 함수 외부에서 사용하는 모든 변수라고 해야 좀 더 정확하다.
    - JS는 상수(allowToggle)에 클로저를 만들고, 함수를 정의할 때 사용하기 위해 상수를 저장한다.
    - 이렇게 구성하면, 다음에 해당 상수(toggleParagraphHandler)가 실행이 되면 저장된 상수(allowToggle)를 그대로 사용하게 된다.
    - 따라서, allowToggle 변수의 값은 변수가 저장된 시점의 값을 사용하게 된다. 일반적으로 완벽한 기능이다.
    - 이 클로저 기능을 사용하면 함수 밖의 변수를 함수 안에서 쓸 수 있으며, 우리가 원하는 시점에 함수를 호출할 수 있다.
    - App 함수가 토글 상태가 변경되어 재평가, 재실행되면 React는 이 함수(useCallback 함수를 말함)를 재생성하지 않는다.
      - 이유는 useCallback을 통해 React에게 어떤 환경에서든 함수 재성성을 하지 않게 막았기 때문이다.
    - 따라서, React가 함수에 사용하기 위해 저장한 allowToggle의 값은 최신의 값이 아니고, App 컴포넌트가 처음 실행된 시점의 값을 저장하고 있다.
      - JS는 함수 생성 시점의 allowToggle 상수의 값을 저장하고 있기 때문이다.
    - 문제가 발생할 수 있는데, 함수 재생성을 필요로 하는 때가 있을 수가 있는데, 해당 함수에서 사용하는 함수 외부에서 오는 값이 변경되었을 수 있기 때문이다.
      - 지금의 사례가 그 경우로, 의존성 배열에 allowToggle을 종속 형태로 추가해 문제를 해결
    - 일반적으로 useCallback에 들어가 있는 함수 내용은 React에게 해당 함수를 저장해달라고 하는 것이다.
      - 하지만, allowToggle의 값이 바뀌고 새로운 값이 들어오면, 함수를 재생성하고 새로 만든 함수를 저장하길 원하기 때문에, 이렇게 하면 함수에 항상 allowToggle의 최신 값만을 사용하게 된다.
      - 의존성 배열에 allowToggle를 추가함으로서 allowToggle의 최신 값을 사용할 수 있게 된다는 말
      - allowToggle이 변경되지 않는다면 그럴 땐 함수 재생성을 하지 않는다.

    ```
    function App () {
      const [showParagraph, setShowParagraph] = useState(false);
      const [allowToggle, setAllowToggle] = useState(false);

      const toggleParagraphHandler = useCallback(() => {
        if (allowToggle) {
          setShowParagraph((prevShowParagragh) => {
            return !prevShowParagragh;
          });
        }
      }, [allowToggle]);

      const allowToggleHandler = () => {
        setAllowToggle(true);
      };
    }
    ```

  - state 스케줄링 및 일괄 처리
    - 대다수의 성능 기반의 작업들이 거의 동시에 진행되는데 잠재적으로 React는 더 높은 우선순위를 갖는 것으로 간주한다.
    - 예로 화면에 사용자가 입력할 수 있는 공간이 있다고 가정하면 사용자 입력에 응답하는 것이 화면의 문자를 변경하는 것보다는 더 우선순위가 높다.
      - 이러한 이유로 React는 예정된 상태 변경을 연기할 수 있다.
    - React는 상태 변화가 발생하게 되면 이 상태 변화의 순설르 명확히 해서, 같은 타입임을 보증한다.
    - 다수의 예약 상태 변화가 동시에 있을 수 있다.
      - 이 때문에 동시에 여러 번의 갱신이 스케줄될 수 있으므로 상태를 갱신할 때는 함수 형태를 이용해서 갱신하는 것을 추천한다.
      - 이전 상태의 스냅샷에 의존해야 한다면 특히 더 함수가 필요하다.
    - 사실 많은 경우에 크게 문제가 되지 않는데, 굉장히 빠르게 처리가 되기 때문에 잠깐의 지연조차 느끼지 못할 정도다.
    - 하지만 이론상으로 스케줄링 작업은 지연될 수 있으므로 이는 상태 변경이 순서대로 처리되고 이전 상태를 기반으로 매 회 상태 변경이 발생할 때마다 가장 최신의 상태를 얻을 수 있게 해주는 안전한 방법이다.
      - 그렇지 않다면 컴포넌트 함수가 마지막으로 실행될 때의 상태를 얻을 텐데 이는 상태 변경이 순서대로 실행될 때와는 조금 다른 결과가 나올 수도 있다.
      - 완료되지 않은 상태 변경 작업이 여러 개가 있다면 App 컴포넌트의 재 렌더링 주기는 모두 동일하기 때문이다.
    - 함수 형태를 사용해야 React가 미완료된 상태 변경 작업에 대해 최신의 상태를 사용하고 컴포넌트가 재 렌더링되었을 그 시점의 상태를 사용하지 않게 된다.
    - 컴포넌트가 재 렌더링되었을 때의 시점과 상태 변경이 예약되는 시점의 차이를 아는 것이 중요
    - 하나의 컴포넌트가 재평가되면서 미완료된 상태 변경 작업이 여러 개 있을 수 있다.
      - 이 것이 핵심이고, 함수 형태가 중요한 이유이다.
    - 상태 갱신 스케줄링은 꼭 기억하고 있어야 할 매커니즘으로, 단순히 이 것을 통해 뭔가 하려고 하는 것이 아니다. 스케줄 업데이트 관리는 React가 해주기 때문이다. 하지만 데이터 없이 작업을 할 때 발생할 수 있는 잠재적인 위험을 배제하기 위함이다.
    - 예로 하나의 함수 내에서 두 개의 상태 변경이 있다면, 하나의 상태 변경 작업 스케줄이 존재하게 된다.
      - 즉, 단 하나의 프로세스를 가지며 컴포넌트의 재실행, 재평가로 인한 2번의 변경 작업이 아니고, 함수 내의 모든 상태 변경을 하나의 작업으로 결합해놓은 스케줄이다.

  <br />

  - useMemo Hook

    - 기본적으로 저장을 할 수 있는데, useCallback이 함수에 대한 것을 저장하듯 모든 종류의 데이터를 저장할 수 있다.
    - useState와 같이 React Hook이기 때문에, useMemo를 import해서 사용해야 한다.
    - useMemo의 첫 번째 인자에는 함수가 들어가야 한다.
      - 하지만 함수를 기억하게 하는 건 아니고, 이 함수는 내가 저장하고 싶은 것을 반환한다.
      - 이 경우에서는 정렬된 배열을 반환
    - useMemo는 useCallback과 마찬가지로, 2개의 인자를 필요로 하는데 그 것은 의존성 배열을 필요로 한다.
      - 의존성 배열을 통해 저장된 값에 변경 사항이 생길 때마다 업데이트된다.
      - 여기서는 값이 변경되고, 새로운 값이 추가될 때 재정렬을 한다.
      - props에서 items가 나오기 때문에, 전체 props 객체가 여기에서 의존성이 된다.
      - props에서 무언가를 꺼내기 위해 디스트럭처링을 사용할 수 있는데, props를 객체 디스트럭처링하고, items을 의존성으로 사용하면 items에 변경 사항이 발생할 때만 리빌드를 진행하게 된다.
    - items는 App이 재실행될 때마다 새로운 배열을 생성하기 때문에 재성성된다. 기술적으로는 같은 값을 가지고, 같은 순서로 된 비슷한 배열이지만 메모리 상에서는 새로운 배열이기 때문에 내포한 값이 같더라도 기존 배열과 다른 새로운 배열로 취급한다.
      - 이 내용이 계속 이 강의에서 여러 번 언급했던 참조 값이다.
    - useMemo의 두 번째 인자에서 빈 의존성 배열을 추가하면, 값에 변함이 없음을 의미한다. 외부 의존성이 없다.
    - useMemo를 사용해 데이터를 저장하면 이는 메모리를 사용하는 것이고, 함수 저장 또한 일정 성능을 사용하는 것이다.
      - 따라서 useMemo는 사용하는 모든 값마다 사용하는 것이 아니다.
      - 뭔가를 정렬하는 경우라면 이후의 컴포넌트 업데이트에서 불필요한 정렬을 막을 수 있으므로, 이를 사용하는 것이 좋다.
      - 결론은 무분별하게 사용하지 말고, 적절히 필요할 때 판단해서 사용하라는 말이다. 결국 메모리를 사용하기 때문에 무분별하게 사용하지 않는 것이 좋다.

    ```
    // useMemo 추가 전
    const sortedList = props.items.sort((a, b) => a - b);



    // useMemo 추가 후 (객체 디스트럭처링을 미사용)

    const sortedList = useMemo(() => {
      console.log('Items sorted');
      return props.items.sort((a, b) => a - b);
    }, [props]);



    // useMemo 추가 후 (객체 디스트럭처링을 사용)
    const { items } = props;

    const sortedList = useMemo(() => {
      console.log('Items sorted');
      return items.sort((a, b) => a - b);
    }, [items]);
    ```

    - App 컴포넌트와 DemoList 컴포넌트의 내용 전체를 보려면 [모듈 리소스](https://github.com/academind/react-complete-guide-code/blob/12-a-look-behind-the-scenes/code/07-finished/src/components/Demo/DemoList.js)에서 보면 된다.
      - TIL에서 추가하지 않은 App 컴포넌트 내용이 있으며, DemoList 내용 전체도 볼 수 있다.
      - App 컴포넌트에서 useMemo를 사용하고 의존성 배열로 빈 의존성 배열을 사용하는 것을 확인할 수 있다.

  <br />

  - React의 백그라운드 작업에 대해 알아보기 & 최적화 테크닉 살펴보기에 대한 결론
    - 이 내용은 경험이 있어야 사용할 수 있는 것들로 되어있으며, 내가 선호하는 것에 따라 원하는 것을 선택할 수 있고 거기에 정답은 없다. 다만 알고 있어야 하는 것은 어플리케이션이 느려지거나 어느 부분을 개선해야 할 때 이런 식으로 최적화가 가능한 부분을 찾아보는 것이 좋다.

<br />

# 오늘 느낀 점

- JS 함수의 클로저 개념에 대해서는 앞으로 더 공부가 필요해보인다. 큰 틀로 어떤 내용인지 파악은 했는데 React Hook을 배울 때보다 내용이 뭔가 확 와닿는 느낌이 안오기 때문에 내일 한 번 더 내용을 듣고 봐볼 생각이다. 그래도 useCallback 종속성에 대한 내용을 다시 들으면서 클로저에 대한 내용도 좀 더 이해가 가긴 했지만, 아직 부족하다는 느낌이 든다. state 스케줄링에 대한 내용은 간단하게 말하면 React가 우선순위를 가지고 있기 때문에 다수의 예약 상태 변화가 동시에 있을 수 있으므로, 상태를 갱신할 때는 함수 형태를 이용해서 갱신하는 것이 좋다고 한다. 그리고 하나의 함수 내에서 두 개의 상태 변경이 있다면, 컴포넌트 재실행 또는 재평가로 인해 2번의 변경 작업이 실행되는 것이 아닌, 함수 내의 모든 상태 변경을 하나의 작업으로 결합해 작동하기 때문에 함수 형태를 이용하는 것이 좋다고 하는 것이다. useMemo는 모든 종류의 데이터를 저장해 반환할 수 있는데 무분별하게 사용하면, 메모리 사용량에 대해 문제가 생길 수 있기 때문에 적절하게 필요한 경우에만 사용하는 것이 좋다. useMemo를 사용해 데이터를 저장하면 이는 메모리를 사용하고, 함수 저장 또한 일정 성능을 사용하기 때문에 사용하는 모든 값에 useMemo를 사용하는 것이 아닌, 앞에서 말한 것 처럼 필요한 경우 적절하게 사용해야 한다. 이번 섹션의 내용은 경험이 있어야 사용할 수 있는 것들로 구성이 되어있었고, 만약 어플리케이션이 느려지거나 어느 부분을 개선해야 할 때 이 내용을 참고해서 최적화가 가능한 부분을 찾아서 작업을 해보는 것이 좋을 거 같다. 내일은 함수형 컴포넌트 대신 클래스형 컴포넌트에 대해 배우고 공부할 예정인데, 예전에 클래스형 컴포넌트에 대해 조금 다뤄본 경험이 있는데 강의를 들을 때 기억이 날지는 미지수이다. 기억이 안나더라도 클래스형 컴포넌트에 대한 내용을 꼼꼼히 정리하면서 공부를 진행할 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- 해쉬맵과 cors에 대해 찾아보기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
