# 오늘 한 일

### React 공부

- 세 번째 연습 프로젝트

  - 새로 추가되는 식사 데이터 id와 이전에 추가된 식사 데이터 id가 동일할 때 이전의 데이터에 가격과 갯수의 값만 추가

    - 기존의 방식은 이전의 데이터에 의존해서 중복되는 id를 가진 객체가 계속 추가가 되었는데 바뀐 방식은 중복되는 id가 있다면 해당 id를 확인해 가격과 갯수의 값만 증가시키는 방식으로 변경했다.
    - 새로운 변수를 하나 추가해 이전 데이터를 map 함수로 새로운 배열을 만들고, if문을 통해 동일한 id를 가진 항목을 비교하고 존재한다면, 기존 데이터에 가격과 갯수를 더해 업데이트한 새로운 객체를 반환
      - 업데이트된 객체는 새로운 변수 배열에 들어가게 된다.
      - 그렇지 않은 경우, 현재 항목은 변경 없이 그대로 반환
      - map 함수를 다시 사용하는 이유는 React에서 상태를 업데이트할 때 상태를 직접 수정하지 않고 새로운 상태 객체를 생성하고 반환해야 하기 때문인데, React의 상태 업데이트는 불변성을 유지해야 하기 때문이다.
      - prevMealData 배열을 직접 수정하지 않고, map 함수를 사용해 기존의 데이터를 복사한 새로운 배열을 생성하고, 필요한 항목만 업데이트한 후 새로운 배열을 반환한다.
        - 이렇게 하면 React는 새로운 상태를 인식하고 화면을 다시 렌더링한다.
      - 만약 map 함수를 사용하지 않고 직접 prevMealData 배열을 수정하면 React는 상태 변경을 감지하지 못하고 화면을 업데이트하지 않을 수 있다. 따라서 React에서 상태를 업데이트할 때는 항상 새로운 상태를 반환하는 방식을 사용해야 한다.
      ```
      const newMealData = prevMealData.map((data) => {
        if (data.id === mealData.id) {
          return {
            ...data,
            price: data.price + mealData.price,
            amount: data.amount + mealData.amount,
          };
        }
        return data;
      });
      ```
    - 만약 동일한 id를 가진 항목이 없다면 if문 조건이 true가 되며 새로운 항목을 새로운 배열에 추가한다.
      - some 함수를 사용하는데 some 함수는 배열에서 만족하는 요소가 하나라도 존재하는지를 확인하는데 사용된다.
      - some 함수는 새로운 변수 배열에서 기존의 넘어온 데이터의 id와 동일한 항목이 이미 존재하는지 여부를 확인한다.
      - some 함수는 새로운 변수 배열을 순회하면서 각 항목의 id와 기존의 넘어온 데이터의 id를 비교하고 어떤 항목의 id가 넘어온 데이터의 id와 일치한다면, some 함수는 true를 반환하고 일치하는 항목이 없다면 false를 반환
      - 동일한 id를 가진 항목이 새로운 변수 배열에 존재하지 않는 경우 넘어온 데이터가 push 함수를 통해서 배열에 추가된다.
      - some 함수를 사용해 중복된 항목을 피하고, 이미 있는 항목인지 확인하고, 없다면 배열에 추가하는 역할을 담당
      ```
      if (!newMealData.some((data) => data.id === mealData.id)) {
        newMealData.push(mealData);
      }
      ```
    - 이렇게 set~ 함수는 이제 업데이트된 새로운 배열을 반환하고, 해당 배열이 새로운 useState 현재 값으로 설정된다.

    ```
    const totalMealAmountHandler = (mealData) => {
      setTotalMealData((prevMealData) => {
        const newMealData = prevMealData.map((data) => {
          if (data.id === mealData.id) {
            return {
              ...data,
              price: data.price + mealData.price,
              amount: data.amount + mealData.amount,
            };
          }
          return data;
        });
        if (!newMealData.some((data) => data.id === mealData.id)) {
          newMealData.push(mealData);
        }
        return newMealData;
      });
    };
    ```

  - 저장된 식사 데이터의 갯수를 누적해서 계산
    - 기존의 식사 데이터의 길이를 구해서 식사 데이터 갯수(객체 갯수)를 구했지만 강의의 모듈 소개를 보면 식사 데이터의 갯수(객체 갯수)를 구하는 것이 아닌, 식사 데이터에 저장된 각 객체의 식사 갯수를 가져와 총합을 구하는 것으로 변경
    - 이 부분에서 혼자서 너무 어렵게 생각했는데 reduce를 사용해 간단하게 해결
    - reduce를 사용해 값을 누적시켜서 결과 값을 출력
      - 초기 값은 0으로 설정
      - 식사 데이터 배열을 순회하며 각 요소(각 객체를 뜻함)를 해당 매개변수(ex:mealData)에 할당하고, 해당 요소의 특정 속성의 값을 더해서 누적된 합계를 계산
      - 초기 값은 0으로 설정했기 때문에 첫 번째 요소의 mealData.(특정 속성), 두 번째 요소, 세 번째 요소 등을 처리하면서 누적된 합계를 계산해 해당 변수에는 전체 배열의 mealData.(특정 속성) 값의 합계가 저장된다.
    ```
    const totalMealAmount = totalMealData.reduce((totalAmount, mealData) => {
      return totalAmount + mealData.amount;
    }, 0);
    ```
    - 이렇게 계산함으로써 length가 필요 없어졌기 때문에 기존의 배열의 길이를 실행하고 출력하기 위해 괄호를 추가한 부분은 괄호를 전부 삭제

  <br />

  - 앞에서 사용한 reduce를 Cart 컴포넌트에서 다시 사용해 장바구니에 저장된 모든 식사 가격의 총 합을 구함

    - prop을 통해서 전달받은 식사 데이터를 똑같이 reduce를 사용하는데 이번에는 amount가 아닌, price 속성의 값을 구해서 장바구니에 저장된 모든 식사 가격의 총 합을 출력

    ```
    const totalMealPrice = props.totalMealDatas.reduce((totalPrice, mealData) => {
      return totalPrice + mealData.price;
    }, 0);

    <p>${totalMealPrice}</p>
    ```

<br />

# 오늘 느낀 점

- 새로 추가되는 식사 데이터가 이전 식사 데이터와 중복될 때 이전 식사 데이터의 갯수와 가격만 추가되도록 수정을 해주었는데 이 부분은 내가 많이 생각해보고 고민해보았는데 if문을 사용해 조건까지는 얼추 구성했는데 처리하는 부분에서 완벽하게 해결하지 못해서 좀 도움 받아서 해결했다. 그래서 다음에 비슷한 경우에서 스스로 처리할 수 있도록 코드의 내용을 파악하고 정리해놓았다. 막상 해결하는 코드의 내용을 보면 어려운 내용이 아니고, 이와 유사하게 머릿속으로 구조는 파악이 되는데 이걸 코드로 작성하는 부분에서 어려움을 겪는데 정말 많은 실습과 연습이 필요하다고 다시 한 번 생각하게 되었다. 저장된 식사 데이터의 식사 갯수가 장바구니 버튼에 출력되도록 하는 부분을 수정했는데 이 부분은 내가 너무 복잡하게 생각을 했던 거 같은데 reduce를 사용해 간단하게 해결을 했다. 장바구니 버튼 컴포넌트에서 식사의 총 갯수를 구하는 reduce 함수를 장바구니 컴포넌트에서도 사용해 이번에는 식사의 총 가격을 계산하고 출력되도록 구성해주었다. 이번에 reduce 함수를 사용하면서 reduce 함수가 어떤 역할을 하는지, 어떤 상황에서 사용해야 하는지, 어떤 방식으로 사용해야 하는지 확실하게 알고 가는 좋은 기회가 된 것 같다.

- 원래 오늘까지 기능을 다 구현하기로 마음먹고 안된다면 내일부터 솔루션을 보며 추가하기로 생각했으나, 마지막 기능 하나만 남았기 때문에 스스로 마지막 남은 기능까지 구현을 해보고 중~고급 기술은 솔루션을 보고 구성을 해보려고 생각중이다. 어제까지는 정말 구상은 되어있는데 이 부분을 어떻게 코드로 구현해야 하는지 막혀서 진행이 안되었는데 reduce 함수를 추가해 해결하고나서 남은 마지막 기능도 reduce 함수를 사용하면 해결이 될 수 있을 거 같다는 생각에 내일까지 기능 구현을 해보기로 마음을 먹게 되었다. 딱 내일 마지막 남은 기능을 구현해보고 정말로 도저히 답이 안나오거나 해결할 수 없다고 생각이 들면 바로 솔루션으로 넘어가 진행할 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

- React Hook나 React 내용 따로 정리

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
