# 오늘 한 일

### React 공부

- React Router가 있는 SPA 다중 페이지 구축하기

  - 상대 경로와 절대 경로
    - 현재 구성해놓은 라우트는 모든 경로는 절대 경로로 구성되어 있다.
      - 이유는 모두 "/"로 시작하기 때문이다.
      - 그 의미는 간단한데 그 것들이 항상 도메인 이름 뒤에서부터 나타난다는 의미이다.
      - 이건 중요한 세부정보다.
    - 예로, 레이아웃 래퍼 경로를 "/root"로 변경하면 어떻게 될까 ?
      - 다시 로딩하면 /products에는 아무것도 없게 된다.
      - /root/products/에도 아무것도 없다.
      - /roote라고만 입력해도 아무것도 나오지 않는다.
      - 개발자 도구를 열어보면 절대 라우트 경로 "/"가 경로 "/root" 아래에 중첩되었다고 나온다.
      - `path: "/root",`
    - 절대 경로가 있는데 그 절대 경로는 "/"로 시작하기 때문에 이런 방식으로 경로들이 절대 경로인지 분간할 수 있다.
      - 경로가 "/"로 시작되면 그건 절대 경로
    - 자녀 라우트 앞에 있는 "/"를 제거하면 라우트 정의 경로가 상대 경로로 변하게 된다.
      ```
      { path: "", element: <Home /> },
      { path: "products", element: <Products /> },
      { path: "products/:productId", element: <ProductDetail /> },
      ```
      - 이제 여기엔 절대 경로가 아닌 상대 경로가 있게 된다.
      - 라우트를 정의할 때 정의된 경로들이 래퍼 라우트의 경로 뒤에 첨부된다는걸 의미한다.
      - 상대 경로로된 자녀 라우트가 있다면 react router는 부모 라우트의 경로를 살펴보고 자녀 라우트를 부모 라우트 경로의 뒤에 첨부하게 된다.
      - 이렇게 변경핳면 오류가 사라지게 된다.
      - /root에는 시작 페이지가 나오고, /root/products에는 제품 페이지가 나온다. 그냥 /products라고 하면 아무것도 나오지 않는다.
        - 기본 오류 메시지가 다시 나오게 된다.
        - 내가 만들었던 오류 페이지의 콘텐츠도 볼 수 없게 된다.
        - 오류 요소는 /root 경로에 추가되어 있고, / 뒤에서 찾으려는 페이지에 대해 오류를 받았기 때문이다. 그래서 오류 페이지가 작동하지 않는 것이다.
      - 시작 경로를 /root로 하지 않고, 대신에 / 로 다시 하려는 경우에도 자녀 라우트에 상대 경로를 계속 쓸 수 있다.
        - 자녀 라우트에 있는 경로들은 래퍼 부모 라우트의 경로 뒤에 첨부되기 때문이다.
    - 링크 경로도 중요한 역할을 한다.
      - MainNavigation.js, Products.js 역시 경로를 정의하고 앞에서와 같은 규칙이 적용된다.
      - 만일 경로가 / 로 시작되면, 즉 앞에 / 가 있으면 그건 절대 경로이다.
      - 링크를 클릭하면 항상 /products와 같은 곳으로 방문을 하게 된다.
      - 다시 부모 라우트 정의에서 /root로 전환하면 문제가 나타나는데 /root/products로 가면 잘 작동된다.
        - 하지만 링크를 하나 클릭하면 오류가 발생한다.
        - 이 링크는 /products/p1으로 연결되기 때문이다.
        - 이유는 Products.js 파일에서 `/products/${product.id}` 이와 같이 정의해놓았고, 그게 / 로 시작되기 때문에 절대 경로이기 때문이다.
        - 도메인 이름 바로 뒤에 추가되는 것이지 현재 활성인 경로 뒤에 추가되지 않는다.
      - 링크에 상대 경로를 만들 수 있다.
        - 이 작업을 Home.js 파일에서 할 수 있다.
        - /products에 링크하는 대신에 그냥 products로 변경한다.
        - 이제 상대 경로로 변경이 되었고, 링크는 상대 경로를 갖게 된다. 그러면 기본적으로 products 경로가 현재 활성인 경로의 뒤에 추가된다.
        - Products.js에서 간단히 /products/ 부분을 삭제해서 상대 경로로 전환할 수도 있다.
          - 이렇게 하면 현재 활성인 라우트 경로 뒤에 그냥 product.id를 추가하고 있게 된다.
          - 즉 템플릿 리터럴 부분 전체를 삭제하고 그냥 경로를 {product.id}로 변경할 수 있게 된다.
          - 이렇게 되면 현재 활성인 경로 뒤에 추가되고 링크가 다시 작동하게 된다.
    - Link 컴포넌트를 사용할 때 특수한 프로퍼티인 relative 프로퍼티를 추가할 수도 있다.
      - relative 프로퍼티는 path 또는 route 중에 하나로 설정할 수 있다.
      - 그걸로 세그먼트를 현재 활성인 라우트 경로에 대해 상대적으로 추가하는지 또는 URL에서 현재 활성인 경로에 대해 추가하는지 제어한다.
        - 가끔 같을 수도 있고, 그렇지 않을 수도 있다.
      - ProductDetail.js에서 Link가 있는 또 다른 단락을 추가
        - to 프로퍼티를 추가하고 `..`을 추가해서 구현할 수 있다.
          - `..` 이건 특수 식별자이고, 이걸 시스템 터미널에서 본 적이 있다. 그냥 한 수준 위로 올라간다는 의미를 가지고 있다.
          - 이전에 활성이었던 경로와 라우트로 돌아가라는 뜻이다.
          - `<p><Link to="..">Back</Link></p>`
    - Products.js에서 relative를 삭제하고 확인
      - ProductDetail.js에서 만든 링크로 relative 프로퍼티의 작동을 보여줄 수 있기 때문이다.
    - 코드를 테스트해보면 Back을 클릭했을 때 root 페이지로 돌아오게 된다.
      - 제품들 중에 하나를 클릭해서 제품 페이지에 들어왔는데, 제품 페이지에서 Back을 클릭하면 root 페이지로 돌아가버린다.
      - 제품 페이지를 방문할 때 URL을 보면 /root/products/ 그리고 그 제품의 id가 들어간다.
      - 여기서 Back을 클릭하면 그냥 /root로 간다. /products/p2가 URL 경로에 제거되었다.
      - 이렇게 된 이유는 뒤로 가면 좀 이상하게 보이긴 하지만 상대 경로인 `..` 상대 경로가 라우트 정의에 대해 상대적으로 리졸빙되었기 때문이다.
      - 예를 들면 ProductsDetail 라우트 정의는 /root 라우트의 자녀이고, /products의 형제이다. 그래서 한 수준 위로 가고 이전 라우트 경로로 돌아간다면 형제가 아닌 부모의 라우트 경로로 돌아간다는 의미가 된다.
      - 경로에서 한 세그먼트만 제거하는게 아니라 부모 라우트 경로로 돌아가게 된다.
        - 즉 두 개의 세그먼트를 제거하게 된다.
        - 이 경우에는 /products 와 /productsId
    - 만약 위에서 추가한 ProductsDetail.js의 Back 링크에 대한 거동을 변경하려 한다면 relative 프로퍼티를 써서 해결할 수 있다.
      - relative를 path로 설정할 수 있고, 기본 값은 route로 되어있다.
        - `ralative="path"`
      - route로 설정하고 테스트해보면 /root로 이동하게 된다.
      - path로 설정하면 react router는 현재 활성인 경로를 살펴보고 그 경로에서 한 세그먼트만 제거하게 된다.
      - 이 구성 상태로 테스트해보면 ProductDetail.js에서 Back 링크를 클릭하면 이제는 /root가 아닌, /root/products인 제품 목록 페이지로 돌아가는 걸 확인 할 수 있다.
        - 현재 활성인 경로에서 제품의 id만 제거되었기 떄문이다.
    - 위의 내용들은 경로, 링크, 상대 경로, 절대 경로를 다룰 때 항상 기억해둬야 할 중요한 특징이다.
      - 만약 to 프로퍼티에 절대 경로가 있으면 relative 프로퍼티는 중요하지 않다. 항상 그 절대 경로가 도메인 뒤에 추가되기 떄문이다.
      - 예로, 단순히 뒤로 가는 특수한 점 두 개 경로 같은 상대 경로가 있으면 relative 프로퍼티를 써서 react router의 거동을 제어할 수 있다.
      - 설령 그게 없어도 상대 경로와 절대 경로 사이에는 차이가 있다는 걸 알고 있어야 하고, 차이점을 기억해야 한다.
    - to 프로퍼티에서 `..`을 사용하고, relative를 사용했을 때 path와 route 이동 내용 정리
      ```
      {
        path: "/",
        element: <Root />,
        errorElement: <Error />,
        children: [
          { path: "", element: <Home /> },
          { path: "products", element: <Products /> },
          { path: "products/:productId", element: <ProductDetail /> },
        ],
      },
      ```
      - 이 내용으로 살펴보면 relative에서 path를 사용할 경우 하나의 세그먼트만 제거하기 때문에 /products/:productId에서 /products로 이동한다.
        - 결국 보면 path로 설정되면 현재 경로의 세그먼트를 제거하고 한 단계 위로 이동하게 된다.
      - relative에서 route를 사용할 경우 동일한 레벨의 경로 중 하나를 제거해서 /products/:productId에서 /로 이동한다.
        - route로 설정하면 동일한 레벨의 경로 중 하나를 제거한다. 그래서 형제 라우트인 products와 products/:productId와 같은 레벨에 있으므로, 이전 경로와 현재 경로와 그 형제 라우트 중 하나를 제거하게 된다.
        - 결국 products와 products/:productId 모두 삭제되고, 최종적으로 / 로 이동하게 된다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/4cdbba6607cf3f464a6c57cff89691831182c7eb)

  <br />

  - 인덱스 라우트 사용하기
    - 상대 경로, 절대 경로와 관련된 내용으로 이 것들과 약간 관련된 특수 프로퍼티가 있다.
      - 일부 라우트 정의에 추가할 수 있는 프로퍼티
      - 예로, 여러 라우트 중에서 Home 라우트에 적용하는 특수 프로퍼티다.
    - Home 라우트 정의의 특별한 부분은 무엇이 있을까?
      - 결론적으로 Home 라우트 정의에는 경로가 없다.
      - 대신에 Home 라우트는 부모 라우트에 있는 경로와 동일한 경로에 대해 로딩되어야 한다.
      - 래핑 레이아웃을 갖길 원하기 때문에 다른 라우트가 2개 있다.
      - 하지만 현재 구성한 것처럼 래핑 레이아웃을 갖는 경우가 상당히 흔하다.
      - 부모 라우트 경로에 대해 로딩되어야 하는 자녀 라우트가 하나 있다.
        - 빈 경로를 추가해서 해결할 수 있다.
      - 빈 경로를 추가하는 대신에 특수한 index 프로퍼티를 추가하고 그걸 true로 설정할 수 있다.
        - `{ index: true, element: <Home /> },`
        - 이렇게 해주면 해당 라우트가 index 라우트로 변한다.
        - 부모 라우트가 현재 활성이면 표시되어야 하는 기본 라우트가 해당 라우트라는 의미이다.
        - 그래서 products나 products/:productId에 대해서는 로딩되지 않는다.
        - "/"에 있으면 인덱스 라우트가 활성화된다.
    - 코드를 저장하고 테스트해보면 애플리케이션은 앞에서와 같은 작동을 한다. 하지만 해결하는 방법이 달라졌다.
      - 인덱스 라우트라는 기능을 알아야 한다.
        - 즉 부모 라우트가 활성일 경우에 로딩되어야 하는 기본 라우트를 정의할 수 있게 해준다.
      - 물론 인덱스 라우트를 꼭 써야 하는 건 아니다.
      - 활용 사례와 애플리케이션에 따라 다르다. 하지만 가끔 기본 라우트가 필요할 때가 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/330fede5ed51ce9ea48f506e7b69c5c27c5ba439)

  <br />

  - 새로운 프로젝트
    - 백엔드 API와 프론트엔드 폴더로 구성
    - 백엔드 API 폴더
      - React 코드가 없는 더미 백엔드 애플리케이션이 포함되어 있다.
      - 강의 섹션 내내 이걸 사용해서 더미 백엔드를 다룰 예정
      - Firebase나 공용 더미 API 같은 공용 서비스도 사용할 수 있는데, 여기에서는 사용할 커스텀 더미 API를 제작해서 제공해주었다.
      - 백엔드 API 폴더에서 코드를 작성할 필요가 없다. 단지 미리 작성해서 제공해준 것
      - React와는 관련이 없다.
      - React와 관련이 없는 NodeExpress 코드이다.
      - React 앱 안에서 백엔드 API로 요청을 전송할 수 있다.
    - 프론트엔드 폴더
      - 강의 섹션에서 계속 다룰 React 앱이 있다.
      - 현재는 비교적 단순한 컴포넌트이고, 약간의 기본 스타일이 제공되어 있다.
      - 이 섹션의 나머지 부분에선 React를 이용한 라우팅에 대해 더 자세히 알아볼 예정
    - 백엔드 서버와 프론트엔드 서버를 각각 독립적으로 시작해야 한다.
      - 터미널에서 cd backend-api 폴더로 이동해서 거기서 npm install을 실행해야 한다.
        - 그 다음 npm start를 실행해서 백엔드 서버를 시작하고 프로그램 전체를 다루는 동안에 그 프로세스가 계속되도록 해두어야 한다.
        - React 프론트엔드를 다시 다루려면 backend-api 폴더에서 백엔드 서버를 항상 다시 시작해야 한다.
        - 나중에 프론트엔드가 백엔드와 대화할 수 있어야 하기 때문이다. 그러려면 백엔드 서버가 가동 중이고 실행 중이어야 한다.
      - 별도의 터미널 창에서 cd react-frontend를 입력해 초기에 React 프론트엔드 애플리케이션을 위해 모든 의존성을 설치(npm install)해야 한다.
        - React 애플리케이션을 다루기 위해서는 React 프론트엔드 dev 서버도 시작해야 한다.
    - 이 강의 섹션을 위해서는 백엔드와 프론트엔드 서버가 모두 가동되고 실행되어야 한다.

  <br />

  - 연습 시간 : 문제
    - 고급 기능들을 살펴보기 전에 배운 내용을 연습하는 시간
    - 라우팅에 관한 기초 지식을 복습
    - 프론트엔드의 scr 폴더에 있는 App.js 파일 안의 예제를 풀어야 함
    - 라우트 정의를 설정하고 링크를 넣는 등 많은 작업이 필요함
    - 우선 React Router DOM을 설치하고 라우팅을 설정해야 한다.
    - 해결해야 하는 챌린지 내용
      1. 5개의 새로운 (더미) 페이지 구성 요소를 추가하기
      - 콘텐츠는 간단한 h1 요소일 수 있다.
      - HomePage
      - EventsPage
      - EventDetailPage
      - NewEventPage
      - EditEventPage
      2. 이 5개 페이지에 대한 라우팅 및 경로 정의를 추가하기
      - / -> HomePage
      - /events -> EventsPage
      - /events/"some-id" -> EventDetailPage
      - /events/new -> NewEventPage
      - /events/"some-id"/edit -> EditEventPage
      3. 모든 페이지 구성 요소 위에 "MainNavigation" 구성 요소를 추가하는 루트 레이아웃을 추가하기
      4. "MainNavigation"에 제대로 작동하는 링크를 추가하기
      5. "MainNavigation"의 링크가 활성화되면 "active" 클래스를 수신하는지 확인하기
      6. 더미 이벤트 목록을 "EventsPage"에 출력하기
      7. 선택한 이벤트의 ID를 "EventDetailPage"에 출력하기
      8. 보너스 과제로, 모든 /events... 페이지 구성 요소 위에 "EventNavigation" 구성 요소를 추가하는 또 다른 (중첩) 레이아웃 경로를 추가하기
    - 마지막 단계는 보너스 과제로, 이론적으로는 해결할 수 있지만 앞에서 해보지 않은 것을 요구하고 있다. 그래서 과제를 완성하지 못해도 실망하지 않고, 도전해본 다음 안된다면 해설을 보고 이해하면 된다.
    - 모든 과제와 챌린지를 직접 풀어보는 것이 중요함
      - 반드시 먼저 직접 풀어봐야 함, 그래야 강의의 효과가 극대화된다.

<br />

# 오늘 느낀 점

- 상대 경로와 절대 경로에 대해 배웠는데 이 부분은 내용을 조금 더 찾아보고 이해가 필요하다고 생각이 된다. 어떤 식으로 사용하는지 파악은 했지만, 이게 어떤 상황에서 절대 경로가 좋고 어떤 상황에서 상대 경로가 좋은지 이 부분에 대한 내용은 듣지 못해서, 절대 경로와 상대 경로의 장단점에 대해 찾아보고 한 번 정리를 해야 할 것 같다. 그리고 Link 컴포넌트의 to 프로퍼티에서 ".."을 사용하고 relative를 사용해서 바로 윗 단계로 이동하도록 구성할 때 path와 route 사용에 대한 차이점을 따로 정리해놓았는데 확실히 한 번 더 정리하면서 내용을 살펴보니 이해가 확실하게 된 거 같다. 인덱스 라우트를 지정하는 방법도 배웠는데 간단하게 특수 프로퍼티인 index를 path 대신에 사용해서 지정해줄 수 있는데, 인덱스 라우트를 꼭 필수로 써야 하는 것은 아니며, 애플리케이션의 구조나 특성에 따라 다르다고 생각이 된다.

- 라우팅에 대한 기본적인 지식은 배웠기 때문에 이제는 라우팅에 대해 더 자세히 알아보고 고급 라우팅 기능들도 살펴보며 데이터 가져오기와 제출하기도 추가하고, React router가 있는 SPA 다중 페이지를 구축하는 연습을 진행해볼 예정이다. 본격적으로 SPA 다중 페이지를 구축하기 전에 먼저 라우팅에 관한 기초 지식을 복습하는 겸 챌린지를 통해 앞에서 배운 내용을 연습하는 시간을 가질텐데 기본적인 페이지 구성 요소 추가, 페이지에 대한 라우팅 및 경로 정의 추가, 모든 페이지 구성 요소 위에 네비게이션 바를 추가하는 루트 레이아웃 추가, 네비게이션 바를 통해 페이지 이동하는 링크 추가, 네비게이션 바에서 현재 활성인 페이지를 알 수 있도록 "active" 클래스가 수신되도록 해줘야 하며, 더미 이벤트 목록을 이벤트 페이지에 출력하고, 선택한 이벤트에 해당되는 ID에 맞는 이벤트 세부 정보를 출력해야 한다. 그리고 보너스 과제로 모든 페이지 구성 요소 위에 이벤트 네비게이션 바를 중첩 레이아웃 경로로 추가를 해야 하는데 이 부분은 배운 내용은 아니지만, 그래도 만드는 시도를 해볼 수 있기 때문에 최선을 다해서 보너스까지 구성을 해볼 생각이다. 이 과제들에 대해 해설을 보지 않고 먼저 직접 풀어보는 것이 강의의 효과를 극대화할 수 있다고 하기 때문에 바로 페이지부터 추가해보면서 차근차근 진행해볼 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
