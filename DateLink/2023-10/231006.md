# 오늘 한 일

### React 공부

- 연습 프로젝트 : 음식 주문 앱에 Http 및 양식 추가 (솔루션)

  - Http를 통해 식사 데이터 가져오기
    - useEffect로 입력한 함수는 promise를 반환해서는 안된다.
      - cleanup 함수는 동시에 실행해야 하기 때문에 불가능
      - cleanup 함수는 promise 같은 것을 반환하지 않는다.
      - 따라서 useEffect에 입력한 전체 함수는 async 함수로 변경해서는 안된다.
      - useEffect 대신 async/await를 사용하고 싶다면 새 함수를 만들어서 그 곳에서 async/await를 사용하고, 중첩된 내부 함수로 입력해야 한다.
      - 이렇게 사용하면 async/await를 여전히 사용할 수 있다. 하지만 useEffect 함수 전체는 이제 promise를 반환하지 않는다.
      - 이 방법은 useEffect에서 promise를 사용하지 못하는 제한에 대한 약간의 회피를 통한 방법이다.
    - 데이터를 받아오는데 여기서 객체로 받기 때문에 배열로 받기 위해서 변환
      - 빈 배열을 추가해주고, for in 반복문을 사용해, 받아오는 데이터 객체의 모든 키를 반복
      - push를 통해서 빈 배열에 넣어주는데, id, name, description, price를 가져온다.
        - 여기서 id는 key, name, description, price는 중첩 객체에 액세스해서 데이터를 가져온다.
        ```
        for (const key in data) {
          loadedMeals.push({
            id: key,
            name: data[key].name,
            description: data[key].description,
            price: data[key].price,
          });
        }
        ```
    - for 반복문 후에 빈 배열에 변형된 데이터를 채우고, useState 업데이트 함수를 호출해 그 안에 변형된 데이터를 넣어서 업데이트한다.
    - useEffect의 의존성 배열은 빈 배열로 놔두는데, 컴포넌트가 처음 로딩될 때만 실행되도록 해준다.

  <br />

  - 로딩 state 다루기
    - state를 추가해서 로딩을 관리
    - useState를 추가하는데 초기 값은 false로 지정
    - 초기에 함수를 시작하는 부분에서 true로 업데이트
      - 이때는 로딩을 하고 있기 때문에 이렇게 true로 설정
    - 컴포넌트가 렌더링 될 때 로딩을 하고 true를 고려하지 않을 수 있는데, 대신 초기 상태를 true로 설정할 수 있다.
      - 컴포넌트가 렌더링될 때 항상 컴포넌트 안에서 로딩 데이터로 시작하기 때문에 초기 값을 true로 설정하는 것도 괜찮다.
    - 컴포넌트가 처음으로 생성되었다고 해서 반드시 로딩을 하는건 아닌데, 이때는 로딩 관련 설정을 하지 않을 수도 있다.
    - 작업을 마친 후 false로 설정
      - 로딩이 마무리되었기 때문에 false로 설정
    - 로딩 업데이트를 통해 렌더링 한 것을 제어할 수 있는데, 이 경우 식사 데이터를 전혀 렌더링 하지 않는다고 할 수 있다.
      - 로딩을 하는 경우 전체 섹션은 전혀 렌더링 해서는 안된다.
    - 식사 데이터를 매핑하기 전에 if문을 통해서 true인지 확인한다.
      - true인 경우에 함수 컴포넌트에 로딩 중이라는 내용을 반환
      - 그리고 아래에 있는 코드에 도달하지 못하도록 해준다.
    - 추가한 텍스트에 대해 css 추가
      - 간단하게 구성
    - 로딩 상태를 아주 잠깐 동안 확인할 수 있는데, Firebase가 빠른 백엔드를 갖고 있기 때문이다.

  <br />

  - 오류 처리
    - 에러가 발생했는지 여부를 결정하는 새로운 state를 추가
    - 초기 값은 false 또는 null 또는 정의되지 않았을 수도 있다.
      - true나 false 값이 아닌, 추후 오류 메시지를 표시하는데 처음에는 값을 갖지 않도록 구성
      - 초기 값을 비어있는 상태로 구성해도 괜찮지만, null로 설정해서 처음에 값을 갖지 않는다는 목적을 분명히 할 수도 있다.
    - 데이터를 가져오는데 실패 여부를 확인하기 위해 if문을 통해 response.ok를 확인
      - `if(!response.ok){}`
      - 오류 응답을 살펴보고 일반적인 오류 메시지를 던진다.
        - 여기서 예시로 그냥 일반적인 오류 메시지로 진행하는 것
    - try-catch문을 추가해 함수 호출을 시도하는 것을 확인한다.
      - 함수 내부에 오류가 발생하면 catch 블록에서 더 이상 로딩하지 않기 때문에 로딩을 false로 만들어주고, 오류 설정을 해주는데 잡은 오류를 보여준다.
      - catch에서 error에 액세스하고, 얻게 되는 에러 메시지를 설정
        - 해당 객체는 default로 message 프로퍼티를 갖게 된다.
        - `error.message`
        - 오류를 생성하고 생성자에 문자열을 입력하면 생성된 오류 객체의 메시지 프로퍼티에 해당 문자열이 저장된다.
    - 오류 상태를 설정해야 하는데 로딩 여부를 확인한 후에 에러의 true 여부를 확인
      - 앞에서 로딩 if문과 유사하게 구성
      - 단지, 차이는 들어가는 내용의 차이 및 css 차이
    - try-catch를 사용하고 있지만, 해당 함수는 async 함수이기 때문에 항상 promise를 반환하므로, promise 대신 오류를 가져오는 경우 그 오류로 인해 해당 promise가 거부하게 된다.
      - 따라서 try-catch를 사용해서 래핑할 수 없다.
      - 다른 방법으로 try-catch를 별도의 함수에 입력하는 것
    - promise로 catch 메소드에 추가
      - promise를 반환하므로 then()을 추가해서 진행
      - promise가 성공적으로 이행한다면 then()을 추가해서 성공할 수 있는데, 그리고 catch를 추가하여 오류를 다룰 수 있고, 그 오류는 promise 내부에서 발생한다.
      - try-catch 대신, 내가 얻는 오류에 대해 catch를 적용할 수 있다.
      - 로딩, 에러에 관한 코드를 catch 블록으로 옮긴다.
      - 이 방법이 promise 내부의 오류를 다룰 수 있는 promise만이 가능한 기존 방법이다.
    - 자세한 코드는 [깃 허브](https://github.com/jeongsangtae/react-complete-training-third-practice-project-solution/commit/3023bf41f4c432aa2d831639c7fba9964647b296)에서 확인 가능

<br />

# 오늘 느낀 점

- Http를 통해 식사 데이터를 가져오는 부분은 상수명만 다르고 기본적으로 같은 방식으로 구성이 되었고, 로딩과 오류 처리에서 조금 다른 부분이 있었다. 로딩에서는 나는 초기 값을 false로 주고 처음에 함수가 시작될 때 true로 바뀌면서 로딩이 뜨도록 해주었는데, 솔루션에서는 초기 값부터 true로 해주면서 로딩이 뜨도록 구성을 해주었다. 그리고 그 뒤에 if문에서 나는 return을 통해 멈추지 않았는데, 솔루션에서는 로딩이 발생중일 때는 그 뒤의 코드가 발생하지 않도록 return을 추가해서 구성을 해주었다. 솔루션의 방식을 보고난 후에 내 방식은 조금 잘못되었다는 것을 알고 수정해주었다. 그리고 오류 처리에서 내가 완전히 잘못 구성했다는 것을 알았는데 기본적인 state를 추가하고, if문을 통해서 확인하는 것도 동일하지만 그 이후에 try-catch를 사용하는 부분에서 나는 async/await를 고려하지 않고 코드를 구성했고, 솔루션은 async/await를 고려해서 catch 메소드를 사용해서 구성해주었다. try-catch 대신에 catch 메소드를 추가해 promise 내부의 오류를 다루도록 구성했다. catch 메소드를 추가한 부분에 대한 설명이 조금 어렵다고 느껴서 이 부분에 대해서는 좀 더 내용을 찾아봐야 할 것 같은데 내일 솔루션을 진행하기 전에 내용을 좀 찾아보고 갈 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
