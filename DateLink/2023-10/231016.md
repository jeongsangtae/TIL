# 오늘 한 일

### React 공부

- 고급 Redux

  - Redux 및 비동기 코드
    - redux를 부수 효과와 비동기식 코드로 연결하는 방법
    - 백엔드 서버를 추가해 백엔드 서버에 요청을 보낸 업데이트된 장바구니를 백엔드에 저장하여 이것을 다시 로드할 때 프론트엔드 애플리케이션에서 서버에 저장된 장바구니를 가져와서 로드하고 표시할 수 있도록 구성
      - Firebase를 백엔드 서버로 사용
      - Firebase는 사용하기 쉽고, 백엔드 코드가 필요하지 않아 개발자로서의 삶을 조금 더 쉽게 만들어준다.
      - 물론 Node.js 개발자라면 자신만의 백엔드 API를 구축하여 요청을 보낼 수도 있다.
    - 백엔드로 보내야 하는 여러 종류의 요청
      - 장바구니가 바뀔 때마다 백엔드에서 업데이트
        - 장바구니에 품목을 추가하거나 제거할 때마다 백엔드를 업데이트
      - 응용 프로그램을 다시 로드했을 때는 백엔드에서 저장된 데이터를 가져오도록 해야 함
      - 현재는 장바구니에 무언가를 추가하고 장바구니를 편집하면 다시 로드할 때 해당 데이터가 모두 손실된다.
      - 장바구니의 데이터를 어디에도 보관하지 않기 때문인데, 그것이 바로 Firebase 백엔드에 저장하여 해결하고 싶은 문제점이다.
    - 백엔드와 백엔드로 보내야 하는 HTTP 요청을 Redux를 사용하는 반응 애플리케이션에 통합하려면 어떻게 해야 하는가?
      - reducer는 순수 함수여야 하고, 부수 효과도 없고 동기식이어야 한다.
      - 부작용을 생성하거나 HTTP 요청을 보내는 것과 같이 비동기식 코드가 있는 경우에는 이러한 코드가 reducer 함수에 들어가서는 안된다.
      - cartSlice를 예로 들면, cartSlice의 reducer 내부에 HTTP 요청을 보낼 수 없다.
        - reducer의 끝으로 이동한 다음 fetch API를 사용하여 백엔드로 요청을 보낼 수가 없다.
        - 이 것은 Redux의 개념에 완전히 반대되는 것이다.
        - 이렇게 구성되는 것은 정말 일어나서는 안되는 일이다.
      - 절대 reducer 내부에서 부수 효과를 수행해서는 안된다.
      - 동기식이든 비동기식이든 절대 reducer 내부에서 수행하면 안된다.
      - 일반적인 경우에도 reducer에서 비동기 코드를 실행하면 안된다.
      - 즉, state 업데이트를 완료한 후 여기에 HTTP 요청을 보낼 수 있다.
        - 이렇게 HTTP 요청 코드를 넣는데 두 가지 주요 옵션이 있다.
        - 컴포넌트에서 실행할 수 있음으로, 이렇게 부르고 싶다면 redux를 무시하면 된다.
        - 아니면, 지금까지 간접적으로만 사용한 작업 생성자를 생성하여 비동기 코드 또는 일반적으로는 모든 부수 효과 코드를 실행할 수도 있다.

  <br />

  - 프론트엔드 코드와 백엔드 코드
    - 컴포넌트 내부의 부수 효과인 비동기 코드를 실행
      - ProductItem 컴포넌트 내부에서 Cart에 항목을 추가하는 것으로 시작
      - ProductItem 컴포넌트의 장바구니에 추가 핸들러가 있는데 이 내용을 redux store에 작업을 전달할 수 있을 뿐만 아니라, 해당 데이터를 Firebase에 백엔드로 보낼 수도 있다.
        - 한 가지 문제가 있는데, 만약 item 데이터를 Firebase로 보내면 Firebase에 해당 Product 데이터를 저장하기만 하면 된다.
        - 하지만 Firebase 방식의 백엔드에는 자체 로직이 없다. 따라서 Firebase 백엔드에서는 추가 코드를 실행하지 않고 일부 product 데이터를 거기에 보내면 해당 product 데이터가 단순히 DB에 추가된다.
        - 하지만 reducer 내에서 제품이 이미 장바구니의 일부인지 여부를 확인하기 위한 모든 논리가 들어있고 수량을 업데이트하거나 추가하지 않는 경우 이러한 종류의 로직은 Firebase에서 실행되지 않는다.
        - 여기서 사용하는 백엔드인 Firebase는 그런 논리가 없다.
      - 만약 실제 프로젝트에서 Firebase를 사용하려 한다면 서버 측 코드를 추가할 수 있다.
        - 들어오는 요청에 대해 트리거 될 수 있고, 백엔드에서 데이터를 변환할 수 있는 Firebase 백엔드에 고유한 코드를 추가할 수 있는 functions 라는 서비스가 있기 때문에 통합이 가능하다.
        - Node.js나 PHP로 빌드된 자체 백엔드를 사용하거나 자체 백엔드 API를 빌드하는 경우라면 DB에 저장하는 대신 무엇이든 간에 들어오는 데이터로 더 많은 작업을 수행하는 해당 백엔드 API에 코드를 추가할 수도 있다.
        - 하지만 이것은 백엔드 API 개발 및 백엔드 프로그래밍 언어에 대한 코스가 아니기 때문에 여기서 시도할 만한 방법은 아니다.
        - 가능은 하지만 Node.js 또는 PHP와 같은 백엔드 프로그래밍 언어에 대한 지식이 필요하다.
      - 프론트엔드에 작성해야 하는 코드와 데드 코드를 작성하는 위치는 백엔드 코드에 따라 달라진다는 점을 인식하는 것이 중요하다.
        - 물론 백엔드 API가 있기 때문에 백엔드 서버는 이러한 HTTP 요청과 우리가 보내는 응답을 통해 프론트엔드 애플리케이션과 통신한다.
        - 많은 작업을 수행하는 백엔드 API가 들어오는 데이터를 저장할 뿐만 아니라, 변환할 수도 있다.
        - 이와 같은 API가 있다면 프론트엔드 애플리케이션이 더 적은 작업을 수행할 수 있다.
          - 예로, 장바구니에 추가해야 하는 제품에 대한 데이터와 같은 데이터를 보낼 수도 있다.
          - 해당 데이터를 백엔드로 보낼 수도 있고, 백엔드가 변환을 수행하도록 한다. 그런 다음 프론트엔드에서 응답을 사용하여, 해당 응답을 저장하기 위해 reducer에 전달하기도 한다.
          - reducer를 줄이고 기본적으로 백엔드에서 들어오고 거기에서 변환된 들어오는 데이터를 취할 수 있다.
        - 많은 작업을 수행하지 않는 백엔드가 있는데, 이게 내가 사용할 Firebase 백엔드
          - 기본적으로 수신 데이터를 수신하는 형식으로 저장한다.
          - 즉, 프론트엔드에서 더 많은 작업을 수행해야 한다는 것을 의미하기도 한다.
          - redux store에 데이터를 저장할 뿐만 아니라 해당 데이터도 준비해야 한다. 그 데이터를 변환해야 한다.
            - 예로, 장바구니에 항목 추가 및 장바구니에서 항목 제거에서 수행하고 있는 것이 바로 그 작업이다.
            - 단순히 완성된 장바구니를 작업의 payload로 가져오는 것이 아니라 product를 가져오고 이 코드를 장바구니에 추가하는 방법을 찾아야 한다.
            - 문제될 게 없다. 물론 백엔드가 없으면 100% 의미가 없다.
            - 하지만 백엔드가 있는 경우 백엔드와 백엔드가 수행하는 작업의 양에 따라 백엔드가 작업을 수행한다면 여기서 더 적은 작업을 수행할 수 있다는 것을 최소한 알 수는 있다.
            - 그러나 여기서는 그렇지 않기 때문에 프론트엔드에서의 작업을 수행하는 동시에 reducer 내부에서 전송하지 않고 변환된 데이터를 백엔드로 보내는 방법을 찾아야 한다.
        - 이제 백엔드가 해당 작업을 수행하지 않는 경우 업데이트된 장바구니를 백엔드로 보내기 위한 코드를 어디에 넣는게 가장 좋을지를 결정해야 한다.

  <br />

  - 우리의 논리를 어디에 둘 것인가
    - ProductItem 컴포넌트의 addToCartHandler에서 작업
      - react redux의 useSelector를 사용하여 업데이트되기 전의 현재 장바구니를 가져올 수 있다.
        - `const cart = useSelector((state) => state.cart);`
      - 그런 다음 reducer에서 수행하는 모든 변환 state를 변경하지 않고, product 항목에서 끝낸다. 이게 중요한 포인트
      - product 항목에서 끝내고 난 후에 요청을 보낸다.
      - slice의 reducer 함수 내부에 변경 코드를 작성할 수 있는데, redux toolkit에는 state를 변경하지 않도록 코드를 변경하기 위한 내부 변환이 있기 때문이다.
        - 이 것은 해당 reducer 메소드 내부에서만 가능하다.
        - product item의 경우, 즉 일반 컴포넌트의 경우는 해당하지 않는다.
        - 예로 장바구니 총 수량을 장바구니 총 수량에 1을 더한 값으로 설정하면 redux에 알리지 않고 redux store의 모든 부분인 메모리에서 JS 객체를 변경하게 된다.
        - reducer 함수 외부에서 이를 변경할 수 있기 때문에 이건 꼭 피해야 할 끔찍한 상황이다.
        - redux state를 변경해서는 안되며 특히 redux 외부에서 수행하면 절대 안된다.
      - redux store에서 아직 수량을 변경하지 않고, 업데이트된 수량을 가진 새 상수를 만든 다음, 항목을 업데이트하기 위해 비슷한 작업을 수행한다.
        - `const newTotalQuantity = cart.totalQuantity + 1;`
      - 기존 객체가 포함된 새로운 배열을 생성하지만 새로운 배열을 생성하는 slice 메소드를 사용하여 장바구니의 항목을 복사한 업데이트된 항목 상수를 생성한다.
        - `const updatedItems = cart.items.slice();`
      - 복사한 항목에서 기존 항목을 식별하여 확보한다.
        - `const existingItem = updatedItems.find((item) => item.id === id);`
        - 해당 항목은 객체가 JS의 참조 값이기 때문에 redux store의 일부인 메모리의 객체로 봐야 한다.
      - 해당 객체도 새 객체에 복사
        - `const updatedItem = { ...existingItem };`
      - 업데이트된 항목은 메모리에 있는 완전히 새로운 객체이므로 redux store를 조작하지 않고도 해당 객체의 프로퍼티를 업데이트할 수 있다.
      - 항목의 index를 찾고 장바구니에 있는 현재 항목을 업데이트된 항목으로 바꾼다.
      - 이전에 장바구니의 일부로 항목을 가지고 있지 않은 경우 업데이트된 항목 배열에 새로운 객체를 push한다.
        ```
        if (existingItem) {
          const updatedItem = { ...existingItem }; // new object + copy existing properties to avoid state mutation
          updatedItem.quantity++;
          updatedItem.totalPrice = updatedItem.totalPrice + price;
          const existingItemIndex = updatedItems.findIndex(
            (item) => item.id === id
          );
          updatedItems[existingItemIndex] = updatedItem;
        } else {
          updatedItems.push({
            id: id,
            price: price,
            quantity: 1,
            totalPrice: price,
            name: title,
          });
        }
        ```
      - 그 다음 새 객체를 만들어 새 장바구니에 총 수량을 새로운 총 수량으로 표시하도록 구성
        - 항목이 업데이트된 항목과 같다고 설정해뒀기 때문에 가능
        ```
        const newCart = {
          totalQuantity: newTotalQuantity,
          items: updatedItems,
        };
        ```
      - dispatch 하는데, store에 새로운 reducer를 추가했기 때문에 장바구니 reducer를 교체해야 한다.
        - 화면 밖에서 추가하고 payload에서 새로운 총 수량과 새 항목을 가져온 다음 redux store에서 오버 라이드한다.
        - 따라서 발송하는 payload는 총 수량과 항목 키가 있는 객체이다.
    - 현재 이 접근 방식의 문제점은 무엇일까?
      - 문제는 애플리케이션의 모든 부분에서 이 내용을 사용한다면 장바구니를 업데이트해야 한다는 것이다.
      - 더 정확히는 장바구니 항목 대신 사용하려는 경우 ProductItem 컴포넌트에 추가한 모든 논리를 장바구니 항목 컴포넌트에도 복사해야 한다. 또는 함수를 내보내는 추가 파일로 아웃소싱할 수도 있다.
        - 따라서 중복을 코딩할 필요는 없지만, 여전히 또 다른 문제가 있다.
      - 일부 도우미 함수에서 데이터 변환을 수행하고 결국에는 컴포넌트에는 직접 데이터를 변환하게 되는데, 그렇기 때문에 reducer에서 변환을 수행하지 않는다.
      - 애플리케이션의 모든 위치에서 장바구니 교체 접근 방식을 사용하면 장바구니에 항목 추가를 제거할 수 있다.
        - redux reducer가 많은 일을 하지 않을 것이라는 것을 의미하기도 한다.
        - 약간의 데이터만 얻고 저장하게 된다.
        - 이 것도 나쁘지는 않다. 이게 취향이라면 반드시 나쁘다고 볼 수는 없다.
        - 그러나, 이 방법은 redux를 사용하는 주요 이유라고 볼 수 없다.
    - 코드를 어디에 둘 것인지에 관해서는 종종 fat reducer, fat 컴포넌트, fat 작업 중에서 선택해야 하기 때문이다.
      - 따라서 로직, 즉 코드를 어디에 둘 것인지 고려할 때는 동기식이면서 부수 효과가 없는 코드와 부수 효과가 있는 코드 또는 비동기식 코드를 구별해야 한다.
      - 현재 product 항목에서 제공한 것은 부수 효과가 없고 의도적으로 해당 HTTP 요청을 보내지는 않았다.
      - 앞에서 추가한 코드는 모두 데이터를 변환한다고 보면 된다. 비동기 코드이며 부수 효과가 없다.
      - 이제 동기식이며 부수 효과가 없는 코드를 다루는 경우를 살펴보면 기본적으로 약간의 데이터 변환만 있는 경우라면 slice의 왼쪽에 있는 경우라고 할 수 있다.
    - 보통 reducer를 선호하게 될 것이다. 반면 만약에 컴포넌트에 코드를 포함하는 것을 좋아한다면, 일반적으로는 이를 위해 reducer 및 광범위한 작업 크리에이터 또는 컴포넌트를 선호하는 것을 좀 더 나은 선택으로 간주한다.
    - 비동기 코드나 부수 효과가 있는 코드의 경우에는 다르다.
      - 거기에서 작업 크리에이터 또는 컴포넌트를 선택해야 하고, 절대 reducer를 사용해서는 안된다.
      - 다시 말해 지금 코드는 문제가 있다는 것이다.
      - reducer 내부가 아니라 컴포넌트에서 데이터 변환을 수행하기 때문에 장바구니 교체에 의존하는 경우에 최적의 코드가 아닌 것이 있다는 것이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-advanced-redux/commit/4d2c5b8754a1e66ddc5fd3a9ddc2c50ff5ed5bf7)

  <br />

  - Redux와 함께 useEffect 사용하기
    - 앞에서 구현했고, 장바구니 교체 접근 방식 대신, 즉 그 방법 대신에 이전에 구성한 접근 방식으로 진행
    - addItemToCart 작업을 dispatch 하고, reducer 함수 내에서 이 모든 무거운 작업을 수행
    - 새 state를 서버에 동기화하려는 경우, 프론트엔드에서 파생된 새 state로 서버를 업데이트하려면 간단한 순서만 전환하면 된다.
      - 먼저, 프론트 엔드에서 작업을 수행하고 redux가 store를 업데이트하도록 하면 된다.
      - 그 다음 두 번째 단계에서 서버에 요청을 보내지만 여기에서 허용되지 않는 reducer 함수 내부에서는 그렇게 할 필요가 없다.
      - 대신, 예를 들어 ProductItem 컴포넌트나, 완전히 다른 파일에서 수행할 수 있다.
      - 우선 App.js를 루트 컴포넌트로 가정한다면, 여기에서 기본적으로 useSelector를 사용하고 장바구니 state의 변경 사항을 수신해 전체 장바구니를 파악할 수 있다.
      - 장바구니 state가 변경될 때마다 HTTP 요청을 보낼 수 있다.
    - App.js에서 작업
      - 전체 장바구니를 확보하기 위해 이미 가져오고 있는 useSelector를 사용하고 해당 내용을 상수에 저장한다.
        - `const cart = useSelector((state) => state.cart);`
      - 이제 React에서 가져온 useEffect를 사용하여 장바구니 state의 변경 사항을 관찰할 수 있다.
        - useEffect 사용하여 부수 효과를 실행할 수 있다.
        - 이제 종속성이 변경될 때마다 효과를 실행할 수 있게 된다.
      - App.js에서 useEffect를 import해서 호출
        - 모든 컴포넌트에서 useEffect 작업을 수행할 수 있게 된다.
        - 현재 코드에서는 루트 컴포넌트를 선택하고 있지만, 반드시 그래야 하는 것은 아니다.
      - useEffect 구성
        - effect 함수와 의존성 배열을 정의
        - effect 함수 내부에서 Fetch API를 사용하여 HTTP 요청을 Firebase로 보낸다.
        - Firebse에서 해당 URL을 가져와 추가하고, `cart.json` 노드를 대상으로 지정해준다.
          - `fetch("https://react-redux-138aa-default-rtdb.asia-southeast1.firebasedatabase.app/cart.json")`
          - json은 Firebase 전용이라고 할 수 있다.
          - 이렇게 하면 DB에 새 장바구니 노드가 생성되고, 거기에 데이터가 저장된다.
        - ~~POST 요청 보내기~~ -> PUT 요청 보내기
          - Firebase에 새 데이터를 저장할 수 있다.
          - 더 정확히는 PUT 요청을 보내고 싶다고 봐야한다.
          - PUT 요청은 POST 요청과 마찬가지로 Firebase가 있어야 가능한 작업이다.
          - PUT 요청을 보내면 Firebase에도 데이터를 저장한다.
          - 하지만 PUT과 POST가 하는 것의 차이를 살펴보자면 새 데이터가 데이터 목록에 추가되지 않고, 기존의 데이터를 오버라이드 한다는 점이다.
          - 따라서 PUT 요청을 보낼 때 장바구니를 수신 데이터로 오버라이드한다.
          - `method: "PUT"`
        - 요청 본문 설정
          - JSON.stringify로 설정
          - 여기서는 장바구니를 내보낼 수도 있다.
          - redux에서 가져온 이 장바구니를 JSON 데이터로 변환하여 요청의 일부로 보낸다.
          - `body: JSON.stringify(cart)`
        - 의존성 배열 설정
          - body에서 장바구니를 사용하고 있으므로, 장바구니가 변경될 때마다 이 effect 함수가 실행되도록 useEffect에 대한 종속성으로 추가해야 한다.
          - `[cart]`
        ```
        useEffect(() => {
          fetch(
            "https://react-redux-138aa-default-rtdb.asia-southeast1.firebasedatabase.app/cart.json",
            { method: "PUT", body: JSON.stringify(cart) }
          );
        }, [cart]);
        ```
      - 여기서 좋은 점은 useSelector가 redux에 대해 구독을 설정한다는 점이다.
        - 즉 redux store가 변경될 때마다 이 컴포넌트 함수(App 컴포넌트)가 다시 실행되고, 최신 상태가 된다.
        - 이 경우에는 최신 버전의 cart가 된다.
        - 다시 말하면 effect도 다시 평가되고 cart가 변경되면 다시 실행된다.
    - 간단한 추가를 통해 cart가 변경될 때마다 HTTP 요청을 보내고 순서를 바꿨기 때문에 reducer 내부에 장바구니를 업데이트하는 논리를 유지할 수 있다.
    - 우선 redux store를 업데이트하면 되는데, 이미 그 업데이트 작업은 해놓았다. 그 다음 업데이트된 저장소를 선택해 요청을 보내면 린 컴포넌트가 모든 논리를 사용하여 fat reducer를 만든 다음 redux state에 따라 달라지는 부수 효과를 수행할 수 있게 된다.
    - 이 방법은 정말 좋은 방법으로, 컴포넌트에 부수 효과 논리를 넣을 수 있는 아주 좋은 방법이다.
    - redux로 작업할 때 일반적으로 사람들이 원하는 위치인 reducer 내부에 모든 데이터 변환 논리를 유지하기에 좋은 방법이라고 할 수 있다.
    - useEffect 문제
      - 현재 사용하는 방식으로 useEffect를 사용할 때 한 가지 문제에 직면한다.
      - 앱이 시작될 때 그 것이 실행된다는 것이다.
      - 이게 왜 문제가 될까 ?
        - 이 것은 초기(즉, 비어 있는) cart를 백엔드로 보내고 거기에 저장된 모든 데이터를 덮어쓰기 때문에 문제이다.
        - 이 내용은 다음 강의에서 고칠 예정이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-advanced-redux/commit/4190a2e8ecb7f9f29c6f38f90040cbe7595a7134)

<br />

# 오늘 느낀 점

- 솔직하게 오늘 배운 내용은 좀 많이 어렵다고 생각이 된다. 내용도 어려웠지만, 번역이 정말 짜증 날 정도로 이상하다고 느꼈기 때문인데, 아무래도 외국 강의를 번역된 내용과 함께 듣다보니까 이렇게 번역될 내용이 아니라고 생각된 부분도 있었고, 컴포넌트 내용을 번역하는데 컴포넌트 이름까지 다 번역해서 혼동을 줄 때도 있었는데, 어느정도 감수하고 듣는데도 좀 어려움이 있었던 거 같다. 어려웠던 내용에 대해 얘기하자면, 다른 내용보다 논리를 어디에 두는 가에 대한 내용에서 좀 어렵다고 느낀 거 같다. 다른 내용은 이해가 어느정도 된다고 느꼈는데, ProductItem 컴포넌트의 addToCartHandler에서 작업해놓은 내용을 봤을 땐 좀 이해가 제대로 안갔던거 같다. 이 후에 그 코드를 삭제하고 useEffect를 사용하는 방법으로 코드를 수정했는데, 분명 이 방법은 앞의 방법보다 훨씬 쉬운 방법임에도 뭔가 잘 이해가 안되었는데, 앞에서 본 방법이 잘 이해가 되지 않아서 useEffect의 방법도 잘 이해가 되지 않은 거 같아서 다시 한 번 보고 이해를 해봐야 할 것 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
