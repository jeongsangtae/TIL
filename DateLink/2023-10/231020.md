# 오늘 한 일

### React 공부

- React Router가 있는 SPA 다중 페이지 구축하기

  - 레이아웃 및 중첩된 라우트
    - 네비게이션 바를 추가할 수 있는데, 이 네비게이션 바 컴포넌트를 페이지마다 각각 추가할 수도 있다.
      - 하지만 추가하려는 페이지가 많아지면 그 단계를 반복해야 한다.
      - 각 페이지마다 추가할 수는 있지만, 약간 번거로울 것이다.
    - 각 페이지마다 추가하는 것 대신에 모든 라우트를 감싸는 레이아웃을 추가하고 래핑 레이아웃 컴포넌트 안의 라우트 컴포넌트들을 간단히 로딩할 수 있다.
      - 예로, RouterProvider 컴포넌트 위에 네비게이션을 렌더링하거나 RouterProvider 컴포넌트를 다른 컴포넌트로 감쌀 수 있다.
      - 히자만 레이아웃에 링크를 추가하려 한다면 잘 안될 것이다.
        - 링크들은 RouterProvider 안에서 렌더링될 경우에만 작동하기 때문이다.
        - 즉 그 위나 옆에 있거나 래퍼일 때는 되지 않는다.
    - react-router-dom을 이용해서 문제에 접근할 수 있다.
      - 라우트 정의에 라우트를 추가하고 "/"이라는 경로를 사용한 다음에 여기에다가 실제로 레이아웃 래퍼를 로딩하는 element를 추가하는 방법을 사용, 그게 다른 라우트들을 감싸야 한다.
    - 레이아웃 래핑
      - 첫 단계
        - pages에 Root.js 파일 추가
        - App.js에서 라우트 요소에 Root 컴포넌트 추가
        - 다른 두 라우트와 컴포넌트들을 레이아웃으로 감싸기 위해 특수한 라우트에 또 다른 프로퍼티를 추가, 바로 children 프로퍼티
        - children 프로퍼티
          - 배열을 받고, 추가 라우트 정의로 된 어레이이다.
          - 다른 두 라우트 정의를 해당 배열로 옮길 수 있다.
          - 옮기면 두 라우트 정의를 라우트의 자녀 라우트 정의로 만들게 된다.
          - Root 컴포넌트가 포함된 라우트는 두 라우트의 부모 라우트 역할을 하게 된다.
            - 두 라우트들의 래퍼 역할을 하게 된다.
          - 부모 라우트 요소에서, 즉 Root 컴포넌트에서 자녀 라우트 컴포넌트와 요소가 어디 있는지도 정의해야 한다.
            - 정의해야 Home, Products가 렌더링되게 된다.
          ```
          {
            path: "/",
            element: <Root />,
            children: [
              { path: "/", element: <Home /> },
              { path: "/products", element: <Products /> },
            ],
          },
          ```
        - Root 컴포넌트에서 또 다른 특별한 특수 컴포넌트를 react-router-dom으로부터 import한다.
          - 바로 Outlet 컴포넌트
        - Outlet 컴포넌트
          - Outlet 컴포넌트는 자녀 라우트 요소들이 렌더링되어야 할 장소를 표기하는 역할을 한다.
          - 프래그먼트를 추가하고, h1 태그를 넣고 대충 문자를 넣은 후에 프래그먼트 안에 Outlet 컴포넌트를 넣으면 된다.
          - Outlet 컴포넌트는 자녀 라우트를 렌더링해야 할 장소를 표시하는 마커가 된다.
          - 그 장소는 결국 Home과 Products가 된다.
          ```
          const Root = () => {
            return (
              <>
                <h1>Layout</h1>
                <Outlet />
              </>
            );
          };
          ```
        - 이렇게 구성하고 웹 페이지를 확인해보면 "Layout" 문자가 보이는 것을 확인할 수 있다.
        - 이 방법의 장점은 Root 컴포넌트가 페이지 컴포넌트들의 래퍼 역할을 한다는 점이다.
        - 이제 더미 텍스트 대신에 앞에서 구성한 네비게이션 바 컴포넌트를 Outlet 컴포넌트 위에 렌더링하면 된다.
    - 레이아웃 역할을 하는 루트 라우트를 만드는건 React route를 사용할 때 아주 표준적이고 정상적인 것이다.
      - 더 복잡한 페이지의 경우에 다수의 루트 라우트를 만들 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/347e2a6e6811ce2c93a705aedd7b5e961194e1f9)

  <br />

  - errorElement로 오류 페이지 표시하기
    - 잘못된 URL로 들어간 오류 페이지 구성
      - 기본적으로 react-router-dom 패키지가 제공하지만, 나만의 오류 페이지를 구성
    - pages 폴더에 Error.js라는 파일을 추가
    - 뭔가가 잘못되었을 때 메시지를 보여주는 페이지를 어떻게 해야 보여줄 수 있을까?
      - react-router-dom 패키지가 알려주고 있다.
        - You can provide a way better UX than this when your app throws errors by providing your own `ErrorBoundary` or `errorElement` prop on your route.
        - errorElement 프로퍼티를 라우트 정의에 추가해서 만일 오류가 생성되면 어떤 페이지를 로딩해야 할 지 정의할 수 있다.
    - 라우트 정의한 App.js에서 구성 진행
      - errorElement 프로퍼티를 추가해서 해당 페이지가 오류를 냈을 때 로딩해야 할 요소를 정의할 수 있다.
        - 현재는 페이지가 실제로 오류를 throw할 수 없다.
        - 섹션의 후반부에서 페이지가 오류를 throw할 수 있는 상황에 대해 알아볼 예정이다.
        - 하지만 루트 경로는 오류를 throw할 수 있다.
      - 루트 라우트에 오류를 throw
        - 실제로 존재하지 않는 URL을 입력하면 react-router-dom 패키지가 오류를 낼 것이고, 그 오류는 루트 라우트 정의에 자동으로 나타나게 된다.
          - "/" 뒤에 아무것도 없는 라우트로 가게 된다.
        - 특수한 "/" 라우트에도 errorElement 프로퍼티를 추가할 수 있고, 만일 오류가 발생하면 루트 라우트에 대해 폴백 페이지로서 Error 컴포넌트를 렌더링하려 한다고 할 수 있다.
    - errorElement를 사용하면 react-router-dom 패키지가 생성한 기본 오류 메시지를 표시하는 것보다 UX가 더 우수하다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/0886a566eba718a240bbfc5de6fd9094cdec2e81)

  <br />

  - 네비게이션 링크 사용하기 (NavLink)
    - CSS에서 `.list a` 이와 같이 되어있는데 정작 JS 파일에서는 a 태그가 없는데, 여기서 신기한게 Link 컴포넌트는 내부적으로 a 태그를 렌더링하기 때문에 적용이 된다.
      - 즉 `.list a`는 react router의 Link 컴포넌트 내부의 a 태그에 적용된다.
    - 링크가 현재 활성화된 페이지로 인도했는지 아닌지, 링크에 표시되도록 지원하기 위해 react-router-dom은 Link 컴포넌트의 대용물을 제공한다.
      - 바로 NavLink 컴포넌트
    - NavLink 컴포넌트
      - NavLink는 Link와 똑같이 사용하고, Link 대신에 사용할 수 있다.
      - NavLink에는 특수한 동작이 하나 있다.
        - NavLink에 className 프로퍼티를 추가하면 실제로 그건 문자열을 받는 일반적인 className 프로퍼티가 아니라, 대신에 함수를 받는 프로퍼티가 된다.
        - 그 함수는 a 태그에 추가되어야 하는 CSS 클래스 이름을 return 한다.
        - 함수는 자동적으로 객체를 받고, 거기에 isActive 프로퍼티를 할당할 수 있다.
          - isActive 프로퍼티가 있는 객체는 react-router-dom이 제공한다. 그리고 isActive는 불리언이다.
          - 현재 활성화인 라우트로 인도되었으면 참이되고, 현재 활성화되지 않은 라우트로 인도되지 않았으면 거짓이 된다.
          - 링크가 활성화 되어있으면 조건부로 CSS 클래스 a를 return할 수 있고, 아니면 b를 return할 수 있다.
          - 링크가 활성화 되어있으면 import한 CSS 클래스로부터 클래스를 추가할 수 있다. 그렇지않으면 undefined를 return할 수 있다.
        - 함수를 받는 동일한 className 프로퍼티를 추가하고, 그게 react-router-dom에 의해 자동으로 함수에 전달된 객체의 isActive 프로퍼티를 받는다.
      - 테스트해보면 여전히 Home, Products 둘 다 활성화 되어있는걸 확인할 수 있는데, 그 이유는 기본적으로 NavLink는 실제로 현재 활성인 라우트의 경로가 NavLink의 경로로 시작하는지 확인하기 때문이다.
        - NavLink는 현재 활성인 라우트가 링크로 설정된 경로로 시작하면 활성인 것으로 간주한다.
        - 중첩된 자녀 라우트에 있을 경우에도 링크를 활성으로 취급할 수 있게 하기 위해서 그런 동작이 존재한다.
        - 좋은 기능이지만 "/" 라우트에 그걸 원하지 않는다. 모든 라우트는 결국 "/"로 시작하기 때문이다. 그래서 모든 라우트에 대한 항상 활성이 될 것이다.
        - 그래서 react-router-dom은 또 다른 프로퍼티를 제공한다.
          - 바로 end 프로퍼티
      - end 프로퍼티
        - true나 false로 설정할 수 있다.
        - 그냥 넣으면 true로 설정된 것과 같다.
        - end 프로퍼티를 추가하면 현재 활성인 라우트의 URL 뒤가 이 경로로 끝나면 이 링크를 활성으로만 간주해야 한다는 것이다.
        - end 프로퍼티가 들어간 링크는 도메인 뒤에 아무것도 없는 경우에만 활성으로 간주된다.
        - 다른 링크에는 end를 추가할 필요가 없다.
          - "/"에만 추가하면 된다.
          - 이유는 /products로 시작되는 다른 라우트가 없기 때문이다.
      - 어떤 스타일을 적용할지는 전적으로 내 선택이다. 인라인 스타일을 선호할 경우에도 isActive를 사용할 수 있고, 동일한 기능을 얻을 수 있다.
        - `({ isActive }) => ({ textAlign: isActive ? "center" : "left" });`
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/9c82165539edf08cd1ae7195bc7427a801302dc5)

  <br />

  - 프로그램적으로 네비게이션하기
    - 강제 라우팅
      - 현재는 클릭할 수 있는 링크를 제공해서 사용자들이 페이지들 간에 이동할 수 있게 하고 있다.
        - 이 방법은 사용자들에게 이동을 제공하는 기본 방식이다.
        - 하지만 그게 유일한 방법은 아니다.
      - 가령 어떤 폼이 제출되었거나 타이머가 만료되었을 경우에 코드 안에서 네비게이션 동작을 트리거하고 싶을 때가 있다.
        - react-router-dom이 제공하는 또 다른 특수 기능을 이용해 제공할 수 있다.
        - 바로 useNavigate Hook
      - useNavigate Hook
        - useNavigate를 import하고 기능 컴포넌트에서 호출해서 useNavigate() 함수에 액세스 할 수 있다.
          - `const navigate = useNavigate()`
        - useNavigate() 함수를 호출해서 네비게이션 동작을 트리거할 수 있고, 프로그램적으로 내 코드 안에서 다른 라우트로 전환할 수 있다.
        - 예로, navigateHandler() 함수를 추가하고, ~~그걸 버튼에 연결할 수 있다.~~ 링크에 연결할 수 있다.
          - 사실 버튼을 생성하고 프로그램적으로 이동하지 말아야 한다.
          - 대신 간단한 링크만 사용해야 한다.
          - 버튼이 전반적으로 어떻게 작동하는지 보여주기 좋은 방법이라서 사용할 뿐이다.
          - 내가 이렇게 버튼을 이용해 연결할 필요는 없고 단순하게 보여주기 위해서 해보는 것
        - 추가한 navigateHandler 함수에 상수로 지정한 useNavigate()를 사용하고 경로를 이동할 수 있다.
          - `navigate("/products")`
      - 버튼 클릭을 이용했지만, 이건 프로그램적인 것이고 버튼 클릭으로 함수를 트리거했고 그 함수 안에 실제 코드 즉, 다른 페이지로 이동하기 위한 프로그램적인 강제적 네비게이션 코드가 있다.
        - 버튼을 사용하는 방법 대신에 링크를 써야 하지만 프로그램적으로 이동해야 할 경우에는 이처럼 함수를 사용해 강제로 이동해야 한다.
        - 예로, 어떤 타이머가 만료되었거나 하는 비슷한 상황이 있을 때 사용할 수 있다.
    - 내가 들은 내용을 토대로 생각한 내용을 정리해보면, 즉 평상시에는 사용할 일이 없고 링크를 통해서 이동하는 것이 좋다. 하지만 폼이 제출되거나, 타이머가 만료되는 것과 같은 상황에서 함수가 작동할 때 프로그램적으로 강제로 이동해야 할 때 이 기능이 필요하다는 걸 말하고 싶은 것 같다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/dfdb0db13ca7afa92d488c3e11fefb34a783e14c)

  <br />

  - 동적 라우트 정의하고 사용하기
    - 현재는 products 페이지는 단순한 더미 페이지이지만, 일반적인 products 페이지라고 하면 제품 리스트를 보여주는게 상당히 일반적일 것이다.
      - 이런 제품 리스트에서 다양한 제품에 대해 별도의 세부정보 페이지를 로딩하는게 일반적일 것이다.
      - 세부 정보 페이지를 보여주기 위해 별도의 페이지가 있어야 한다.
    - 다양한 제품들에 대해 세부 정보 페이지를 로딩
      - 새로운 라우트를 추가하고, 이어서 링크를 추가
      - 라우트의 path는 `/product-detail`일 수도 있지만, 일반적으로 다양한 제품들의 세부정보들은 모두 다르게 되어있다.
      - 언제나 동일한 컴포넌트를 로딩할 수 있지만 거기에 표시될 데이터는 다양한 제품들에 대해 다를 것이다.
      - 예로, `/products/p1`과 같은 경로를 지원하는게 합리적일 것이다.
        - 다양한 제품들에 대해 다른 경로를 넣을 수 있다.
        - 그리고 항상 동일한 페이지를 로딩하길 원한다.
          - 항상 `ProductDetail`을 로딩할 것이다.
      - 물론 경로가 조금씩 다른 다수의 경로를 추가할 수도 있다.
        - 이 방법은 현실적인 방법이 아니다.
        - 제품이 많아지면 더 많은 경로를 추가해야 하기 때문이다.
        - 일반적으로 제품이 몇 개인지 미리 알지도 못하는 경우가 많다.
        - 역동적으로 더 많은 제품을 추가하게 될 것이다.
        - 결국 대부분의 웹 사이트는 상당히 역동적이고 사용자와 관리자는 새 제품을 추가할 수 있길 원할 것이다.
        - 새 제품이 추가되었다고 항상 그걸 코드에 추가하길 원치는 않는다.
        - 경로 안에 다양한 제품 id를 하드 코딩하는 방식은 올바른 대안이 아니다.
      - react-router-dom은 역동적 경로 세그먼트 또는 다른 말로 경로 파라미터를 지원한다.
        - 콜론을 넣고 그 뒤에 id, productId 같은 원하는 식별자를 넣어서 경로에 파라미터를 즉 역동적 경로 세그먼트를 추가한다.
          - `path: "/products/:id"`
          - `path: "/products/:productId"`
          - 이건 내가 원하는대로 넣을 수 있다.
          - 하지만 콜론은 아주 중요하다.
        - 콜론은 경로의 `:productId` 이 부분이 역동적이라는걸 react-router-dom에게 알려주는 것이다.
          - 실제로 `/products/:productId`에 대해 이 요소를 로딩하려는게 아니라 `/product/` 뒤에 있는 `productId` 플레이스 홀더에 대한 실제 값으로 사용될 어떠한 값이라도 로딩하게 된다.
          - 필요하다면 그 뒤에는 하드 코딩된 세그먼트가 있을 수 있다.
          - `/products/:productId` 이렇게 작성했다면 이 세그먼트는 역동적이다.
        - 콜론을 사용한채로 확인해보면 모든 경로에 대한 동일한 컴포넌트가 로딩된다. `/products` 뒤의 부분이 역동적이기 때문이다.
          - 플레이스 홀더에 어떠한 값이라도 넣을 수 있다.
            - 다양한 제품에 대해 다양한 데이터를 로딩하려 한다면 플레이스 홀더가 더욱 중요해진다.
      - 예시로 ProductDetail 페이지에서 어떤 제품에 대한 페이지가 로딩되었는지 알고 싶다고 한다면 ?
        - 어떤 제품 id가 사용되었는지 알려고 한다면, 그 특정한 제품의 데이터를 가져오기 위해 백엔드 API와 DB로 가고 그걸 화면에 표시할 수 있다.
          - 이 것 또한 흔히 있는 시나리오
        - react-router-dom은 플레이스 홀더, 즉 :/productId 대신에, 사용된 실제 값을 잡기 위한 또 다른 툴을 제공하고 있다.
        - react-router-dom에서 제공하는 그 툴이 바로 useParams Hook 이다.
      - useParams Hook
        - useParams를 호출하면 이 훅은 params 객체를 주고, params 객체는 내가 라우트 정의에서 프로퍼티로 정의한 모든 역동적 경로 세그먼트가 담긴 간단한 JS 객체이다.
        - params 객체에 productId라는 프로퍼티를 사용
          - 내 라우트 정의에서 productId를 플레이스 홀더, 경로 파라미터, 역동적 경로 세그먼트에 대한 식별자로 선택했기 때문이다.
          - 콜론 뒤의 부분은 params 객체에 프로퍼티 이름으로 쓸 수 있는 식별자이다.
          - `params.productId`를 출력할 수 있다.
            - `<p>{params.productId}</p>`
          - 라우트 정의에서 콜론 뒤에 쓸 다른 식별자를 선택하면 어떻게 될까?
            - 예를 들어 그냥 id로 사용했다고 한다면 `params.productId` 이 내용을 `params.id`와 같이 바꿔서 해당 식별자를 사용해야 한다.
      - 위 내용으로 테스트해보면 URL에서 `/products/` 뒤에 입력한 내용이 페이지에 표시되는 것을 확인 할 수 있다.
      - 이와 같은 방식으로 URL에 인코딩된 데이터를 잡을 수 있다.
      - 일반적으로 품목이나 제품의 id 같은걸 URL에 인코딩한다.
        - 보통 백엔드로 가고 그 제품에 관한 데이터를 가져올 수 있기 때문이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/d091e218cba28ce46e5c65e302d64f42e222f4f5)

  <br />

  - 동적 라우트에 링크 추가하기
    - 제품 페이지에 실제 링크를 추가
      - Products.js에 Link 컴포넌트 import
      - NavLink가 아닌 Link 사용하는 이유는 클릭했을 때 그 링크가 하이라이트되는 걸 원치 않기 때문이다.
      - to 프로퍼티를 추가해 내용 구성
    - 백엔드로부터 데이터를 가져와서 구성
      - 현재는 더미 상수를 하드코딩해서 진행하고 있지만, 백엔드에서 오는 데이터가 될 수 있다.
      - 받는 데이터는 JS 객체들로 된 배열일 수 있고, 모든 객체에는 id와 예로 "Product 1"과 같은 title이 있을 수 있다.
    - 리스트 항목을 하드 코딩하는 대신에 제품들을 모두 매핑해서 역동적인 리스트 구성
      - map을 사용해 구성한다.
      - 리스트를 만들 때 항상 필요한 key prop 추가
      - 리스트 항목에서 링크를 출력
      - Link 텍스트 사이에 product.title을 출력
      - 링크를 역동적으로 구성
        - 2개의 프로퍼티에 대한 값이 된다.
        - 역동적 값을 추가하는데 백틱을 사용해 문자열을 역동적으로 구성한다.
          - JS 템플릿 리터럴을 사용해 구축
          - 이렇게 하면 역동적 값을 쉽게 역동적으로 문자열에 주입할 수 있다.
          - /products/로 시작하고 두 번째 / 뒤에 역동적 값을 문자열에 주입한다.
          - 역동적 값은 product.id가 될 수 있다.
      - 이렇게하면 경로가 다른 다양한 링크가 있는 다수의 리스트 항목을 생성할 수 있다.
      - 역동적 경로 파라미터가 있는 라우트에 대해 링크를 생성하고 구축할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-routing-basic/commit/742ddd61717154fa674e00e6a21c6c9795372ff4)

<br />

# 오늘 느낀 점

- 라우트 내용을 들으면서 느껴지는 생각은 되게 react-router-dom에서 좋은 기능을 가진 함수들이 많다고 생각이 되었다. 네비게이션 바를 컴포넌트 페이지마다 각각 추가하는 것이 아닌, 한 번에 라우트를 묶어서 네비게이션 바를 레이아웃으로 만들 수도 있고, 잘못된 URL 오류 페이지를 내 입맛대로 구성할 수도 있었다. 그리고 Link 대신에 NavLink를 사용하고 isActive 프로퍼티를 할당하고 받아서, 해당 페이지가 활성화되어 있는 상태인지 구분도 할 수 있게 해주는 부분이 정말 좋다고 생각이 되었다. 프로그램적으로 네비게이션하기 위해서 강제로 라우팅할 수도 있는데 이 기능은 나중에 React로 웹 페이지를 만들 때 폼이 제출될 때 사용하면 아주 유용할 거 같다고 생각이 되었다. 실제 웹 사이트에서 백엔드 데이터를 가져와서 페이지별로 다르게 보여져야 하는 경우가 있는데, 제품과 관련된 내용 또는 여행 페이지와 같이 해당 데이터는 페이지가 동적으로 보여지고, 라우트 또한 동적으로 이루어져야 하기 때문에 동적 라우트 설정은 정말 좋은 거 같다. 이 동적 라우트 정의는 사실 NodeJS 공부할 때 자주 사용했던 내용이라서 많이 익숙하게 느껴졌던 거 같다. 콜론을 사용하는 것과 템플릿 리터럴를 사용해서 구축하는 것은 NodeJS에서 동적으로 구성할 때 정말 많이 사용했던 내용이기 때문에 React 웹 사이트를 구축할 때 라우트를 사용한다면, 단지 어떻게 사용하고, 어디에 사용해야 하는지 그런 유무만 파악한다면 동적 구성은 쉽게 할 수 있을 거 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
