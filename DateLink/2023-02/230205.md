# 오늘 한 일

### 100일 코딩 챌린지 (54~55일차)

- JS : 매개변수

  - 기본 매개변수는 항상 기본값이 없는 모든 매개변수 다음에 오는 함수 매개변수 목록의 끝에 와야 한다.
  - 기본값을 추가하면 그 뒤에 있는 매개변수는 선택 사항이 되기 때문이다.
  - 값을 전달할 수 있지만 반드시 그럴 필요는 없기 때문이다.
  - 기본값이 없는 매개변수는 선택 사항이 아니다. 값을 전달하지 않으면 `undefined`를 기본값으로 얻게된다. 그건 일반적으로 원하는 게 아니기 때문이다.
  - 항상 비선택적 매개변수를 먼저 나열하고 그 이후에 선택적 매개변수를 나열해야 한다.
  - 비선택적 매개변수 값은 항상 제공되고, 선택적 매개변수에 관한 다른 값은 해당 함수를 호출할 때 항상 제공되는 것이 아니다.
  - 여기서 비선택적 매개변수는 `greetingPrefix`, 선택적 매개변수는 `userName`이다.

  ```
  function greetuser(greetingPrefix, userName = "user") {
    console.log(greetingPrefix + " " + userName + "!");
  }

  greetuser("Hi", "Jeong");
  greetuser("Hello");

  결과값

  Hi Jeong!
  Hello user!
  ```

- JS : 매개변수 (sum)

  - 예시로 매개변수를 3개 추가했을 경우
  - 한 가지 중요한 제한이 있는데 세 개의 숫자만 허용한다.
  - 정확히는 3개의 숫자를 원하는 것
  - 두 개의 숫자로는 호출할 수 없다.
  - 두 개의 숫자로 호출하면 NaN 결과가 출력된다.
  - 하나의 값이 더 추가되어야하는데 없기때문에 다른 하나의 값에 `undefined`가 오며, 숫자가 아니기 때문에 JS는 수학적으로 이를 수행할 수 없으므로 NaN 라는 결과를 출력한다.
  - 여기서도 기본값을 추가해 선택적 매개변수로 만들어주면 코드가 정상적으로 실행이 된다.

  ```
  function sumUp(num1, num2, num3 = 0) {
    return num1 + num2 + num3;
  }

  console.log(sumUp(1, 2));
  ```

  - 대신 숫자 배열도 허용할 수 있다.

  ```
  function sumUp(numbers) {
    let result = 0;

    for (const number of numbers) {
      result += number; // result = result + number
    }
    return result;
  }

  console.log(sumUp([1, 5, 5, 10]));
  ```

  - `...` 연산자 (Rest 매개변수)
    - 해당 함수는 매개변수의 양에 관계없이 허용하고 고정된 제한이 없다고 하는 것
    - 쉼표로 구분하여 전달된 모든 매개변수는 JS에 의해 배후에서 배열로 병합된다.
    - JS에서 내부적으로 배열로 래핑된다.
    - 개별 값 목록을 병합해 배열로 수집한다.
    - 객체에 사용하면 객체에서 모든 키 값 쌍을 가져와 해당 키 값 쌍의 목록을 제공
    - 중괄호 사이에 입력하면, 다른 객체의 모든 키 값 쌍을 가져오는 새 객체를 만듬
    - 다른 객체의 모든 이전 키 값 쌍이 있는 새 주소의 메모리에 새 객체를 얻는다.

  ```
  function sumUp(...numbers) {
    let result = 0;

    for (const number of numbers) {
      result += number; // result = result + number
    }
    return result;
  }

  console.log(sumUp(1, 5, 5, 10));
  ```

  ```
  function sumUp(...numbers) {
    let result = 0;

    for (const number of numbers) {
      result += number; // result = result + number
    }
    return result;
  }

  const inputNumbers = [1, 5, 5, 10];

  console.log(sumUp(...inputNumbers));

  // 여기서 consolo.log에 쓰인 `...`는 스프레드 연산자로 부른다.
  // 배열을 여러 개별 값으로 분산시키기 때문이다.
  // 결과 값은 위 예제 코드와 같다.
  // 여기서 console.log에 쓰인 `...`이 빠진다면 결과 값은 01,5,5,10 이렇게 나오게 된다.
  ```

- JS : 함수는 객체이다.

  - 내부적으로 함수는 객체일 뿐이다.
  - 이면의 함수는 모두 객체일 뿐이기에 함수에 속성을 추가할 수 있다.
  - 특별한 종류의 객체이긴하나 여전히 객체이다.
  - express가 함수로 실행된 다음 속성에 액세스할 때 객체처럼 사용될 수 있는 이유이다.

  <br />

- JS : 템플릿 리터럴 (JS에 내장된 기능)

  - `` 백틱
    - 여러 줄 문자열을 작성할 수 있게 해준다.
    - 문자열 내부에 줄 바꿈을 추가할 수 있다.(작은따옴표를 사용하면 불가능)
    - 더하기 연산자를 사용해 많은 부분을 연결하고 결합할 필요 없이 동적 값을 해당 문자열에 쉽게 연결할 수 있다.
    - ${}를 사용해 특수한 구문으로 만들어준다.
    - 중괄호 사이에 출력하려는 변수, 상수, 매개변수 값을 넣을 수 있다.
    - 동적 값이 많은 매우 긴 문자열을 구성하는 경우 유영할 수 있는 또 다른 기능이다.
    - 모든 추가 더하기 연산자와 문자열을 서로 연결하는 것을 피할 수 있고 해당 문자열 내부에 동적 값이 포함된 하나의 문자열을 작성할 수 있다.

  <br />

- JS : 기본 값(Primitive Values)과 참조 값(Reference Values)

  - Primitive values(원시 값): numbers, strings, booleans & more (undefined)
  - Reference values(참조 값): Objencts 여기에 Arrays, Functions도 포함(Array와 Function도 객체이기 때문이다.)
  - 참조 값은 원시 값과 다른 종류의 컴퓨터 메모리에 저장이 된다.
  - 그 이유는 단순히 객체가 좀 더 복잡한 경향이 있기 때문이다.
  - 결국 그 객체들은 여러 값, 여러 키 값 쌍, 심지어 일부 메서드를 포함할 수 있다.
  - 원시 값은 실제로 원시적이다.
    - 그 값들은 간단하다.
    - 단일 숫자 또는 단일 문자열, 더 긴 문자열이더라도 매우 간단하다.
  - 원시 값은 보다 기본적인 종류의 컴퓨터 메모리에 저장된다.
  - 객체는 보다 발전된 종류의 메모리에 저장된다고 할 수 있다.
  - 객체가 더 복잡해질 수 있다는 경향이 있기 때문에 객체의 불필요한 복사본은 피하도록 저장된다.
  - 불필요하게 객체를 복사하는 것을 피하려고 하는 것
  - 배열이나 객체를 생성하여 변수나 상수에 저장할 때 실제로 저장한 것은 값이 아니다.
    - 객체 또는 배열 자체지만 메모리의 해당 객체 또는 배열에 관한 포인터이다.
    - 메모리에 있는 해당 객체의 주소이다.
    - 배열 자체가 저장된 것처럼 보이지만 실제론 그렇지 않다.
  - 배열이나 문자열에 숫자를 저장하면 값 자체가 변수나 상수에 저장된다.
  - 그렇기 때문에 새 값을 해당 배열에 푸시(push)하면 값이 메모리의 기본 배열에 추가되지만 포인터는 변경되지 않는다.
  - 메모리에 있는 해당 배열의 주소는 변경되지 않는다.
  - 푸시(push)를 호출해 배열에 새 값을 추가하면 실제로 JS에 해당 주소를 조회하고 메모리의 실제 배열로 이동해 해당 값을 추가하도록 지시한다.
  - 상수에 저장된 값은 해당 값이 배열 자체가 아닌 주소이기 때문에 변경되지 않는다.
  - 객체는 단순히 숫자와 같은 원시 값과 다르게 메모리에 저장된다. 그리고 객체 자체가 아니라 상수에 객체의 주소만 저장하기 때문에 상수 값 자체를 조작하지 않고, 기본 객체 또는 배열을 조작할 수 있다.

  <br />

- JS : try - catch

  - 함수는 실행을 멈추지 않게된다.
  - 전체적으로 발생할 수 있는 오류를 매우 자세하게 처리하는데 매우 유용한 구조이다.
  - 일반적인 오류 처리 매커니즘에 의존하는 대신에 사용
  - 왜 모든 코드를 try - catch로 래핑하지 않는가?
    - 모든 것을 래핑하면 실제로 애플리케이션을 충돌시켜야 하는 몇 가지 오류도 포착할 수 있다. 개발 중에 수정할 수 있는 버그일 뿐이므로, 개발자는 코드를 작성하는 동안 이를 확인해야한다.
    - 그것들을 시도하고 처리하면 그 오류를 그렇게 빨리 발견하지 못할 수 도 있다.
    - 또 다른 이유로 다른 소스에서 발생하는 다른 오류가 종종 다른 방식으로 처리되어야 하기 때문이다.
    - 모든 것을 try - catch로 래핑하고 싶지 않고, 어떤 상황에서 오류를 예상할 수 있는 곳만 그리고 필요한 만큼만 코드를 래핑하고 싶을 때 사용

  <br />

- JS : 변수, 상수 및 함수의 범위 지정 (scoping)

  - 범위 지정이란 ?
    - 단순히 변수, 상수 및 함수가 특정 위치에서만 사용될 수 있음을 의미한다.
  - 파일에 값을 잠그는 파일 기반 범위 지정은 NodeJS전용이다.
  - 브라우저와 NodeJS 모두에 적용되는 다양한 형태의 범위 지정도 있다.
  - 범위 지정에 관해 주의해야 할 가장 중요한 점은 상수와 함수 및 변수를 정의한 블록에서만 사용할 수 있다는 것
  - 여기서 블록이란 ?
    - JS의 블록은 객체 생성을 제외하고 중괄호로 묶인 코드 섹션이다.
    - 객체를 생성하기 위해 등호 오른쪽에 중괄호를 사용한다면 그 곳에는 코드 블록이 없다.
      - ex) const person3 = { age: 32 };
    - 함수를 정의할 때, try -catch, for 반복문 여기에 중괄호가 있을 때마다 이 곳에서 중괄호는 코드 블록을 표시한다.
    - 예로 try - catch에서 상수를 정의하면 그 블록에서만 사용할 수 있다.
    - try - catch 블록 외부에서 console.log 할 수 없다.
    - 여기서 예로 try - catch 내부에서와 외부에서 모두 액세스 하려면 함수 블록에 변수를 생성하고, 그 다음 try - catch 블록에 할당해주면 된다.
    - 모든 중첩 블록에서도 사용할 수 있다. 위의 예처럼 함수 블록에서 정의된 변수를 try - catch 블록 내부에서 사용할 수 있다. 여기서 try 블록은 해당 함수 블록 내부에 있기 때문이다.
    - 외부에서 내부로 지원되지만, 반대는 되지 않는다.
    - 상수와 변수는 **해당 블록 외부가 아니라 정의한 블록 내부**에서만 사용할 수 있다는 점을 꼭 이해하는게 중요

  <br />

- JS : 변수 또는 상수를 가리는 개념 (섀도잉)

  - 함수 블록에서 정의된 상수나 변수의 이름을 함부 블록의 다른 내부 블록에서 동일하게 사용해 가린다.
  - 그렇게 같은 이름으로 상수나 변수로 정의하여 해당 내부 블록 내에서 더 높은 우선 순위를 갖게 한다.
  - 따라서 동일한 이름을 가진 함수 블록 상수 또는 변수와 완전히 관련이 없는 두 번째 변수나 상수를 가지게 된다.
  - 물론 꼭 이렇게 해야하는 것은 아니고, 다른 이름으로 정의해 변수나 상수가 어떤 범위에 속하는지 명확하게 할 수 있다.

  ```
  const fs = require("fs");

  function readFile() {
    let fileData;
    try {
      const fileData = fs.readFileSync("data.json");
    } catch {
      console.log("An error occurred!");
    }
    console.log(fileData);
    console.log("Hi there!");
  }

  readFile();
  ```

- Quiz 15. More Advanced JavaScript Concepts

  - 함수에서 “기본 매개변수”를 사용하면 어떤 효과가 있나요?
    - 일부 매개변수는 함수가 호출될 때 명시적으로 설정되지 않은 경우 자동으로 값을 가정하기 때문에 이제 선택 사항이다.
  - 기본 매개변수를 설정하는 데 올바른 구문은 무엇입니까?
    - function multiply(number, factor = 2) { return number \* factor; }
    - 기본값이 있는 매개변수는 다른 모든 매개 변수 다음에 추가하는 것이 중요하다.
  - "Rest 매개변수(...)"의 주요 아이디어는 무엇입니까?
    - 다양한 양의 매개변수 값으로 함수를 호출할 수 있다.
  - “확산 연산자”(...)의 기능은 무엇인가요?
    - 배열과 객체에서 값(또는 키-값 쌍)을 가져온다.
  - 함수에 관한 설명으로 옳은 것은?
    - 함수는 객체이지만 실행(호출)될 수 있다.
  - 기준값에 대한 설명으로 옳지 않은 것은?
    - 참조 값은 변수/상수에 값으로 저장된다. (틀림)
    - 모든 객체는 참조 값이다. (맞음)
    - 참조 값의 경우 값의 주소는 변수/상수에 저장된다. (맞음)
  - 아래 스니펫에서 숫자에 무엇이 저장되어 있습니까?
    - const number = 32;
    - 값 32
    - 32는 숫자이며 원시 값이므로 값 자체가 저장된다.
  - 이 코드 조각은 콘솔에 어떤 출력을 기록합니까?

  ```
  const hobbies = ['Sports', 'Cooking'];
  const newHobbies = hobbies;
  newHobbies.push('Reading');
  console.log(hobbies);

  // ['Sports', 'Cooking', 'Readidng']
  // 배열은 참조 값이므로{newHobbies}를 변경하면 원래 배열이 변경된다. 주소가 동일하기 때문이다.
  ```

  - try / catch를 사용한 오류 처리의 이면에 있는 아이디어는 무엇입니까?
    - 이를 통해 JS 코드에서 세분화된 오류 처리를 구현할 수 있다.
  - "가변 범위" 개념의 이면에 있는 아이디어는 무엇입니까?
    - 변수(및 상수)는 정의된 범위(및 "중첩 범위")에서만 사용할 수 있다.

<br />

# 오늘 느낀 점

- 매개변수에 대해 간단한 예제로는 참 이해가 쉬운데 좀 코드가 복잡해지면 이게 어떻게 들어오는거지 이런 생각을 했었는데, 아까 console.log를 매개변수가 들어오는 곳에 다 찍어보며 확인해보면서 예전보다는 더 이해가 가는 것 같다. 하지만 아직 부족하다고 생각이 되며, 코드를 보고 아 이건 바로 여기서 오는거구나 하고 이해하는 수준까지 공부해야겠다고 생각하였다. 그리고 일부 매개변수에 대해서도 배웠는데 그 부분은 이해가 바로 되었다.

- (...)연산자도 배웠는데, 배열형식으로 래핑하여 사용하는데 코드를 직접치면서 해볼땐 바로 이해가 되었는데 퀴즈를 풀 때 글로만 읽으니 잘 이해가 되지않았는데 확실한건 사용할 기회가 되면 자주 사용해보면 익숙해질거라고 생각한다.

- 백틱에 대해서는 또 한가지 새로운 걸 배워가는데 줄 바꿈을 할 수 있다는 걸 알지 못했던거같은데 이번 기회에 또 하나 추가로 복습하며 배워가는거 같다.

- 원시 값, 참조 값도 뭔가 설명은 되게 길게 주절주절 적어놓았지만, 처음 예시를 보고 이해는 바로 되었다. 참조 값에서 특히 중요한 부분은 실제로 값으로 저장된다고 생각했던 것이 주소로 저장된다는 사실이었는데, 중요하며 꼭 기억하고 이해해야하는 부분이라고 생각이 된다.

- try - catch 에 대해서는 예전에 배웠던게 기억이 가물가물 했는데 이번에 다시 배우면서, 세분화된 오류 처리를 구현할 수 있게 도움을 준다고 확실하게 배운 것 같다.

- 변수 또는 상수를 범위지정 하는 스코핑과 가리는 새도잉 이 부분에 대해 배웠는데, 먼저 스코핑은 블록에 대한 개념이라고 생각한다. 일반적인 객체 생성은 블록이 존재하지 않으며 함수, 트라이, for문에서 블록이 있는데 그 블록 안에서 정의한 변수 또는 상수를 외부에서 내부로 지원은 되지만 반대는 불가능하며, 정의한 그 블록에서만 사용가능한 부분 이런 블록에 대한 내용은 기존에 내가 계속 해오던 방식이었다. 그냥 블록이라는 개념에 대해 확실하게 정의하고 가는 느낌이었다. 그리고 새도잉은 먼저 함수에서 정의된 변수나 상수의 이름을 다른 내부 블록에서 그 이름을 동일하게 사용하면서 높은 우선 순위를 갖게하는 방법이다. 꼭 그 방식이 아닌 다른 이름으로 정의하여 명확하게 표현할 수 도 있다.

<br />

# 내일 할 일

- 100일 코딩 챌린지 계속 진행하기 (속도보단 복습과 꾸준한 연습으로 튼튼하게 다지기)

- ExpressJS에 대해 더 깊게 공부하기 (EJS와 함께)

- Advanced-js(고급 JS)에 대해 공부하며 이해하기

- 코드 리팩토링, 쿼리 매개변수

- new 키워드, FormData(), get(), trim() 찾아보고 내용추가

- Tic Tac Toe 게임의 endGame 함수에서 매개변수 한번 더 봐보기 + 매개변수에 대해 추가 공부

- require, createServer, listen 에 대해 알아보기
