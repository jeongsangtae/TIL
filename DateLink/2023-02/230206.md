# 오늘 한 일

### 100일 코딩 챌린지 (55~57일차)

- JS : Date()

  - 브라우저와 NodeJS 모두에서 JS에 내장되어 있다.
  - 생성자 함수 또는 클래스
  - 객체를 구축할 수 있는 블루프린트이다.

  <br />

- JS : new 키워드

- JS : class

  - NodeJS와 브라우저 모두에서 지원되는 자체 블루프린트 생성
  - 객체에 관한 블루프린트
  - 명명 규칙은 Date가 대문자로 시작하는 것처럼 일반적으로 해당 클래스의 대문자로 시작
    - ex) class Job {}
  - 고유하고 재사용 가능한 블루프린트를 갖기 위해 고유한 클래스를 생성
  - "생성자" 메서드 (Constructor)
    - 클래스를 기반으로 하는 새 객체가 생성될 떄 실행되는 로직을 작성할 수 있다.

  <br />

- JS : this

  - JS에 내장된 특수 키워드
  - 단순히 생성될 객체를 참조한다.
  - 점 표기법을 사용해 속성을 읽거나 쓸 수 있다.

  <br />

- Array Destructuring (배열 비구조화) & Object Destructuring (객체 비구조화)

  - 모든 요소를 가져올 필요는 없다. 배열 또는 객체에서 원하는 요소만 가져올 수 있다.
  - 객체는 JS가 추출하려는 속성을 알 수 있도록 속성 이름중 하나를 사용해야 한다.
  - 객체 비구조화에서 속성의 값은 그대로 얻고 싶지만, 다른 이름을 가지고 싶을 때는 `:`을 추가해 비구조화 할 수 있다.
    - ex) const { title: jTitle } = job
  - 객체 비구조화를 사용한 예
    - 저번에 uuid를 사용할 때 `const uuid = require('uuid')` 이렇게 사용
    - 하지만, 공식 문서에서 객체 비구조화를 하여 사용한다면
    - `const { v4: uuidv4 } = require('uuid')`

  ```
  const arrays = ["a", "b", "c", "d", "e"];

  const [first, second, third] = arrays;

  console.log(first, second, third);

  const job = {
    title: "Developer",
    location: "Seoul",
  };

  const { title, location } = job;

  console.log(title, location);
  ```

- Quiz 16. More on Objects

  - “클래스"의 이면에 있는 아이디어는 무엇입니까?
    - 객체에 대한 청사진을 정의할 수 있다.
  - 온라인 상점에서 제품에 대한 청사진을 정의하는 클래스의 좋은 이름은 무엇입니까?
    - Product (맞음)
    - PRODUCT (틀림)
    - product (틀림)
    - 클래스 이름을 정의할 때는 맨 앞에 대문자로 시작
  - "생성자" 메서드의 역할은 무엇입니까? (Constructor)
    - 클래스를 기반으로 하는 새 객체가 생성될 떄 실행되는 로직을 작성할 수 있다.
  - “this” 키워드는 무엇을 의미하나요?
    - 클리스를 기반으로 하는 객체에

  <br />

- JS : async operation(비동기 작업)

  - 작업이 시작되고 그 결과를 기다리지 않고, 그 이후의 코드가 실행되도록 작동한다.
  - 다른 작업을 차단하지 않고 "백그라운드에서" 실행되는 작업을 뜻한다.
  - 그렇기 때문에 비동기 작업에 쓰인 프로미스 주위에 try - catch를 사용할 수 없다.
  - 콜백 함수도 마찬가지이다. (try - catch로 래핑해도 의도한 대로 작동하지 않는다.)
  - 그래서 콜백 접근 방식의 경우 오류가 발생했는지 여부를 알려주는 오류 매개변수를 가진다.

  ```
  fs.readFile("data.txt", function (error, fileData) {
  if (error) {
    // ...
  }
    console.log("File parsing done!");
    console.log(fileData.toString());
  });

  // 콜백으로 작업할 때 오류를 처리하기 위해 할 수 있는 작업 (if문 사용)
  ```

  - 프로미스는 프로미스 체인에 다른 메서드를 추가할 수 있다.
    - catch 메서드
    - catch()
  - 프로미스에는 성공 사례를 처리하는 then 메서드와 이전 프로미스에서 발생할 수 있는 오류를 처리하는 catch가 있다.
  - catch도 함수를 가진다.
    - 발생한 오류를 설명하는 해당 오류 객체를 가져오는 함수
    - 그 다음 해당 오류를 console.log하거나 처리하려는 방식으로 처리할 수 있다.

  ```
  fs.readFile("data.txt")
    .then(function (fileData) {
      console.log("File parsing done!");
      console.log(fileData.toString());
      // return anotherAsyncOperation
    })
    .then(function () {})
    .catch(function (error) {
      console.log(error);
    });

  // 프로미스로 작업할 때 오류를 처리하기 위한 작업 (catch 사용)
  ```

- JS : promises

  - 내장 패키지
  - 파일 시스템 메소드의 프로미스 버전을 제공
  - 프로미스는 항상 then 메소드를 갖는 객체이다.
  - 프로미스는 then 메소드를 추가 한 것 빼곤 콜백함수와 거의 동일하다 ?
  - 그렇다면 어떤 이점이 있을까?
    - 장점은 프로미스를 사용해 보다 구조화된 방식으로 코드를 작성할 수 있다.
    - 매우 읽기 쉬운 프로미스 체인으로 이어진다.
    - 여러 비동기 작업을 명확하게 구조화된 작업 라인으로 결합할 수 있다.
  - 프로미스는 비동기 작업을 처리하는 매우 현대적이고 널리 사용되는 방법이다.
  - 단순히 더 구조화된 방식으로 코드를 작성할 수 있기 때문
  - 종종 비동기 작업을 시작하는 메소드에 직접 전달하는 콜백 함수 작업의 대안
  - 프로미스를 사용하는 것은 종종 콜백 함수를 사용하는 것의 대안이지만 콜백과 프로미스를 모두 제공하는지 콜백을 조정하거나 그냥 프로미스를 제공하는지 여부는 항상 사용 중인 패키지에 따라 다르다.
  - 프로미스는 이미 잠재적으로 서로 중첩될 수 있는 여러 콜백 함수를 갖는 것보다 조금 더 구조화된 코드를 작성할 수 있도록 한다.
  - 비동기 작업을 래핑하고 보다 구조화된 코드를 작성할 수 있도록 하는 기본 제공 객체이다.

  <br />

- JS : then 메소드

  - 함수, 익명 함수 또는 미리 정의된 함수를 사용한다.

  <br />

- 대부분의 패키지는 비동기 작업을 수행할 때 동기화 대안을 제공하지 않는다.

- JS : async / await

  - 콜백, 프로미스에서 추가 로직으로 복잡해지는 코드를 단순화 해줄 수 있다.
  - 함수 앞에 `async` 키워드를 추가해 함수를 소위 `async 함수`로 전환할 수 있다.
  - 그렇게 하면 그 함수는 명시적으로 반환하지 않고, 자동으로 프로미스를 반환한다.
  - `async` 키워드는 다른 하나의 키워드를 잠금해제해서 해당 async 함수 내에서 사용할 수 있다.
  - 바로 `await` 키워드
    - 프로미스를 반환하는 모든 메서드 앞에 해당 키워드를 추가할 수 있다.
  - 내부적으로 async await를 사용할 때 JS는 해당 프로미스에 then을 추가한다. 그리고 변수나 상수, then에 전달되는 함수의 매개변수 값으로 얻을수 있는 값을 제공한다.
  - 그래서 JS는 해당 값을 반환 값을 제공한다. 마치 그것이 비동기 작업인 것처럼
  - 내부적으로 말하면 뒤에서 변형된 것이다.
  - 코드 실행은 다음 줄로 넘어가기 전에 await를 사용한 줄이 완료될 떄까지 중단된다.
  - 프로미스를 사용하도록 강제하는 일부 작업을 사용하는 경우 async await를 사용해 코드를 다시 단순화 할 수 있다.
  - 콜백함수와 프로미스에서 사용못한 try - catch를 다시 사용할 수 있다.
  - 동기식 코드처럼 보이는 스타일로 돌아갈 수 있게 해준다.
  - 사실은 아직 비동기 작업이다.
  - 더 단순화된 코드를 원할 경우 매우 유용하다.
  - 그리고 여러 비동기 작업을 동시에 시작하지 않아도 괜찮다. 왜냐하면 그건 가능하지 않고, await가 코드 실행이 완료될 때까지 다시 차단하기 때문이다.
  - 동시에 여러 작업을 시작할 필요가 없는 경우 유용할 수 있는 단순화 작업이다.
  - 훨씬 더 읽기 쉬운 방식으로 프로미스 기반코드를 작성할 수 있다.

  <br />

- Quiz 17. Asyncchronous Code

  - "비동기 작업"이란 무엇입니까?
    - 다른 작업을 차단하지 않고 "백그라운드에서" 실행되는 작업이다.
  - 콜백 기능이란 무엇입니까?
    - 미래의 어느 시점에서 실행될 다른 함수에 매개변수로 전달되는 함수이다.
  - 자바스크립트에서 “프로미스"란 무엇입니까?
    - 비동기 작업을 래핑하고 보다 구조화된 코드를 작성할 수 있도록 하는 기본 제공 객체이다.
  - 모든 장기 작업이 프로미스를 지원합니까?
    - 아니요.
    - 해당 작업을 수행하는 함수는 Promise를 적극적으로 지원해야 한다.(즉, 내부적으로 Promise를 반환해야 함).
  - async/await는 어떤 작업을 하나요?
    - 이를 통해 훨씬 더 읽기 쉬운 방식으로 프로미스 기반코드를 작성할 수 있다.

  <br />

- DB

  - 기존의 데이터를 영구 저장할 때 항상 파일에 저장
    - 단순히 데이터를 파일에 쓰고 해당 데이터가 필요할 때 해당 파일에서 읽어들였다.
    - 이 방법의 문제점
      - 데이터를 생성할 때 항상 파일의 전체 내용을 새 데이터로 바꿔버린다.
      - 데이터를 읽을 때 항상 전체 파일 내용을 읽은 다음 반복해서 특정 요소를 찾는다.
      - 데이터를 업데이트하거나 삭제하려는 경우 전체 콘텐트를 읽고 업데이트하거나 삭제할 요솔르 찾은 다음 전체 데이터를 업데이트하고 다시 작성한다.
    - 매번 이렇게 한다면 매우 비효율적인 방법이다.
    - 항상 모든 것을 덮어쓰고, 항상 모든 데이터를 읽기 때문이다.
    - 물론 그저 다양하고 간단한 데모 프로젝트와 웹 사이트를 탐색하고 있지만 웹 사이트가 성장하고 데이터가 점점 더 많아지면서 성능 문제가 발생하고 코드가 불필요하게 많은 작업을 수행하게 된다.
    - 생성, 읽기, 업데이트, 삭제 작업은 매우 평범하게 일반적으로 `CRUD` 작업이라고 한다.
      - Create
      - Read
      - Update
      - Delete
  - DB는 왜 필요한가?
    - 데이터 크기가 커지고, 데이터가 많아짐에 따라 확장성 문제가 발생할 수 있다.
    - 서버에 점점 더 많은 요청이 들어오면 문제가 발생할 수도 있다.
    - 파일을 덮어쓰는 문제도 발생할 수 있다.
    - 등등 여러가지 문제를 DB로 인해 해결할 수 있다.
  - DBMS (데이터베이스 관리 시스템)
    - 단순히 소프트웨어 시스템
    - 일부 시스템에 소프트웨어를 설치한다고 생각하면 된다.
    - 데이터 저장 작업에 최적화 되어 있지만, 내부적으로는 여전히 데이터와 파일을 어느 시점에 저장하지만, 더 효율적인 방식으로 수행하기에 파일 액세스와 동시 읽기 쓰기, 액세스 관리의 모든 부담을 없앨 수 있다.
    - 데이터를 파일에 쓰는 방법이나 파일에서 가져오는 방법에 대해 걱정할 필요 없이 데이터를 사용해 작업할 수 있다.
    - 읽기-쓰기 액세스를 최적화
    - 데이터 저장 및 검색 방법을 단순히 최적화해서 데이터를 보다 효율적으로 만든다.
    - 파일 시스템에 압도하지 않도록 도와준다.
    - 풍부한 쿼리를 지원해 데이터 쿼리를 최적화 한다.
    - 많은 양의 데이터에서 특정 데이터 조각을 찾을 수 있도록하는 특정 쿼리 언어를 제공한다.
    - 웹 사이트에서 하고자하는 동일하거나 더 많은 작업에 관해 코드를 적게 작성해야 한다.
    - 데이터를 저장하고 가져오는 웹 사이트가 있는 경우 DBMS를 반드시 사용해야 한다.
    - SQL (Structured Query Language)
      - 관계형 DBMS
      - 구조화된 쿼리 언어를 의미한다.
      - DB에서 데이터를 가져오고, DB 또는 일반적으로 데이터를 저장하기 위해 구축된 일종의 프로그래밍 언어이다.
    - NoSQL
      - 비관계형 DBMS
      - 데이터를 다르게 저장하기 때문에 그렇게 불린다.
      - DB 내부에서 다르게 구조화되어 있고, 데이터를 가져오거나 데이터를 쓰는데 SQL언어를 사용하지 않고, 다른 쿼리 언어를 사용한다.

  <br />

- SQL

  - 일반적으로 여러 테이블에 걸쳐 정규화된 데이터를 저장한다.
  - 테이블의 모든 열에는 행당 하나의 값만 가진다.
  - 실제로 스키마와 데이터 유형을 명확하게 정의한다.
  - 데이터 저장 또는 가져오기를 시작하기 전에 DB 테이블을 설정하고, 모든 테이블에 관한 스키마를 만들고 해당 DB의 모든 필드에 어떤 종류의 데이터를 저장해야 하는지 정의한다.
  - 고유 식별자가 없으면 서로 다른 테이블의 서로 다른 데이터 조각 간에 명확한 관계를 가질 수 없다.
  - SQL DB를 사용하면 데이터, 특히 관련 데이터를 쿼리할 수 있다.

  <br />

- NoSQL

  - 많은 테이블을 사용하는 것 대신 일반적으로 몇 개의 테이블만 사용한다.
  - 예로 하나의 큰 항공편 테이블이 있다면, 거기에 저장하려는 모든 데이터가 포함된 문서를 저장하고 있다.
  - SQL DB에서 알고 있는 것처럼 열과 행으로 작업하는 대신 예를 들어 JSON 형식으로 데이터를 저장한다.
  - 실제로 단일 문서에 속한 모든 데이터를 포함하는 독립 실행형 문서가 있다.
  - 다음으로 큰 레코드를 하나의 테이블에 저장하는 이점은 더 적은 수의 테이블에 더 많은 정보를 저장할 수 있기에 더 적은 쿼리로 더 많은 정보를 얻을 수 있다는 점이다.
  - 여러 테이블을 연결할 필요가 없으며, 여러 테이블에서 복잡한 쿼리를 실행할 필요가 없어진다.
  - 한 필드에 관해 하나의 쿼리를 실행하고 예처럼 항공 코드와 관련된 모든 데이터를 얻는다.
  - 쿼리를 단순화해서 DB 성능을 향샹시킬 수 있기 때문에 큰 이점이 될 수 있다. 덜 복잡한 쿼리를 실행해야 하기 때문에
  - 저장된 데이터의 크기는 조금 더 커질 수 있지만 많은 양의 데이터를 저장하는 것이 반드시 문제가 되는 것은 아니다.
  - 일반적으로 성능 병목 현상은 데이터 쿼리이며, 더 많은 데이터가 함께 저장되기 때문에 NoSQL DB를 사용해 단순화할 수 있다.
  - SQL DB와 달리 NoSQL은 열과 행으로 생각하지 않고, 대신 테이블에 저장되는 객체 또는 문서가 있으며 명확하게 설정된 스키마도 없다.
  - 예시로 항공편 테이블의 모든 항목은 우연히 동일한 구조를 갖지만 독립형 문서가 있기에 동일한 테이블의 다른 문서에 다른 구조를 가질 수 있는 열이 없다.
  - 처음에 설정하고 정의해야 하는 스키마가 없기 때문이다.

  <br />

- SQL vs NoSQL

  - 결국 확실한 승자는 없다.
  - 두 가지 접근 방식 모두 괜찮다.
  - 두 DBMS 모두 매우 대중적이다.
  - DBMS 선택할 때 명확한 결정 기준은 없다.
  - 시스템을 선택하는데 도움이 될 수 있는 부분
    - 실행할 쿼리와 저장할 데이터의 종류
    - 데이터를 쓰는 빈도와 데이터를 읽는 빈도에 관해서 생각해보는 것
  - 매우 큰 웹사이트에서는 두 시스템 모두에서 작업하고 서로 다른 종류의 DBMS에 서로 다른 종류의 데이터를 저장할 수 도 있다.
  - SQL DB
    - 더 많은 구조와 규칙을 제공하는 이점이 있다.
    - 이는 웹 사이트를 계획할 때와 DB 계획할 때 도움이 될 수 있다.
    - 일부 데이터 엄격함을 적용할 수 있다.
    - 웹 사이트가 성장하고 트래픽이 증가함에 따라 도움이 될 수 있다.
    - 실수로 많은 다른 데이터를 저장할 수 없기 때문에 나중에 쿼리하기가 어려워 질수 있다.
    - 다른 한편으로 이점이 단점이 될 수 도 있다.
    - 웹 애플리케이션이 성장함에 따라 데이터 사용 사례도 변경될 수 있기 때문이다.
    - 특정 구조와 스키마가 있는 경우 스키마를 쉽게 변경할 수 없기 때문에 가능한 모든 사용 사례를 처리하기가 어려울 수 있다. 물론 할 수 있지만 항상 더 많은 작업이 필요하다.
  - NoSQL DB
    - 고정된 스키마가 없기 때문에 좀 더 유연할 수 있다.
    - 많은 데이터를 읽는 DB가 있는 경우 NoSQL DB는 정말 좋을 수 있다.
    - 많은 테이블을 엮을 필요가 없는 더 간단한 쿼리를 가질 수 있기 때문이다.
    - 더 적은 쿼리로 더 많은 데이터를 얻을 수 있기에 더 나은 성능을 얻을 수 있다.
  - 성능에 대해 말하면 하루에 수백만 명의 활성 사용자가 있는 초대형 웹 사이트와 웹 애플리케이션을 생각해보면 SQL DB에는 약간의 확장성 문제가 있는 경향이 있다.
  - 물론 문제를 해결하기 위한 전략은 있다. 웹 사이트의 일부에는 SQL DB를 사용하고, 다른 부분에서는 NoSQL DB를 사용할 수 있다.
  - 데이터 저장과 관련해서 단순하기 때문에 NoSQL DB는 많은 양의 데이터와 많은 방문자 및 쿼리에 관해 SQL DB를 능가하는 경향이 있다.
  - 항상 DB가 올바르게 사용 및 구현된다는 가정하에 있는 것이다.
  - 당연하게도 NoSQL DB를 잘못된 방식으로 사용한다면 SQL DB보다 성능이 저하되며 그 반대가 된다.
  - 궁극적으로 명확한 승자가 없다.
  - NoSQL DB가 요즘 매우 인기있는 경향이 있지만 두 DB 모두 장단점이 있고, 두 DB 모두 대기업에서 모든 종류의 사용 사례 및 시나리오에 사용하고 있다.

  <br />

- Quiz 18. Databases Introduction

  - (적어도 많은 웹사이트와 웹 애플리케이션에서) 데이터베이스가 필요한 이유는 무엇입니까?
    - 데이터베이스는 데이터 저장 및 검색을 최적화하기 때문이다.
  - 결국 "데이터베이스" 또는 "데이터베이스 시스템"은 실제로 무엇입니까?
    - 설치하는 일부 추가 소프트웨어
  - RDBMS(SQL) 데이터베이스 시스템에 대한 설명으로 옳지 않은 것은 무엇일까요?
    - 중첩되거나 연결된 데이터는 몇 개의 테이블에만 저장된다. (틀림)
    - 데이터는 정규화되고 일반적으로 여러 테이블에 저장된다. (맞음)
    - 데이터는 열과 행에 걸쳐 구조화된다. (맞음)
    - SQL 데이터베이스에 이와 같은 데이터를 저장할 수 있지만 데이터베이스를 잘못된 방식으로 사용할 가능성이 매우 높습니다.
  - NoSQL 데이터베이스의 핵심 아이디어는 무엇인가요?
    - 데이터는 쿼리의 복잡성을 줄이도록 구조화된다.

<br />

# 오늘 느낀 점

- class에 대해 배웠는데 이번에 다른곳에서 사용했던 내용과 비슷하였고, 단지 class 내부에서 this 사용하는 부분에 대해 좀 더 봐봐야할거 같다.

- 비동기 작업에 대해 좀 길게 배운거같은데, 결국 비동기 작업은 해당 작업이 진행되는 동안 그 뒤의 코드도 함께 실행되도록 하는 것인데 여기서 앞의 작업이 진행되던 과정에서 뒤의 코드가 오류가 생기면서 전체 코드가 멈출 수도 있다. 그 비동기 작업을 콜백 함수와 프로미스가 할 수 있는데 콜백 함수보다 구조화된 코드를 작성할 수 있는 프로미스를 사용하며 거기서 더 코드를 단순화하기 위해 async/await 방식을 사용해 더 읽기 쉬운 방식으로 프로미스 기반 코드도 작성할 수 있으며, 프로미스에서 사용하지 못한 try - catch 도 사용할 수 있게 된다.

- SQL과 NoSQL을 사용하는 것에 대한 문제는 개인의 선호도와 지식 및 경험에 달려있다고 생각한다. 두 가지 접근 방식중 어느 것이 더 직관적인지 생각해보고 본인 스스로 결정해서 사용해야 한다. 두 접근 방식 모두 장단점이 있기 때문이다. 상황에 맞게 사용해야지 각 DB의 성능을 제대로 사용할 수 있게된다.

<br />

# 내일 할 일

- 100일 코딩 챌린지 계속 진행하기 (속도보단 복습과 꾸준한 연습으로 튼튼하게 다지기)

- ExpressJS에 대해 더 깊게 공부하기 (EJS와 함께)

- Advanced-js(고급 JS)에 대해 공부하며 이해하기

- 코드 리팩토링, 쿼리 매개변수

- new 키워드, FormData(), get(), trim() 찾아보고 내용추가

- Tic Tac Toe 게임의 endGame 함수에서 매개변수 한번 더 봐보기 + 매개변수에 대해 추가 공부

- require, createServer, listen 에 대해 알아보기
