# 오늘 한 일

### 100일 코딩 챌린지 (74~75일차)

- 인증 (Authentication)

  - 웹 사이트에 로그인 가입 및 로그아웃 기능을 추가하고 나의 사이트에 계정을 만들지 않은 익명의 사용자와 우리가 아는 사용자를 구분한다는 것을 의미
  - 계정이 있는 권한 있는 사용자에게 웹 사이트가 제공해야 하는 특정 기능의 잠금을 해제할 수도 있다.

  <br />

- 보안 (Security) (웹 사이트 보안)

  - 고격 및 작업으로부터 보호하고자 한다.
  - 그 어떤 사용자도 모든 계정 목록을 가져오거나 DB 테이블을 삭제할 수 없어야 한다. 어떤 사용자에게도 가능해서는 안된다.
  - 어떤 사용자도 나의 사이트에서 다른 방문자의 데이터를 훔쳐서는 안된다.
  - 실제로 놀랄 만큼 많은 웹 사이트가 취약한 몇 가지 일반적인 공격 패턴이 있다.

  <br />

- CSRF 공격 (Cross Site Request Forgery, 사이트 간 요청 위조)

  - 수행해서는 안 되는 작업을 유발하는 요청을 서버의 백엔드로 보낸다.
  - CSRF 공격은 의도하지 않은 방식으로 사용되는 세션이 포함된다. 그리고 그러한 요청은 예로 나의 웹 사이트처럼 보일 수 있는 웹 사이트를 만들어 위조될 수 있다. 그런 다음 악용하는 사람은 피해자일 수 있는 사용자에게 링크를 보낸다. 이들은 자신도 모르게 해당 웹 사이트를 기본적으로 사용하게 된다.
  - 예로 피싱 이메일 공식적으로 나한테서 온 것처럼 보이는 준비된 이메일이 있다. 하지만 사실은 악용하는 사람한테서 온 것
  - CSRF 공격에 관한 반효과적인 방어

    - Same-Site Cookie
      - 최신 브라우저에 있는 기능
      - 명시적으로 구성되지 않은 경우 브라우저가 특정 기본값을 가정하는 서버 측에서 설정할 수 있는 쿠키 구성이다.
      - 예로 크롬은 렉스를 기본 구성으로 사용
      - 렉스가 의미하는 것은 쿠키가 다른 사이트에서 수신되는 요청에 첨부될 수 있다는 것
      - 단, 메인 사이트에서 해당 사이트를 방문한 경우에만 가능
      - 따라서 이메일의 일부 링크를 클릭하면 보내는 요청에 쿠키가 첨부되지 않는다.
      - 제한 사항과 염두에 두어야할 사항이 있다.
        - 로컬 호스트에 있는 경우 모두 비활성화된다.
        - 렉스는 모든 브라우저에서 적용되는 것이 아니며 예로 방문자가 파이어폭스, 사파리에서 사용하는 경우 CSRF 공격 패턴에 취약할 수 있다.
      - samesite cookie가 도움이 될 수는 있지만 여전히 충분한 보호 매커니즘은 아니다.
      - samesite cookie 설정은 있으면 당연히 좋다. 추가 보호 기능을 추가하지만 그 자체로는 CSRF 공격으로부터 완전히 보호하기에는 충분치 않다.

    ```
    // samesite cookie 추가

    app.use(
      session({
        secret: "super-secret",
        resave: false,
        saveUninitialized: false,
        store: sessionStore,
        cookie: {
          maxAge: 2 * 24 * 60 * 60 * 1000,
          sameSite: "lax",
        },
      })
    );
    ```

    - CSRF 공격 보호에 관한 모범 사례는 사이트에 추가할 수 있는 방법에는 이른바 CSRF 토큰 생성이 포함된다. (CSRF 공격에 대한 효과적인 방어)
      - 서버 측에서 생성되는 무작위로 보이는 문자열 값인 토큰이다.
      - 서버에서만 알 수 있고 수명 주기가 짧다.
      - 그 토큰들은 하나의 요청 응답 주기 동안에만 존재한다.
      - 서버가 해당 토큰을 생성했기 때문에 서버에 알려진다.
      - 해당 토큰을 사용해서 해당 문자열을 서버에서 렌더링하는 템플릿에 주입한다. 예로 숨겨진 입력 필드에
      - 그 다음 수신되는 요청에 관해 서버는 그러한 유효한 토큰이 해당 요청의 일부인지 확인한다.
      - 서버만이 그 토큰을 알고 있기 때문에 그 이후에는 한 번의 수신 요청에 대해서만 유효하기 때문에 그리고 공식 템플릿에만 존재하기 때문에 내가 소유한 해당 서버가 렌더링한 공식페이지, 공격 서버, 가짜 서버는 해당 토큰을 알 수 없다. 추측할 수도 없다. 다른 서버에서 생성할 수도 없다.
      - 서버만이 올바른 토큰을 알고 있으며 도난당할 수도 없다.
      - 따라서 유효한 CSRF 토큰이 없는 요청은 차단된다.
    - express csrf 패키지 (CSRF 토큰 패키지)

      - npm install csurf
      - csurf 패키지는 node-express 앱에서 가장 많이 사용되는 패키지이다.

      ```
      // app.js

      const csrf = require("csurf");

      app.use(csrf());


      // demo.js

      router.get("/transaction", function (req, res) {
        if (!res.locals.isAuth) {
          return res.status(401).render("401");
        }
        const csrfToken = req.csrfToken();
        res.render("transaction", { csrfToken: csrfToken });
      });


      // transaction.ejs

      <input type="hidden" value="<%= csrfToken %>" name="_csrf">
      ```

- XSS 공격 (Cross Site Scripting)

  - 교차 사이트 스크립팅 공격
  - 악성 JS 코드를 웹 사이트 콘텐츠에 주입하는 것
  - 사이트에 인증이 있다면 XSS가 더 많은 피해를 줄 수 있다.
  - 삽입된 JS 코드를 사용하면 인증된 사용자를 대신해서 예로 어딘가에 송금을 하는 요청을 다시 보낼 수 있기 때문이다.
  - 인증이 기술적으로 필요하지 않다. XSS에 취약하게 하기 위해 기술적으로 인증이 필요한건 아니다.
  - 두 가지 보호 방법이 있는데 두 가지를 모두 수행할 필요는 없다.
  - 일반적으로 두 가지를 모두 수행해서는 안되고 삭제 및 이스케이프를 동시에 처리하면 안된다. 대신 둘 중 하나만 수행해야 한다.
  - 일반적으로 삭제 처리하지 않아야 하며 대신 이스케이프를 우선적으로 처리해야 한다.
  - 이스케이프 처리되지 않은 컨텐츠를 출력하려는 경우 먼저 정리해서 삭제해야 한다.
  - 이스케이프 처리 할 수 없고, 일부 원시 HTML 컨텐츠를 출력해야 하고, 이를 HTML로 구문 분석해야 하는 시나리오가 있는 경우에 필요하다. 그러한 경우에는 출력하기 전에 최소한 삭제하기를 고려할 수 있다.
  - 보호 방법

    - 첫 번째. 사용자 입력을 이스케이프 처리하는 방법 (컨텐츠를 이스케이핑)
      - EJS 템플릿 언어에서 일반적으로 `-` 대신에 `=`를 사용해서 출력한다.
      - 그 이유는 EJS 태그를 등호와 함께 사용하면 출력될 컨텐츠가 이스케이프 처리되고 결국에는 일반 텍스트로 처리된다.
      - 따라서 사용자 생성 컨텐츠를 출력할 때는 항상 `-`대신 `=`를 사용해야 한다.
      - 우리들이 실제로 HTML 컨텐츠로 구문 분석해야 한다는 것을 진짜로 알고 있지 않는 한. 그런 경우에는 먼저 삭제되었는지 확인해야 한다.
      - `-`가 들어있는 태그는 포함 함수를 사용할 때 볼 수 있다.
      - 실제로 다른 파일에 정의된 많은 HTML 코드를 포함하려고 하기 때문에 `-`사용하는 곳에서 구문 분석을 하고 HTML로 사용되어야 한다.
      - ex) `<%- include('includes/header.ejs') %>`
      - 위 예시는 개발자가 작성한 HTML 코드가 포함되어 있기에 사용자 생성 컨텐츠가 아니라 안전하다.
      - 대신 사용자 생성 컨텐츠는 일반적으로 `=`태그와 함께 출력해야한다.
      - 기존에 `-`로 출력하던 사용자 생성 컨텐츠 `ex) <script>alert("Hacked!")</script>`를 `=`로 바꾸면 HTML이 아닌 일반 텍스트로 브라우저에 구문 분석된다.
      - 브라우저는 위 스크립트를 실행하지 않게 된다.
      - 다른 템플릿 엔진을 사용하는 경우 모든 엔진에는 일반적으로 이스케이프 태그가 있고 출력하기 전에 항상 해당 사용자 생성 콘텐츠를 이스케이프해야 한다.
    - 두 번째. 사용자 입력을 삭제하는 방법
      - 정리한다는 것을 의미한다.
      - 컨텐츠를 살펴보고 그 컨텐츠에서 위험한 것을 제거한다는 것을 의미한다.
      - 그리고 사용자 컨텐츠를 살펴보고 정리를 시도하는 고유한 코드를 작성할 수 있지만 대부분의 경우 타사 패키지를 다시 사용하는 것이 더 편리하다.
    - xss 패키지

      - `npm install xss`
      - 스크립트 텍스트와 같은 특정 컨텐츠를 제거한다.
      - 사용자 생성 컨텐츠를 수신하는 경우 그 함수 호출을 xss로 래핑할 수 있다.
      - xss 함수를 넣으면 xss 함수가 이를 삭제하고 정리한 다음 깨끗한 값을 반환한다.
      - 정리된 값은 DB에 저장된다.
      - ex) `text: xss(req.body.comment)`

      ```
      // discussion.js

      const xss = require("xss");

      router.post("/discussion/comment", async function (req, res) {
        const comment = {
          text: xss(req.body.comment),
        };

        await db.getDb().collection("comments").insertOne(comment);

        res.redirect("/discussion");
      });
      ```

- SQL 주입 공격

  - ex) `Jeong"; DROP TABLE comments; SELECT * FROM comments WHERE author = "manu`
  - 위 예시처럼 작성하면 기존의 테이블이 삭제되버린다.
  - 보호 방법
    - 사용자 입력을 받지 않고 대신 이스케이프 처리해야한다.
    - 사용자 입력에 이스케이프를 사용하는 것
    - 템플릿 문자열 기능을 사용하지 않고, `"${req.query.author}"` 이와 같이 값을 삽입했다.
    - 대신 값을 삽입하기 위해 `?`를 사용해왔다. 그리고 항상 `?`를 사용해야 한다.
      - `"INSERT INTO comments (author, text) VALUES (?)"`
    - 그렇게하면 해당 물음표에 관해 배치될 값이 MySQL 패키지에 의해 자동으로 이스케이프 처리되기 때문이다.
    - 물음표를 사용하고 MySQL 패키지가 실제 값을 쿼리에 삽입하도록 하면 위의 테이블 삭제 문제가 발생하지 않는다.
    - 쿼리에 값을 추가할 때는 항상 `?`를 사용해야 한다.
    - MySQL 패키지에는 또 다른 보호 단계가 있다.
      - `multipleStatements: true`
      - 위 값은 기본값이 아니다. 기본값은 `false`이다.
      - 이 값이 `false`일 경우 (기본 값 설정한 경우) 한 번에 여러 SQL 문을 실행하려고 한다면 위의 접근 방식을 사용해도 물음표 없이 MySQL 패키지가 차단한다.
      - 한 번에 둘 이상의 SQL문을 실행하지 않기 때문이다.
      - ex) `WHERE author = ?`; // Jeong"; DROP TABLE comments; SELECT \* FROM comments WHERE author = "manu
        - WHERE author = ?`; // Jeong" <- 하나의 SQL문은 이름으로 작성자를 선택하는 것
        - DROP TABLE comments <- 이게 두 번째 명령문이 된다.
    - 쿼리당 하나의 명령문을 사용하는 기본값을 고수하는게 좋다.
    - 구체적인 값으로 대체되어야 하는 자리표시자를 표시하기 위해 `?`를 사용하는 것
    - 그러면 해당 값이 이스케이프 처리되고 SQL 주입으로부터 보호할 수 있기 때문이다.

  <br />

- NoSQL 주입 공격

  - 이건 다루기 조금 어렵다.
  - 기본적으로 NoSQL 주입에 대한 보호 기능이 상당히 뛰어나고 특히 노드 및 몽고DB로 작업할 때 취약점을 노출하기 위해 서버 측에서 고급 NoSQL 코드를 작성해야 하기 때문이다.
  - 노드JS 몽고DB 코드가 서버 측에서 조금 더 발전된 경우 NoSQL 주입이 문제가 될 수 있다.
  - 하지만 기본적으로 기본적인 NoSQL 및 몽고DB 쿼리로 작업하는 경우 대부분의 웹 사이트에서 수행할 것이기 때문에 기본적으로 강력한 보호 기능을 사용할 수 있다.
  - NoSQL 주입 공격은 `node mysql injection` 검색

  <br />

- 보안 (Security)에 대해 핵심 사항 정리

  - 사용자, 특히 사용자의 입력을 절대 신뢰해서는 안된다.
  - 입력을 처리하거나 저장하기 전에 해당 입력을 삭제하거나 정리해야 한다.
  - 또는 그 입력을 이스케이프 해야 한다.
  - 반대의 경우가 아니라면 이스케이프 처리된 컨텐츠만 출력해야 한다.
  - 그리고 어떤 이유로든 원시 컨텐츠를 출력해야 하는 경우 삭제하기는 이스케이프 처리 대신 수행할 수 있는 추가 단계이다.
  - 하지만 사용자 입력으로 작업할 때는 항상 주의해야 하고 타사 라이브러리를 사용해야 한다.
  - CSRF 공격
    - CSRF 토큰을 페이지의 모든 양식에 추가해줘야한다.
    - 이 토큰은 타사 패키지에서 생성할 수 있다.
    - 그리고 그건 내 서버에만 알려져있다.
    - 하나의 요청 응답 주기에만 유효하며 다른 페이지에서 추측될 수 없다.
    - 따라서 모든 양식에서 이러한 토큰을 포함하면 나의 사이트처럼 보일 수 있는 가짜 사이트에서 서버에 관한 요청을 보낼 수 없다.
    - ex) `<input type="hidden" value="<%= csrfToken %>" name="_csrf">` 이렇게 추가

  <br />

- 개발자로서 백엔드 코드를 작성할 때 저지를 수 있는 실수

  - 정적으로 제공되어서는 안되는 폴더를 정적으로 제공하는 것
    - 공개적으로 액세스할 수 없는 데이터나 파일을 그 안에 넣어서는 안된다. (ex. public 폴더 안에)
    - 사용자 데이터를 텍스트나 json 파일로 저장해서는 안된다. 거기에 암호 파일을 저장해서도 안된다.
    - 공용 폴더에는 공용이 액세스할 수 있는 파일만 있어야한다.
    - 또 다른 예로 `app.use(express.static(''))` 이렇게 전체 폴더를 정적으로 제공해서는 안된다.
    - 그렇게 되면 모든 파일에 액세스할 수 있고 사람들이 백엔드 코드를 읽을 수 있기 때문이다.
    - 이 것들이 파일을 정적으로 제공할 때 염두 해둬야하는 사항이다.
    - 따라서 컨텐츠를 정적으로 제공할 때 주의하고 잘못된 폴더를 정적으로 제공해선 안된다.
  - 실제로 방문자에게 원시 오류 메시지를 보낸다던가 하는 것
    - 백엔드 코드에서 문제가 발생할 때마다 이 오류를 어떻게든 처리하고 있는지 확인해야한다.
    - 예로 기본 익스프레스 오류 처리 기능을 사용하는 것처럼
    - 그러면 표준화된 오류 메시지나 페이지를 사용자에게 다시 보낼 수 있다.
    ```
    app.use(function(error, req, res, next) {
      console.log(error);
      res.render('500');
    })
    ```
  - 위 예시는 백엔드에서 오류를 올바르게 처리하지 못했기 때문일 수 있다.

<br />

# 오늘 느낀 점

- 오늘 보안에 대해 배우고 정리해보았는데 CSRF, XSS, SQL 주입 공격 등 종류도 다양하고 처리하는 방법도 다양했는데 CSRF는 사실상 스피싱과 다름이 없다고 생각이 된다. XSS, SQL 주입 공격은 개발에 대한 지식이 있지 않는 이상 일반 사용자는 발생할 수 없지만 CSRF는 특정 사이트에 대해 모방해서 만들어놓고 중간에 가로채 스피싱에 이용당할 수 있다고 생각이 된다. 물론 그렇다고 XSS, SQL 주입 공격을 무시해도 되는건 아니지만 실질적으로 사용자가 피해를 볼 수 있는건 CSRF라고 생각이 되며, 개발자가 피해를 볼 수 있는건 CSRF, XSS, SQL 주입 공격 등 모든 보안 관련해서는 개발자가 피해를 볼 수 있다고 생각이 된다.

- 일단 기본적으로 보안에 대해선 사용자의 입력을 믿어선 안되며 모든 변수 즉, 예외에 대해 생각하며 처리를 해놓아야한다고 생각한다. 사용자의 입력에 대해 이스케이프 해놓고 그 이스케이프 처리된 컨텐츠만 출력하며 원시 컨텐츠를 출력해야 한다면 삭제하기를 이용해 출력해야 한다. 항상 사용자의 입력을 주의해야하며 타사 라이브러리를 잘 활용해야한다. CSRF는 CSRF 토큰을 사용해 페이지의 모든 양식에 추가해 사전에 방지해야한다.

<br />

# 내일 할 일

- 100일 코딩 챌린지 계속 진행하기 (속도보단 복습과 꾸준한 연습으로 튼튼하게 다지기)

- ExpressJS에 대해 더 깊게 공부하기 (EJS와 함께)

- Advanced-js(고급 JS)에 대해 공부하며 이해하기

- multer 패키지 한번 더 자세히 들여다보기

- addEventListener 키워드 정리

- 세션 & 쿠키 부분 한번 더 다시보기
