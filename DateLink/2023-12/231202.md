# 오늘 한 일

### React 공부

- React 요약 및 핵심 기능 둘러보기

  - 양식 제출 처리
    - form에 onSubmit 이벤트 리스너 추가
    - PostList에 있는 입력 관련 state와 함수를 NewPost로 이동
      - post 목록을 동적으로 렌더링하는 방식으로 변경해야 함
    - onSubmit에 실행할 함수 추가
      - form이 전송되었을 때, 실행될 함수 추가
      - 다른 이벤트 핸들러 함수처럼 event 객체가 매개변수로 들어온다.
        - form이 전송되면 브라우저는 자동으로 HTTP 요청을 만들어 전송한다.
        - 이 event 객체로 브라우저 기본 동작을 막아준다.
          - `event.preventDefault()`
      - 상수 하나를 추가해 객체로 구성해서 그 안에 form에서 입력된 값을 담는다.
      - form이 제출된 후에 모달 창이 닫히도록 onClose()를 마지막에 추가

  <br />

  - 이전 상태를 기반으로 상태 갱신하기
    - 데이터를 포스트 목록에 추가해 포스트를 하드코딩해 출력하지 않고, 동적으로 출력되게 만들 수 있을까?
      - 앞에서 배운 것들과 두 가지 새로운 개념을 응용하면 할 수 있다.
      - 포스트 데이터를 NewPost 컴포넌트에서 PostList 컴포넌트로 가져와야 한다.
        - 이건 상태 끌어올리기로 가능
      - PostList에서 포스트 목록의 state를 관리해야 한다.
        - 목록이 변경될 때마다 변경 사항을 화면에 반영할 수 있도록 해야 함
        - useState를 추가해서 초기 값은 배열로 지정해서 그 배열에 저장되도록 하면 된다.
      - state 업데이트 함수에서 이전 상태를 기반으로 상태를 갱신하도록 구성
    - 양식이 제출되고 그 데이터를 업데이트하는 함수
      - NewPost에서 전달 받을 postData를 매개변수로 추가
      - setPosts를 호출해서 posts 상태를 갱신
      - Post 객체를 만들어서 배열에 추가해야 한다.
    - setPosts 구성
      - 이전 상태를 기반으로 하기 위해선, 함수를 넘겨줘야 한다.
        - 이 함수는 setPosts를 호출할 때마다 React에 의해 자동으로 호출된다.
      - 해당 함수는 기본적으로 현재 상태의 스냅샷을 받는다.
        - 그걸 prevPosts로 받도록 구성
      - 새로운 상태 값을 반환해야 한다.
        ```
        setPosts((prevPosts) => {
          return [postData, ...prevPosts];
        });
        ```
        - 이 코드를 좀 더 줄일 수 있다.
          - `setPosts((prevPosts) => [postData, ...prevPosts]);`
    - 이전 상태를 바탕으로 새로운 상태를 만들 때는 함수 형태를 써서 상태를 업데이트해야 한다.
      - 이전 상태가 자동으로 들어오기 때문에 이를 받아 새로운 상태를 만들고 값으로 반환하면 된다.
      - 필요하다면 이전 상태를 전개해 사용할 수도 있다.
      - 상태가 꼭 배열이 아니더라도 이전 상태를 바탕으로 새 상태를 정의할 때면 언제든 쓸 수 있다.

  <br />

  - 목록 데이터 표시하기
    - Post 컴포넌트에 다른 배열의 항목을 출력하려면 동적 표현식이 필요하다.
      - posts 객체 배열을 JSX 요소 배열로 바꿔야 한다.
      - 하나의 포스트 객체를 하나의 Post 요소로 바꾸는 것
      - posts 배열은 순수한 JS 객체 배열인데 이걸 JSX 요소로 바꿔 JSX 코드에서 출력해야 한다.
    - 내장 메서드 map 사용
      - posts 배열에서 map 호출, map은 모든 JS 배열에서 사용 가능
      - map 메서드는 함수를 인자로 받는데, 이 함수를 브라우저가 배열의 모든 항목에 대해 실행해준다.
        - 각 항목을 받아 해당 항목과 매핑되어야 할 값을 반환해야 한다.
      - map으로 배열을 받아 해당 배열의 구 항목을 새 항목으로 바꿔 새로운 배열을 반환하는 방식
      ```
      {posts.map((post) => {
        return <Post post={post} />;
      })}
      ```
    - key props 추가
      - React의 요구사항으로 React가 목록을 효율적으로 갱신하고 렌더링하는 데 필요한 항목이다.
      - 배열을 JSX 요소 배열로 매핑해서 목록을 출력할 때는 "key"라는 특수 프로퍼티를 JSX 요소에 추가해야 한다.
      - key prop은 컴포넌트에서 받아 처리해야 하는 프로퍼티가 아니다.
      - React가 지원하는 특수한 내장 prop
      - key prop에 넣는 값은 각 Post마다 고유해야 한다.
        - 보통은 고유한 ID 값 같은 걸 넣겠지만, 여기서는 그냥 간단하게 Math.random을 사용해서 랜덤한 숫자가 id로 저장되도록 구성
    - 포스트가 없을 때, 메시지가 표시되도록 구성
      - 조건부 렌더링을 사용해서 posts.length가 0보다 크면 리스트를 렌더링
      - posts.length가 0과 같다면 입력한 메시지가 출력되도록 구성

  <br />

  - React SPA에 백엔드 추가하기
    - 현재 데이터가 로컬 메모리에만 저장되고 있기 때문에, 페이지를 다시 로드하면 포스트가 사라지고 다른 사용자는 볼 수가 없다.
      - 백엔드가 있다면 요청을 보내고 응답을 받을 수 있기 때문에, 거기에 DB를 두고 데이터를 저장할 수 있다.
    - 백엔드라는 건 서버에서 구동되는 별도의 웹 애플리케이션, 웹 API, REST API 같은 걸 말한다.
      - 사용자가 쓰는 브라우저가 아니라 내가 따로 관리하는 서버이다.
      - 백엔드 API, 즉 REST API는 내가 원하는 언어와 프레임워크로 구축할 수 있다.
        - 꼭 JS로 할 필요가 없다.
        - 그리고 백엔드에서는 React를 쓰지 않는다.
      - React는 "진짜" 백엔드 라이브러리가 아니다.
        - 진짜가 아니라는 건 NextJS나 Remix 같은 프레임워크를 React 맨 윗단에 얹어 백엔드 코드와 섞어 React 앱에서 쓸 수 있기 때문이다.
        - React 자체는 백엔드 라이브러리가 아니다.
        - React는 반응형 UI를 구축하기 위한 언어이다.
    - 백엔드 API를 사용해 백엔드 서비스와 파일 또는 DB 같은 것들이 데이터를 주고 받을 것이다.
      - 프론트엔드 애플리케이션인 React 앱은 백엔드로 HTTP 요청을 보내 데이터를 저장하거나 백엔드로부터 데이터를 가져올 수 있다.
      - 이 경우 데이터는 HTTP 응답을 통해 프론트엔드로 반환된다.
    - 첨부 파일 링크 내용
      - 테스트용 백엔드 프로젝트가 있다.
      - REST API가 NodeJS와 ExpressJS로 구현되어 있다.
      - 여기에는 React 코드가 없다.
      - 현재 이 백엔드 API는 이미 완성된 상태
      - 백엔드 API를 사용해서 약간의 데이터를 posts.json 파일에 저장할 예정
        - DB를 쓸 수도 있지만, DB를 사용하기 위해선 추가 설정 작업이 필요해서 데모에서는 그냥 json 파일에 저장할 예정이다.
        - json 파일에 데이터를 저장하고, 다시 가져오는 작업을 해볼 것이다.
      - 다양한 REST API 엔드포인트를 추가해뒀다.
        - post 하나만 가져오는 것도 있고, 포스트를 생성하는 것도 있다.
        - 각각의 작업을 수행하는 로직도 API에 추가해뒀다.
    - 백엔드 서버를 로컬에서 실행해 데모에서 사용하려면, 관련된 코드를 프론트엔드 쪽인 React 애플리레이션에 추가해 백엔드에 접근할 수 있게 만들어야 한다.
      - 가능하다면 백엔드를 서버 장치 두 대에 놓고, 도메인에 분리하겠지만 여기서는 둘 다 로컬 장치에서 실행하고 포트만 다르게 해, 서로 다른 서버와 도메인처럼 작동하게 만들 예정
    - 백엔드 애플리케이션은 8080 포트를 수신한다.
    - 백엔드에서 npm install로 필요한 의존성을 설치하고, npm start로 실행해 노드 서버를 구동해야 함
      - 프론트엔드의 개발 서버처럼 백엔드 쪽으로 요청을 보내려면 백엔드 서버를 구동 상태로 유지해야 한다.

  <br >

  - POST HTTP 요청 보내기
    - NewPost에서 submitHandler가 트리거 됐을 때, onAddPost를 호출하고 수집한 post 데이터를 NewPost의 부모 컴포넌트에게 넘겨준다.
      - 여기서 부모 컴포넌트는 PostList 컴포넌트
    - NewPost 컴포넌트에서 onAddPost를 통해 addPostHandler가 실행되면 addPostHandler 함수 안에서 로컬에 있는 posts의 상태를 갱신한다.
      - 로컬에도 posts 상태가 있어야 한다.
      - post를 렌더링할 때 필요하다.
      - 하지만 백엔드에도 데이터를 보내야 한다.
    - 요청은 백엔드 코드 API 라우트에서 처리한다.
      ```
      app.post("/posts", async (req, res) => {
        const existingPosts = await getStoredPosts();
        const postData = req.body;
        const newPost = {
          ...postData,
          id: Math.random().toString(),
        };
        const updatedPosts = [newPost, ...existingPosts];
        await storePosts(updatedPosts);
        res.status(201).json({ message: "Stored new post.", post: newPost });
      });
      ```
      - 이러한 코드가 처리
      - POST 요청을 백엔드의 이 경로로 보내면 데이터가 이런 형태로 구성되어 posts.json 파일에 저장된다.
        - 가짜로 만든 고유 ID와 함께 저장됨
      - 이 경로로 요청을 보내야 한다.
    - 요청을 보내는 방법
      - Fetch API를 사용해야 한다.
        - fetch()는 브라우저에서 기본으로 지원하는 함수
        - React의 기능이 아님
        - fetch()는 HTTP 요청을 보낼 때 사용
        - 이름과 다르게 데이터를 가져오는 것뿐만 아니라 보내는 것도 가능하다.
      - fetch() 구성
        - 요청을 전송할 URL을 인자로 넣는다.
          - `fetch("http://localhost:8080/posts")`
          - localhost는 백엔드가 로컬 장치에서 실행 중이라는 뜻이고, 8080은 백엔드가 수신하고 있는 포트 번호이다. 그리고 /posts는 백엔드에 작성된 /posts 경로로 POST 요청을 보내야 새 포스트를 posts.json 파일에 저장할 수 있다.
          - 해당 URL 또는 도메인으로 요청을 전송
        - 요청에 또 다른 설정
          - fetch API의 기본 요청은 "GET"이기 때문에 두 번째 인자를 객체 형태로 만들고, method 필드에 "POST"를 넣어 POST 요청으로 바꿔야 한다.
          - 객체에 body 필드도 추가해 요청에 담아 보낼 데이터를 넣어야 한다.
            - 보낼 데이터는 postData
          - postData를 JSON으로 변환
            - JSON 포맷으로 바꾸는 건, 내장된 JSON 객체의 stringify() 메서드로 할 수 있다.
            - `JSON.stringify(postData)`
            - 위와 같이 구성하면 데이터가 JSON 포맷으로 변환된다.
          - 마지막으로 객체에 headers 필드를 추가해 발신 요청 헤더를 설정해야 한다.
            - `{"Content-Type": "application/json"}`
        ```
        fetch("http://localhost:8080/posts", {
          method: "POST",
          body: JSON.stringify(postData),
          headers: { "Content-Type": "application/json" },
        });
        ```
      - 위 예시처럼 POST 요청을 만들고 post 데이터를 담아 더미 백엔드의 경로로 보낸다.
    - fetch()가 요청을 보내면 백엔드의 API 라우트, 즉 API 리소스로 오게 된다.
      - API 리소스로 오게 되면 백엔드 쪽에서 응답을 보낸다.
      - 현재는 응답에 관심이 없기 때문에 현재 상태로 저장
    - 구성을 추가한 상태로 새로운 post를 추가해보면 여전히 로컬에서 동작한다.
      - posts 상태 갱신은 그대로이기 때문이다.
      - 백엔드 쪽에서 posts.json 파일을 확인해보면 포스트 정보가 저장된 것을 확인할 수 있다.
        - 백엔드에서 정보를 받아 파일에 저장된 것이다.

  <br />

  - useEffect()로 부수효과 처리하기
    - PostList에서 fetch 작업
      - 이전과 동일한 URL을 보낸다.
      - GET은 fetch의 기본 요청이기 때문에 따로 설정할 게 없다.
    - 요청에 대한 응답을 받아 posts를 업데이트해야 한다.
      - 보통 async-await를 사용해 처리
      - 하지만 여기서는 쓸 수 없다.
      - 컴포넌트 함수는 반드시 JSX 코드나 다른 값을 반환해야 한다.
        - promise를 반환하면 안된다.
        - 기본 컴포넌트에서는 불가능
    - 함수 앞에 async를 붙이면 모든 값을 프로미스 객체로 반환한다.
      - 함수에서 반환되는 모든 데이터가 promise로 래핑되기 때문에 함수 앞에 async를 붙여서도 안 되고, await를 쓸 수도 없다.
    - 표준에 가까운 구식 방법으로 응답을 처리할 수 있다.
      - then() 메서드를 추가해 응답을 받은 다음 response.json()을 호출해 응답으로부터 데이터 압축을 해제한다.
      - json 메서드로 응답에서 서버가 돌려보내면 데이터만 추출할 수 있다.
      - 서버가 돌려보낸 데이터는 객체 형태로 posts 라는 필드에 가져온 포스트를 모두 담고 있다.
      - then 블록을 하나 더 추가해서 data.posts를 가져온다.
        - setPosts를 호출해 posts를 data.posts로 설정해야 한다.
      - 하지만 코드를 이렇게 구성하면 안된다.
        - 코드를 이렇게 작성하면 이론적으로는 posts 상태가 새로운 포스트로 갱신된다.
        - 하지만 무한 루프가 발생한다.
    - 무한 루프가 발생하는 이유는 state를 갱신하면 컴포넌트 함수가 React에 의해 다시 실행된다.
      - React 핵심 개념 중 하나
      - 컴포넌트 함수가 다시 실행되면 fetch 요청도 다시 전송된다.
      - 이렇게 되면 또 요청을 보내고, 데이터를 받아 state를 갱신하고 같은 동작을 반복하게 된다.
      - 이 문제는 흔히 발생하는 문제이기 때문에 또 다른 React Hook을 사용하면 된다.
        - 이 Hook은 이런 문제를 해결하기 위해 컴포넌트 함수에서 부수 효과를 적절하게 일으키고 싶을 때 사용하는 Hook이다.
        - 수행하려는 동작이 JSX 코드에 직접적인 영향을 주지 않고, 나중에 간접적으로 영향을 주는 경우나 UI 렌더링과 관련없는 다른 작업을 하는 경우에 사용한다.
        - 바로 useEffect Hook
    - useEffect Hook
      - 부수 효과를 래핑하는 데 사용된다.
      - useEffect를 사용해서 위에서 설명한 코드를 무한 루프 없이 실행할 수 있다.
      - useState와 달리 값을 반환하지 않는다.
        - 대신 함수를 값으로 받는다.
      - 두 번째 인자로 배열을 받는다.
      - useEffect는 두 개의 인자로, 함수와 배열을 넘겨야 한다.
      - 여기서 함수는 React에 의해 실행되는데 이 효과가 실행되어야 한다고 판단되면 알아서 실행된다.
        - 두 번째 인자에 있는 배열과 관련이 있다.
    - useEffect Hook 구성
      - 함수 인자 구성
        - 앞에서 작업한 fecth 내용을 넣고, 함수로 감싸준다.
        - 감싸준 함수는 비동기 함수
          - 효과 함수 안에 정의되어 있기 때문이다.
        - fetch 내용은 await를 사용해서 응답을 받는다.
        - 응답 데이터를 추출할 때도 await를 사용
        ```
        const fetchPosts = async () => {
          const response = await fetch("http://localhost:8080/posts");
          const resData = await response.json();
          setPosts(resData.posts);
        };
        ```
      - 효과 함수 자체를 비동기 함수로 바꾸지는 않는다.
        - useEffect가 인자로 받는 함수에서는 프로미스를 반환하면 안된다.
        - 아무것도 반환하지 않거나 클린업 함수만 반환해야 한다.
    - useEffect 함수는 어떻게 동작하길래 무한 루프가 발생하지 않는가 ?
      - 효과 함수가 컴포넌트 함수가 실행될 때마다 함께 실행되지 않도록 해줌으로써 무한 루프 발생을 막아준다.
        - 물론 가끔씩은 컴포넌트 함수와 함께 실행된다.
        - 그렇지 않으면 포스트를 가져온 수 없다.
        - 하지만 매번은 아니다.
      - 정확히 언제 실행될까?
        - useEffect에 전달하는 두 번째 인자로 결정된다.
        - 배열에는 효과 함수를 실행할 의존성을 정의한다.
          - 의존성에는 변수든 함수든 효과 함수 바깥에 정의된 거라면 뭐든 쓸 수 있다.
          - React 컴포넌트에 있는 거면 이 컴포넌트에 있든 props를 통해 받은 부모 컴포넌트에 있든 상관 없다.
        - 효과 함수 밖에 있는 변수 또는 함수가 변경될 때마다 변경된 값을 받아서 효과 함수를 다시 실행한다.
        - 빈 배열을 넣으면 함수에는 의존성이 없다는 뜻이기 때문에 효과 함수는 두 번 실행되지 않는다.
          - React는 효과 함수를 단 한 번 실행하는데, 컴포넌트가 처음 렌더링될 때 실행된다.
          - 정확히 말하면 컴포넌트가 처음 렌더링된 직후에 실행된다.
        - 순서대로 보면, 처음에 포스트 없이 컴포넌트가 렌더링되고, 그 직후에 효과 함수가 실행되면서 포스트가 업데이트된다.
          - 이 과정이 너무 빨라서 포스트를 가져온 뒤의 상황만 볼 수 있는 것이다.

  <br />

  - 로딩 상태 관리
    - 요청을 보내 데이터를 가져오거나 저장하는 데 시간이 좀 걸리는 경우가 있다.
      - 시간이 좀 걸리는 상황을 백엔드 코드에서 재현
      - 백엔드 코드에 있는 내용을 주석 해제
        - `await new Promise((resolve, reject) => setTimeout(() => resolve(), 1500));`
        - 딜레이를 추가하는 코드로, 실제로는 추가할 일이 없지만 여기서는 테스트해보기 위해 추가
    - 딜레이 코드를 포함한 상태에서 테스트 해보면, 포스트가 없다는 메시지에서 갑자기 포스트가 보인다.
      - 이건 이상적인 동작이라고 할 수 없다.
      - 사용자는 정확한 원인을 알 수 없기 때문이다.
      - 이렇게 하는 대신, 로딩 문구나 로딩 스피너 같은 걸 사용자가 기다리는 동안 표시해 둘을 구분해야 한다.
        - 정말 데이터가 없는 경우와 데이터를 가져오기 위해 기다리고 있는 경우
    - PostList 컴포넌트에 새로운 state 추가
      - 초기 값은 false
        - `const [isFetching, setIsFetching] = useState(false);`
      - 포스트를 가져오기 시작할 때 true로 설정했다가, 가져온 다음 false로 바뀌도록 해준다.
      ```
      const fetchPosts = async () => {
        setIsFetching(true);
        const response = await fetch("http://localhost:8080/posts");
        const resData = await response.json();
        setPosts(resData.posts);
        setIsFetching(false);
      };
      ```
      - 이렇게 하면 isFetching 상태로 데이터를 가져오는 동안 사용자에게 다른 UI를 표시할 수 있다.
    - JSX 코드에서 대체 문구를 추가
      ```
      {isFetching && (
        <div style={{ textAlign: "center", color: "white" }}>
          <p>Loading posts...</p>
        </div>
      )}
      ```
    - 포스트가 없다는 메시지를 표시하는 것보다 이렇게 변경해주는 것이 더 나은 UX를 제공한다.
      - 데이터를 가져올 때 이런 방법을 사용하면 더 나은 앱을 만들 수 있다.

# 오늘 느낀 점

- 이제 백엔드와 연결해서 작업을 진행하는데 아직까지는 비교적 쉬운 내용이라고 생각이 된다. 이 뒤에 라우트를 추가하고, 라우팅 개념 그리고 loader, action 내용에서 조금 더 복잡해질 텐데 이 내용은 더 중요하다고 생각이 되기 때문에 제대로 복습하고 갈 생각이다. 내용을 요약해서 부족할 수도 있지만 앞에서 나는 쭉 전체 코스를 통해 배웠기 때문에 요약으로 복습하는 것도 많이 도움이 된다고 생각한다. 그리고 세부적인 내용을 복습하는 것도 도움이 되겠지만, 좀 더 효율적으로 요약된 내용으로 복습하는 것도 시간적인 부분에서 도움이 된다고 생각한다. 남은 부분도 빠르게 마무리를 지어보고 개인 프로젝트를 시작해봐야 할 것 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
