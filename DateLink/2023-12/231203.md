# 오늘 한 일

### React 공부

- React 요약 및 핵심 기능 둘러보기

  - 라우팅 개념 설명 및 라우팅 기능 추가
    - 아주 간단한 데모 앱 같은 걸 제외한 대부분의 앱에는 라우팅이 필요하다.
    - 라우팅 정의
      - 라우팅은 간단히 말해 여러 경로를 정의해 여러 페이지를 로드하고 해당 경로에서 다른 컴포넌트를 로드하기 위해 사용한다.
    - 현재 데모 앱은 경로가 하나 뿐이다.
      - 새 포스트 버튼을 클릭해도 위에 나오는 경로는 URL은 그대로 유지된다.
      - 경로가 하나 일 때, 단점은 다른 사용자에게 작성 창 링크를 줄 수 없다.
      - 누군가 새 포스트를 바로 작성할 수 있도록 화면의 링크를 보내고, URL을 복사해서 전달하고 주소를 넣고 엔터를 쳐도 시작 화면으로 돌아온다.
      - 현재 만들고 있는 데모 앱은 SPA이기 때문이다.
        - 그래서 하나의 페이지 하나의 HTML 파일만 있다.
    - 라우팅 개념에서는 다양한 경로를 지원할 수 있다.
      - 단순히 앱 실행 중에 URL 변경을 감지하거나 URL이 처음에 로드될 때 확인하는 방식으로 가능
      - 해당 URL에 인코딩된 여러 경로에서 다른 컴포넌트를 로드
      - "도메인 주소/"로 접속하면 시작 페이지를 로딩, /products로 접속하면 제품 페이지를 로딩하고 그런 식으로 가능
        - 이것이 라우팅
    - React 앱이 SPA로 만들어져 있더라도 라우팅 동작을 구현할 수 있다.
      - React router 패키지를 사용하면 된다.
        - React에서 가장 흔히 사용되는 라우팅 패키지이다.
      - React에는 라우팅 기능이 내장되어 있지 않기 때문에 직접 해결책을 구현해야 한다.
        - URL 페이지를 직접 보고 경로를 추출해서 다른 경로에 있는 다른 컴포넌트를 로드해야 한다.
      - React router는 아주 강력한 패키지로 위의 문제를 모두 해결해주며 라우팅과 관련된 다양한 기능을 제공한다.
    - React router 버전
      - 이 패키지에는 다양한 버전이 있다.
        - 버전 5.0은 아직도 널리 사용되지만, 버전 6.0은 5.0과 비교했을 때 동작이 많이 다르다.
        - 버전 6.0에서 달라진 점을 소개하기 위해 별도 강의도 있다.
      - 버전 6.4에는 React router와 관련된 기능이 더 많이 추가되었다.
        - 이 강의는 가장 최근에 나온 패키지에 대해서 알아보는 강의
    - React router 패키지 설치
      - `npm install react-router-dom`
      - 이 패키지를 설치해야 프론트엔드 애플리케이션에서 React router를 사용할 수 있다.
    - 라우팅은 클라이언트 쪽에서 작업하는 것이다.
      - 프론트엔드에서 작업해야 함
      - 백엔드 쪽이 아니다.
      - 프론트엔드 쪽에서도 다양한 경로를 정의해 해당 경로에서 다양한 컴포넌트를 로드할 수 있다.

  <br />

  - 라우트 추가하기
    - 총 3개 라우트로 구성
      - 시작 페이지, 새 포스트 페이지, 상세 페이지
    - main.jsx
      - react router dom에서 RouterProvider import
      - App 컴포넌트 대신 RouterProvider 컴포넌트 사용
        - RouterProvider 컴포넌트는 라우팅을 활성화하고 React router에게 URL을 확인해 다른 경로에 있는 다른 컴포넌트를 렌더링하라고 명령한다.
        - 이걸 추가하는 것만으로는 동작하지 않는다.
      - react router에서 어느 경로에서 어떤 컴포넌트를 로드할 건지 알려줘야 한다.
        - router 설정을 해야 한다.
      - RouterProvider에 router 속성에 라우트 설정 객체를 값으로 넣어줘야 한다.
        - 설정 객체는 react router dom이 제공하는 함수로 만들 수 있다.
          - createBrowserRouter() 함수
        - createBrowserRouter 함수를 호출해 라우트 설정 객체를 만들고 객체를 변수에 저장해 설정 객체 값을 RouterProvider의 router 속성 값으로 넘겨준다.
          - `const router = createBrowserRouter()`
          - `<RouterProvider router={router} />`
      - createBrowserRouter 함수
        - 배열을 인자로 받는다.
        - 배열에 필요한 라우트를 모두 추가
          - 라우트 정의 목록
          - 라우트 정의는 객체 형태로 하면 된다.
        - 라우트 정의
          - 일반적으로 path 속성이 있는데, 여기에 단일 라우트 경로를 정의한다.
          - 여러 객체를 추가할 수 있고, 각 객체가 하나의 라우트 하나의 경로 그리고 해당 경로에서 로드해야 할 컴포넌트를 의미한다.
      - 라우트 정의 세부 내용
        - path
          - 경로 정의
          - `{path: "/"}`
        - element
          - 라우트가 활성화됐을 때 화면에 렌더링할 JSX 코드를 정의
          - 해당 경로에서 렌더링할 요소를 정의
          - `{path: "/", element: <App />}`
        - 다른 라우트 또한 위와 같이 만들어주면 된다.
          - `{path: "/create-post", element: <NewPost />}`
            - NewPost 컴포넌트 페이지가 잘 나오긴 하지만, 모달 형태가 아니고, 앱의 나머지 부분도 사라졌고 포스트 작성도 되지 않는다.
            - 전송과 관련된 속성값이 들어오지 않아서 이런 문제가 발생
            - NewPost 컴포넌트를 사용하면서 속성 값을 설정하지 않아서 그렇다.
            - 이 문제는 다음 강의에서 레이아웃 라우트로 해결할 예정

  <br />

  - 레이아웃 라우트 사용법
    - 라우팅을 사용해 복잡한 React 앱을 만들다 보면 라우트끼리 레이아웃 요소를 공유해야 할 때가 있다.
      - 메인 네비게이션 바는 내가 만든 모든 라우트에서 표시되어야 한다.
      - 이렇게 만들려면 "레이아웃 라우트"를 사용해야 한다.
    - 레이아웃 라우트
      - 일반적인 라우트와 비슷하지만 내부에 다른 라우트를 품고 있는 라우트이다.
      - 레이아웃 라우트를 추가하려면 라우트를 추가로 정의해야 한다.
        - 배열에서의 위치는 크게 상관없지만, 첫 번째 라우트로 추가
      - 레이아웃 라우트에 경로도 "/"
        - 경로에 상관없이 모든 라우트를 래핑하는 레아아웃을 만들 것이기 때문이다.
      - 레이아웃 라우트에 element 속성 추가
        - 새로운 컴포넌트를 넣어준다.
        - 그 전에 "routes"라는 폴더를 새로 만들어 새 컴포넌트를 정리
          - 라우트로 사용되는 컴포넌트는 routes 폴더에 넣고 다른 곳에 사용되는 컴포넌트들은 components 폴더에 둔다.
          - 꼭 필요한 작업은 아니지만, 이렇게 하면 이해하기도 쉽고 관리하기도 쉽다.
          - 해당 폴더에 RootLayout.jsx 파일 추가
            - 일반적인 컴포넌트 함수로 구성하고 MainHeader 컴포넌트 추가
            - 나머지는 다른 작업을 하고 추가
        - 레이아웃 라우트라는 건 다른 라우트들을 감싸는 라우트이기 때문에 MainHeader는 공유되고 다른 라우트가 가진 콘텐츠는 MainHeader 컴포넌트 밑에 렌더링된다.
        - element 속성에 RootLayout 컴포넌트 추가
          - `{path: "/", element: <RootLayout />}`
      - 레이아웃 라우트에 children 속성 추가
        - children 속성은 값으로 배열을 받는다.
          - 배열에는 다른 라우트를 정의한 객체를 넣는다.
        - 앞에서 정의한 라우트 두 개를 RootLayout 라우트 안으로 옮긴다.
          - RootLayout 라우트의 정의가 넣어준 두 라우트의 레이아웃 라우트로 바뀐다.
          - 두 라우트는 이제 바깥에 있는 라우트에 중첩되어 있기 때문에 RootLayout 라우트가 제공하는 레이아웃을 공유한다.
          - 두 라우트는 RootLayout 컴포넌트로 들어오게 되고, 안에 있는 MainHeader를 공유한다.
        ```
        {
          path: "/",
          element: <RootLayout />,
          children: [
            { path: "/", element: <App /> },
            { path: "/create-post", element: <NewPost /> },
          ],
        },
        ```
    - 코드를 저장하고 앱으로 가면 헤더는 보이지만 콘텐츠는 보이지 않는다.
      - 새 포스트 작성 버튼도 작동하지 않는다.
      - 콘텐츠가 나오지 않는 이유는 MainHeader 컴포넌트를 공유하고 있긴 하지만 React route에게 중첩된 라우트의 콘텐츠를 렌더링할 위치를 알려주지 않았기 때문이다.
        - 표시할 위치를 알려줘야 한다.
    - RootLayout.jsx에서 표시할 위치 지정
      - Outlet 컴포넌트를 react router dom에서 가져온다.
        - 이건 react router 패키지가 제공하는 특별한 컴포넌트
      - Outlet 컴포넌트를 중첩된 라우트가 가진 실제 콘텐츠가 렌더링 되고 삽입되어야 할 위치에 사용한다.
        - RootLayout에서 Outlet 컴포넌트를 사용해 중첩 라우트의 콘텐츠를 렌더링할 위치를 표시한다.
      ```
      const RootLayout = () => {
        return (
          <>
            <MainHeader />
            <Outlet />
          </>
        );
      };
      ```

  <br>

  - 라우트 컴포넌트 리팩토링 및 중첩 라우트 추가
    - App 컴포넌트를 별도 라우트로 분리하는 작업
      - App 컴포넌트는 이제 라우트에서 로딩되기 때문에 routes 폴더로 옮긴다.
      - App.jsx에서 Posts.jsx로 변경
      - 이 컴포넌트의 궁극적인 역할이 포스트 목록을 렌더링하는 것이기 때문이다.
    - Posts.jsx 내용 변경
      - MainHeader 컴포넌트 삭제
      - 함수 이름도 변경하고 내보내는 이름도 변경
      - show, hide 함수도 삭제
      - PostList 속성 부분과 상태 정의도 삭제
        - PostList와 관련된 전체 로직과 동작 방식을 변경할 것이기 때문이다.
    - NewPost 컴포넌트 리팩토링
      - NewPost 컴포넌트와 스타일 파일을 routes 폴더로 옮긴다.
        - 해당 컴포넌트도 라우트에서 로딩되기 때문이다.
      - NewPost 컴포넌트는 모달을 로드해야 한다.
        - NewPost 컴포넌트 안에서 Modal 컴포넌트를 사용
        - form을 Modal 컴포넌트로 래핑
    - PostList 컴포넌트 리팩토링
      - 이제 포스트 추가 작업을 처리하지 않는다.
        - 이 작업은 NewPost 컴포넌트가 맡아서 처리한다.
      - PostList 컴포넌트에서는 포스트 추가 작업 관련 코드 삭제
        - Modal에 NewPost 컴포넌트를 렌더링하는 부분 삭제
        - 프로퍼티로 들어오는 내용도 삭제
        - 필요 없는 import 두 개도 삭제
        - addPostHandler 함수도 필요 없지만, 잠시 남겨놓는다.
    - 수정한 내용을 확인하기 위해 주소창에서 /create-post를 입력하고 확인
      - form이 오버레이로 스타일로 열리는 것을 확인
        - 하지만 포스트 목록 위에 표시되지는 않고 있다.
      - 목록 위에 표시하려면 Posts 컴포넌트 자체를 레이아웃 컴포넌트로 바꿔야 한다.
      - Posts 컴포넌트에 측면 메뉴 바, 메인 메뉴 바 같은 건 없지만 여전히 요소를 가지고 있고 NewPost 컴포넌트에도 필요한 요소이다.
        - 포스트 목록이 필요
    - main.jsx에서 내용 추가
      - Posts 컴포넌트에서 children 프로퍼티를 추가
      - children 배열에 "/create-post" 경로를 자식 컴포넌트로 추가
        - 이렇게 하면 NewPost 컴포넌트가 Posts 라우트의 자식 라우트가 된다.
      ```
      {
        path: "/",
        element: <RootLayout />,
        children: [
          {
            path: "/",
            element: <Posts />,
            children: [{ path: "/create-post", element: <NewPost /> }],
          },
        ],
      }
      ```
      - 중첩된 레이아웃이 생겼는데, 위처럼 설정하면 새 포스트 모달 창을 포스트 목록 위에 표시할 수 있다.
    - 포스트 목록 위에 새 포스트 모달 창이 뜰 수 있도록 Posts.jsx에서 내용 추가
      - Outlet 컴포넌트 추가
        - main 섹션 위에 Outlet 추가
      - Posts도 레이아웃 라우트라고 할 수 있게 된다.
    - 라우트를 중첩하면 form이 포스트 목록 위에 팝업 창처럼 열리도록 할 수 있다.

  <br />

  - 경로 연결 및 경로 탐색

    - 두 라우트의 연결 장치를 만들어줘야 새 포스트 버튼으로 NewPost 모달을 열 수 있다.
    - MainHeader 컴포넌트 내용 변경
      - 버튼을 링크로 바꿔서 "/create-post" 라우트와 연결해야 한다.
      - button을 a 요소로 바꿔준다.
        - 추가로 onClick 핸들러와 사용하지 않는 프로퍼티 삭제
        - href 속성을 추가하고 "/create-post"와 연결
    - 변경한 내용으로 확인해보면 잘 되는 것처럼 보이지만, 실제로는 새로고침되면서 완전한 새로운 요청을 React 앱의 서버 쪽으로 보냈다는 뜻이다.
      - React 앱 전체를 다시 다운로드해서 또 하나의 새로운 앱 인스턴스를 시작한 것이다.
      - 새로고침 버튼을 눌렀을 때 일어나는 동작과 같다.
      - 동작하긴 하지만 SPA에서 이런 식으로 페이지를 다시 로드하면 전역으로 관리하던 상태를 모두 잃게 되고 모든 JS 코드를 다시 다운로드하고, 그 코드를 전부 다시 실행하기 때문에 성능에도 악영향을 준다.
    - 동일한 SPA에서 React 앱을 서비스하는 서버에 새로운 요청을 보내지 않고도 URL을 변경하고, 새로운 컴포넌트를 로드할 방법이 필요하다.
      - 이 경우 흔히 사용하는 방법은 Link 컴포넌트를 사용한다.
    - MainHeader 컴포넌트 내용 변경 2
      - Link 컴포넌트
        - react router dom에서 가져와서 사용할 수 있다.
        - Link도 내부적으로 앵커 요소를 렌더링하지만, Link는 브라우저가 자동으로 요청을 전송하지 못하게 막아준다.
      - a 요소 대신 Link 컴포넌트 사용
        - href 속성이 아닌, to 속성을 경로로 받는다.
          - 경로는 동일하게 /create-post로 하면 된다.
    - 변경하고 확인해보면 새 포스트 버튼을 누르면 페이지를 새로 로드하지 않는다.
      - 동일한 SPA에 존재하게 된다.
      - 이게 제공하려는 UX
    - Modal.jsx에서 백드롭 클릭, 취소 버튼으로 모달창이 닫히도록 해야 한다.
      - Modal에는 항상 래핑할 페이지가 있다고 가정하고, 라우트 안에서 Modal을 래퍼처럼 사용
      - Modal의 백드롭을 클릭하면 다른 라우트로 이동하게 만들어야 한다.
      - closeHandler 함수를 추가하는데 여기서는 프로그램적으로 경로를 이동시킨다.
        - 링크가 아니라 div 요소가 클릭됐을 때 페이지를 이동해야 한다.
      - div를 Link로 변경해도 되지만, 여기서는 div를 사용해 프로그램적으로 경로를 탐색하도록 구성
        - 가끔씩 코드를 써서 다른 경로로 이동해야 하는 경우가 있기 떄문에 이 방식을 사용
      - 프로그램적으로 경로를 이동하기 위해 useNavigate Hook import
        - react route dom에서 가져오는 Hook
      - useNavigate를 변수에 담아 함수처럼 실행
        - `const navigate = useNavigate()`
      - closeHandler에서 navigate 상수를 함수처럼 호출
        - closeHandler가 실행됐을 때 이동할 경로를 인자로 넘겨준다.
        - `const closeHandler = () => { navigate("/") };`
        - 좀 더 유연하게 상대 경로를 써서 `navigate("..")`도 가능하다.
          - 이렇게 사용하면 모달을 좀 더 동적으로 쓸 수 있다.
    - NewPost에서 취소 버튼으로 모달창이 닫히도록 구성
      - 코드를 써서 프로그램적으로 경로를 탐색해도 되지만, 여기서는 Link를 사용하는 것이 더 적절하다.
      - Link 컴포넌트를 사용하고, 이벤트 리스너는 삭제 그리고 to 프로퍼티를 통해 React route에게 Link가 클릭됐을 때 어디로 가야 하는지 알려준다.
        - 여기서도 ".."을 사용해 부모 라우트로 올라간다.

  <br />

  - loader()로 데이터 가져오기
    - 6.4 이상 버전의 React route에서 사용할 수 있는 아주 멋진 기능
      - 데이터 전송과 회수를 도와주는 기능이 있다.
      - 특정 경로에서 특정 컴포넌트를 가져오는 수준을 뛰어넘는 기능
    - 데이터를 가져올 때 useEffect를 사용해도 된다.
      - 하지만 6.4 이상 버전의 React router를 사용하면 데이터를 더 편리하게 가져올 수 있다.
    - 6.4 이상 버전을 설치하고 라우트 정의 부분으로 가서 데이터가 필요한 라우트에다가 "loader"라는 프로퍼티를 추가하면 된다.
    - loader 프로퍼티
      - 함수를 값으로 받는데 React route는 해당 라우트가 활성화될 때마다 loader에 있는 함수를 실행한다.
      - loader 프로퍼티가 있으면 해당 요소가 렌더링되려고 할 때마다 loader에 있는 함수가 실행되기 때문에 loader 함수를 사용해 라우트 컴포넌트 또는 라우트의 일부로 사용되는 컴포넌트에 필요한 데이터를 미리 로드해 둘 수 있다.
    - Posts 라우트 정의의 loader에서 HTTP 요청을 전송해 데이터를 가져오는 로직을 추가할 수 있다.
      - 하지만 main.jsx가 무거워지지 않도록 일반적으로는 라우트 컴포넌트 파일에서 정의한다.
    - Posts.jsx
      - export로 loader 함수를 내보내서 사용한다.
      - 이름은 보통 loader로 하지만, 다른 걸로 해도 된다.
        - 일반적으로 loader를 쓰는 이유는 이 함수가 라우트 정의의 loader 프로퍼티에 할당되는 함수이기 때문이다.
      - loader 함수 역시 클라이언트 쪽에서 실행된다.
        - 이 코드는 브라우저에서 실행
        - 이 함수의 다른 곳에서 할 수 있는 거라면 뭐든지 구현 가능
      - loader 함수 구성
        - PostList 컴포넌트의 HTTP response 코드를 복사해서 가져온다.
          - 상태 업데이트 코드는 여기서 중요하지 않다.
          - loader 함수는 컴포넌트 바깥에서 실행되기 때문에 컴포넌트 상태를 바꿀 수 없다.
          - loader 프로퍼티는 async/await, 즉 비동기 함수도 사용 가능
        - 화면에 표시할 데이터를 반환하면 해당 데이터를 현재 라우트에 렌더링된 요소가 받는다.
    - main.jsx에서 loader 함수를 import
      - import하는데 여기서 loader에 별칭을 사용해, 다른 라우트에서도 loader가 추가될 경우에 이름이 중복되는 것을 피해준다.
      - `import Posts, {loader as postsLoader} from "./routes/Posts";`
    - loader에서 반환된 데이터는 위에 있는 요소에서 사용할 수 있다.
      ```
      function Posts() {
        return (
          <>
            <Outlet />
            <main>
              <PostList />
            </main>
          </>
        );
      }
      ```
      - React router는 loader함수에서 반환한 데이터에 라우트 요소 또는 중첩된 컴포넌트가 접근할 수 있게 해준다.
        - 그래서 PostList에서도 접근할 수 있다.
    - PostList.jsx
      - useLoaderData Hook import
      - useLoaderData Hook은 컴포넌트 함수 내부에서 사용할 수 있다.
        - 다른 Hook처럼 이 Hook도 결국에는 컴포넌트 함수 안에서만 사용해야 한다.
      - useLoaderData Hook을 사용하면 Posts 라우트에 할당된 loader에서 반환한 데이터를 얻을 수 있다.
      - posts 상태 슬라이스 삭제
      - isFetching 상태 삭제
        - 로딩 상태는 다른 방식으로 처리할 예정
      - useEffect 호출 부분도 삭제
        - 데이터를 가져오는데 이제 useEffect를 사용하지 않는다.
        - 이제 React router가 제공하는 다른 기능을 사용한다.
      - isFetching 조건도 삭제
      - posts에 데이터가 있는지는 계속해서 확인
    - 지금 바꾼 동작에는 loader가 실행되는 동안 라우트 요소가 렌더링되지 않아서 몇 초 뒤에 포스트 목록이 나온다.
      - form 작성 페이지를 닫고 시작 페이지로 이동할 때는 뒤에서 포스트 목록을 미리 렌더링한다.
        - 이때는 빈 화면이 나오는 현상이 발생하지 않는다.
      - 맨 처음에 페이지로 들어왔을 때는 로딩 작업이 완료될 때까지 빈 화면이 나타나게 된다.
        - 이 동작은 원하는 동작이 아니기 때문에 변경이 필요하다.
    - React router에서 페이지를 더 빨리 보여줄 수 있는 방법이 있다.
      - 이 방법은 백엔드가 느린 경우를 제외하고는 모든 경우에 적합한 방식이다.
        - 백엔드가 느릴 때는 맞지 않을 수도 있다.
      - 백엔드에서 지연하는 코드를 주석처리하면 해결

# 오늘 느낀 점

- 오늘 요약 및 핵심 기능 관련 내용을 마무리하려고 했는데, 개인적인 일로 마무리를 하지 못하였다. 오늘도 최대한 짧게 요약해보려고 했는데 역시나 짧게 요약하지 못했고 좀 길어진 것 같다. 그래도 다시 복습을 하면서 내용을 한 번 더 살펴보며 부족한 내용을 채울 수 있어서 좋았던 것 같다. 특히 라우트 관련 내용이나 loader 함수 관련 내용은 한 번 더 들으려고 했는데 좋은 기회라고 생각이 되며 남은 action 내용과 동적 라우트 내용까지 마무리하고 개인 프로젝트 계획을 세울 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
