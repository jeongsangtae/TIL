# 오늘 한 일

### JWT 내용 정리 및 session, HTTP 응답 헤어, cookie 내용 추가 정리

- JWT 내용 정리

  - session vs JWT
    - session
      - 사용자가 특정 웹 사이트에 접속이 가능한 입장권에 간단하게 발급번호와 같은 내용만 적혀있고, 사용자가 웹 사이트에에 입장권을 제시하면 서버나 DB에 따로 만들어놓은 sessionStore에서 확인을 해서 조회를 해서 별 다른 문제가 없다면 사용자를 통과시켜주는 방식으로 진행
      - session은 사용자가 입장권을 제시할 때마다 sessionStore에서 데이터를 조회해야 하기 때문에 동시에 접속하는 사용자가 많을수록 서버에 부담이 된다.
    - JWT
      - 입장권에 써있는 정보가 많이 존재하는데 여기에 회원명, 이메일, 발급일, 유효기간 등의 정보가 있는데 여기에서 서버는 입장권을 검사할 때, 입장권 하나 자체만 확인하고 유효기간이나 내용이 별 문제가 없다면 사용자를 통과시켜주는 방식으로 진행
      - stateless 하며, 입장권 자체만 확인하면 되기 때문에 처리가 매우 빠르다.
      - JWT를 대충 쓰면 보안 이슈 4가지 정도 문제가 생길 수 있다.
        - 해당 내용은 아래에서 작성
    - 대부분의 서비스들은 session 방식으로 회원 인증을 구현하는 것이 보안상으로 안전

  <br />

  - JWT
    - Header, Payload, Signature의 구조를 갖는다.
      - Header
        - 기본 세팅 값이 들어간다.
        - 토큰 타입 지정 / 알고리즘 명시
      - Payload
        - 입장권에 기록할 데이터를 입력하는 곳
        - 토큰에 권한을 부여, 사용자 정보를 선택해 담을 수 있음
      - Signature
        - Header와 Payload를 조합한 후, 서명 알고리즘에 따라 생성된 서명 값
        - signature에 들어가는 내용은 토큰을 생성한 서버가 비밀 키를 사용하여 서명을 생성하므로, 클라이언트가 서버에서 생성한 서명을 직접 변경할 수 없다.
          - 이를 통해 토큰의 무결성이 보장됨
      - 3가지의 구조를 짧은 문자로 인코딩한 것이 JWT 입장권
    - 로그인을 하면 2개의 토큰을 주도록 구성
      - Access token, Refresh token
      - access token과 refresh token을 발급하고 클라이언트에게 보내고 나서 refresh token은 상응값을 DB에도 저장
      - 사용자는 access token의 수명이 다하면 refresh token을 보내고, 서버는 그걸 DB에 저장된 값과 대조해보고 맞다면 새 access 토큰을 발급하는 방식
      - refresh token만 안전하게 관리된다면, 이게 유효할 동안은 access 토큰이 만료될 때마다 다시 로그인을 할 필요 없이 새로 발급을 받을 수 있게 된다.
      - 이렇게 access token과 refresh token으로 구성해서 진행하는 이유는, 중간에 access token이 탈취당해도 오래 쓰지는 못하기 때문에 보안상으로 안전하다.
    - JWT의 보안 이슈 4가지
      - 첫 번째
        - Header 부분의 alg 에서 none으로 작성하고 JWT를 만들면 문제가 생긴다.
        - `HS256`으로 사용을 해야 함
        - alg 부분에서 none으로 채워서 직접 만든 입장권을 서버로 보내보는 악성 유저들이 있기 때문에 조심해야 한다.
          - 간혹 어떤 서버들은 입장이 된다고 함
          - alg를 none으로 만든 JWT를 거절하는 기능도 확인해보는 것이 좋다.
          - 최신 라이브러리 잘 쓰면 문제가 없을 수도 있다고 함
      - 두 번째
        - JWT는 디코딩(변환)이 매우 쉬워서 민감한 유저 정보들을 그대로 집어넣어서는 안되며, 최소한의 정보들만 집어넣어야 한다.
      - 세 번째
        - JWT를 구현할 때, 시크릿 키를 개발자 마음대로 결정할 수 있는데 이걸 대충 적게 되면 때려맞추기 쉬워지기 때문에 조심해야 한다.
        - 시크릿 키를 털리게되면 입장권을 마음대로 발생할 수 있기 때문에 키를 매우 길게 설정하고, 키를 공유해서는 안되며, 생성용 키와 검증용 키를 분리해서 2개로 운용을 하는 것도 좋은 방법이다.
      - 네 번째
        - JWT는 입장권을 탈취당해도 회수하거나 사용 정지시키는 작업이 어렵다.
        - 입장권을 탈취당한 경우에 입장권의 유효 기간이 지나기전까지 계속 사용이 가능하다.
        - 솔루션
          - 훔치기 어렵게 만들면 좋다.
            - HttpOnly cookie
          - 블랙리스트 운영
            - 특정 입장권들은 입장이 불가능하다고 목록을 따로 저장해두는 방식
            - 누군가 입장권을 제시할 때마다 검사를 진행하도록 한다.
            - 하지만, 이런 방식으로 코드를 짜면 JWT를 사용하는 장점이 사라지기 때문에 session 방식이랑 별 차이가 없다.
          - 유효기간을 짧게 구성
            - ex) 5분
            - 예시처럼 5분으로 설정하고, 입장권 재발급을 위한 refresh token을 통해서 새로운 입장권을 발급 받을 수 있도록 해줄 수 있다.
          - refresh token도 탈취당하는 경우가 있기 때문에 refresh token rotation이라는 방법을 사용하면 좀 더 안전하게 사용 가능
          - refresh token을 언제나 1회용으로 사용하도록 하면 더 안전하게 사용할 수 있다.
      - 주의해야 할 내용
        - passport-jwt와 같은 라이브러리 즉, nodejs + jwt를 사용하는 백엔드에서 jwt와 관련된 저런 라이브러리는 토큰 생성 검증만 하는 라이브러리이고, 보안 기능과 관련된 내용이 딱히 없기 때문에 제대로 쓰려면 추가 기능을 직접 개발해야 한다.

  <br />

  - Access token & Refresh token
    - Access token
      - 수명이 몇 시간이나 몇 분 이하로 짧은 토큰
      - 사용자 정보에 접근하는 token
      - 매번 인가를 받을 때 쓰는 수명 짧은 토큰이 access token
    - Refresh token
      - 꽤 길게, 보통 2주 정도로 잡혀 있는 토큰
      - Access token 갱신 용도의 token
      - Access token을 재발급 받을 때 쓰는 토큰이 refresh token

  <br />

  - HTTP 응답 헤더 & Cookie
    - HTTP 응답 헤더
      - 장점
        - 쿠키 크키 제한 우회
          - 헤더에 포함되는 정보는 쿠키보다 더 많은 데이터를 처리할 수 있다.
        - 유연성
          - 쿠키를 사용하지 않기 때문에 쿠키 관련 설정에 영향을 받지 않고, 다양한 헤더 기능을 사용할 수 있다.
      - 단점
        - 브라우저 호환성
          - 일부 브라우저는 사용자 지정 헤더를 차단할 수 있으므로 호환성 문제가 발생할 수 있다.
        - 보안 이슈
          - 일부 사용자 지정 헤더는 보안 문제를 발생시킬 수 있으므로 신중하게 선택해야 한다.
      - JSON 응답의 일부로 JWT 토큰을 전송하는데, 이 경우 클라이언트는 서버 응답의 JSON 본문에서 토큰을 추출하여 저장하고 사용할 수 있다.
        - 이 방법은 클라이언트가 JWT 토큰을 따로 저장하거나 처리할 필요가 있어 구현하기에 복잡할 수 있다.
      - 좀 더 세밀한 설정이 가능하고, 특히 보안과 관련된 설정이나 클라이언트-서버 간의 특정한 요구 사항을 충족시키기 위해 헤더를 직접 구성할 수 있다.
        - 예로, 캐시 제어, 보안 정책, CORS 관련 설정 등을 HTTP 응답 헤더를 통해 구성할 수 있다.
    - Cookie
      - 장점
        - 브라우저 지원
          - 쿠키는 브라우저에서 자동으로 관리되므로, 클라이언트 측에서 별도의 작업 없이 편리하게 사용할 수 있다.
        - 보안
          - Secure 속성을 설정하면 HTTPS 연결을 통해야만 전송되므로 데이터를 안전하게 전송할 수 있다.
        - CSRF 방어
          - 쿠키에는 SameSite 속성을 설정하여 CSRF 공격으로부터 보호할 수 있다.
        - 서버레스 통신
          - 클라이언트-서버 간의 통신에서 서버가 세션을 관리하지 않아도 되므로 서버리스 아키텍처를 구현할 수 있다.
      - 단점
        - 쿠키 크기 제한
          - 브라우저는 쿠키 크기에 제한을 두기 때문에 토큰의 크기가 제한될 수 있다.
        - 네트워크 오버헤드
          - 모든 HTTP 요청에 쿠키가 포함되므로, 요청마다 쿠키가 추가되어 네트워크 오버헤드가 발생할 수 있다.
      - 특별한 설정 없이 브라우저가 요청과 응답 사이의 쿠키를 자동으로 관리하기 때문에, 백엔드에서 추가적인 처리가 필요하지 않다.
      - 서버는 JWT 토큰을 쿠키에 저장하여 클라이언트로 보낼 수 있다. 이 경우 클라이언트는 서버에서 설정한 쿠키를 자동으로 관리하고 요청 시마다 해당 쿠키를 서버로 다시 보낸다.
        - 쿠키에 토큰을 저장하는 방법은 브라우저가 쿠키를 자동으로 관리하기 때문에 구현이 간단하고, 보안상의 이점도 있다.
    - 종합하면 두 방법 모두 장단점이 있다. 일반적으로 보안적인 측면과 클라이언트의 편의성을 고려하여 적절한 방법을 선택한다.

<br />

- 추가 및 해결 해야 할 내용
  - 회원가입 form에서 잘못된 입력을 제출 했을 때, session에 데이터가 저장되는데, 기존의 session 데이터에서 업데이트되는 방식이 아닌 매번 제출할 때마다 새로운 session이 추가되고 있기 때문에 백엔드 코드에서 수정이 필요하다.
    - 계속 원인을 찾아보려고 이것저것 시도해보았지만 아직 어떤 코드가 정확히 원인인지 찾지 못해서 하나씩 천천히 테스트가 필요함
    - 일단 이걸 테스트 해보기전에 먼저 정상적으로 세션 만료가 되는지 확인해보았는데 정상적으로 세션 만료가 되기 때문에, 로그인을 먼저 구성해보고 정상적으로 로그인이 되는지 확인을 해보고 안된다면, session에 저장되는 부분을 다시 확인해봐야 할 것 같다는 생각
  - 로그인이 되는지 확인하고, 로그인이 되었다면 메인헤더가 변경되도록 구성해야 함
    - `req.session.isAuthenticated`를 프론트엔드에 전달해서, useState를 이용해 메인헤더가 변경되도록 해주면 될 것 같음 (완료)
    - 현재 결과로 따지면 로그인도 되고, 메인헤더가 변경되긴 하지만 순환 참조 오류가 있어서 추가 작업이 필요함 (완료)
    - 로그인 시 `isAuthenticated` 정보가 MainHeader 컴포넌트로 넘어가서 useState에 true로 값이 저장되며, 해당 값을 사용해서 조건부 렌더링이 작동하도록 구성해서 순환 참조 오류없이 작동하도록 구성 (완료)
  - 로그인 후에, 새로고침 시 로그아웃 되어버리는 상황도 수정을 해야 함
    - JWT를 사용해서 클라이언트 측에서 state를 유지하게 해줘야 한다.
      - 사용자의 인증 정보를 클라이언트에 저장해서 지속적으로 유지해야 함
    - session에서 넘어온 데이터를 통해 sessionStorage에 저장해서 로그인이 유지되도록 구성되어 있으며, 이 내용에 JWT를 추가해서 구성해볼까 생각중
      - 로그인은 새로고침 시에도 문제없이 유지됨
  - 로그아웃 기능도 추가해야 함
    - 로그인이 성공하면 메인헤더가 변경되고 로그아웃 버튼이 추가되며, 로그아웃 버튼 클릭 시 메인 헤더의 내용이 초기 상태로 돌아오도록 구성을 해줘야 함 (완료)
    - 구성한 내용을 테스트 해본 결과 정상적으로 동작하고 있기 때문에 이 상태로 유지하고 추가로 로그인 관련 코드를 변경하면 추가 수정을 해줄 생각이다.
  - JWT 관련 코드 문제
    - 이전 오류를 테스트하기 위해 router.use를 사용하는 부분을 주석 처리하고 진행한 결과 정상적으로 토큰이 생성되고 추가되는 것을 확인했다.
    - sessionStorage에 토큰이 추가된 채로 다시 router.use 코드의 주석을 풀고 테스트해본 결과 토큰이 있음에도 여전히 토큰이 없다는 메시지가 뜨고 있기 때문에 이 부분의 수정이 추가로 필요하다.
    - JWT에 대해 좀 더 알고 사용해야 할 것 같아서, 찾아본 내용에 대해 정리를 하고 코드를 구성할 생각이다.
      - 그리고 sessionStorage에 저장하는 것도 좀 고려를 해봐야 할 것 같고, http 응답 헤더 방식을 사용하는 것도 좀 변경이 필요해보인다.
      - HTTP 응답 헤더 방식 대신에 보안상 더 안전한 cookie를 사용할 예정이다.

# 오늘 느낀 점

- 오늘 JWT에 대한 내용을 찾아보고, JWT의 보안 이슈에 대해서 알아보며, session과 JWT가 어떻게 다른지 그리고 어떤 방식으로 동작하는지 알아보고 JWT에서 access token과 refresh token이 각자 어떤 역할을 하는지 알아보았다. 추가로 HTTP 응답 헤더를 사용해서 저장하는 방법과 cookie를 사용해서 저장하는 방법을 비교했는데 아무래도 내가 코드를 구성하고 작업하기에는 HTTP 응답 헤더보다는 cookie가 좀 더 쉽고 간편하며, 보안적인 측면도 알아서 처리되는 부분이 있기 때문에 cookie를 사용하는 것이 맞다고 생각이 된다. HTTP 응답 헤더를 사용해서 저장하는 방법은 좀 더 규모가 큰 프로젝트에서 사용하는 것이 맞다고 생각이 되며, 더 세부적인 보안 사항을 강화할 때 알맞게 작업할 수 있고, 세밀한 제어도 할 수 있으며, 그 외에 여러 이점이 더 있기 때문에 프로젝트 규모가 커졌을 때 HTTP 응답 헤더를 사용하는 방향으로 생각 중이다. 그리고 jwt token을 백엔드에서 cookie에 저장하는 내용을 추가하고 작업을 진행할 생각이며, 자연스럽게 로그인이 될 시 cookie에 token이 저장되도록 구성해줄 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작
