# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- 빠진 타입 정의 내용을 추가 및 React.FC 내용을 삭제, props 명시적 타입 정의로 변경
  - 그룹 채팅방 목록 컴포넌트에서 로딩을 관리하는 useState와 useEffect 내의 fetch 함수에서 타입 정의를 하지 않은 것을 확인하고 타입 정의를 추가해 주었으며, 인증 모달, 로그인, 회원가입, 그룹 채팅방 생성 컴포넌트에서 불필요하게 React.FC 내용을 사용해 타입 정의하고 있기 때문에 해당 내용을 삭제하고 props의 타입을 명시적으로 정의하는 방식으로 변경해 주었다.
  - 프론트엔드
    - GroupChats
      - loading useState에 boolean 타입 정의 추가
      - useEffect 내의 fetch 함수 내용에 Promise 타입 정의 추가
    - Login, Signup, CreateGroupChat, AuthModal
      - React.FC 내용을 삭제하고, props에 명시적 타입 정의로 변경
  - 빠진 타입 정의를 추가해 주면서 코드가 더 명확해 졌다고 생각이 되며, React.FC로 정의된 타입 내용을 제거하고 props의 타입을 명시적으로 정의하는 방식으로 변경해 주면서, 컴포넌트의 타입 정의가 전체적으로 일관성 있게 구성이 되었다고 생각이 된다.
  - loader 함수와 fetch 함수 반환 타입 정의, 그리고 useState와 useLoaderData의 타입 보장 차이, 마지막으로 React.FC로 타입 정의하는 방법과 props의 타입을 명시적으로 정의하는 방법 차이에 대해 정리하고 갈 생각이다.
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/a2eae8c02975e8264f6f601a0114d669b7ca4498)

<br />

- loader 함수와 useEffect 내의 fetch 함수 반환 타입 정의 차이
  - loader 함수
    - return을 통해 반환값이 명확히 넘어오도록 타입을 정의해야 함
    - 반환값이 있는 함수는 ex) `Promise<GroupChatData[]>` 이런식으로 정의
  - useEffect 내의 fetch 함수
    - fetch 함수는 비동기 작업을 수행한 뒤 결과를 상태로만 업데이트하고, 호출자에게 반환하는 값이 없기 때문에 타입 정의를 기본 함수로 지정
    - 데이터 처리를 위해 useState 내용을 업데이트할 뿐, 함수 호출 자체로 반환되는 값이 없음
    - 반환값이 없는 함수는 `Promise<void>` 타입을 정의

<br />

- useState와 useLoaderData의 타입 보장 차이
  - useState
    - 타입을 100% 확신함
      - 이유는 useState는 초기값과 함께 타입을 정의함
      - 초기값 타입을 정의하고, TypeScript는 항상 정의한 타입 내용을 확신함
    - 상태를 업데이트할 때도 설정한 타입 정의 내용만 허용하므로, 상태 값의 타입이 언제나 안전하게 유지됨
    - useState 내용에 map 함수를 사용하면 이미 타입을 100% 확신하기 때문에, 구성한 내용에 추가적인 타입 정의가 필요없음
  - useLoaderData
    - 반환받는 데이터가 실제로 어떤 데이터를 갖고 있는지 TypeScript가 100% 확신하지 못함
      - 이유는 반환값이 런타임에서 달라질 가능성이 있기 때문에 확신하지 못함
      - ex) 서버 오류, 데이터 누락 등
    - useLoaderData는 데이터를 런타임에 가져오므로, 반환되는 데이터가 예상과 다를 가능성이 있음
      - 런타임에서 다른 값(ex: null, undefined, 예상치 못한 데이터 구조)이 반환될 수 있음
      - TypeScript는 이 점을 감안하여 안전하지 않을 가능성을 열어 둠
    - loader 함수의 반환값을 통해 타입을 강제하지만, 데이터 로딩 중이나 오류가 발생했을 가능성을 TypeScript가 감안함
      - 그래서 데이터를 사용할 때 명시적으로 타입을 지정하여 코드의 안정성을 높이는 것이 필요함
    - 데이터 타입을 보장하지 않으며, 타입을 강제하는 역할만 하므로 useLoaderData를 통해 가져오는 데이터에 map 함수를 사용하면 TypeScript는 데이터가 올바르게 로드되었다고 보장을 하지 못하기 때문에 명시적으로 타입을 지정해야 함
      - map 함수를 사용하는 내용에 명시적으로 타입을 정의해야 TypeScript가 데이터 사용을 안전하게 처리하도록 강제할 수 있음
  - 간단 요약
    - useState
      - 초기값과 타입이 고정되어 런타임 변경 가능성이 없으므로 추가 타입 정의가 필요없음
      - useState로 관리되는 데이터는 TypeScript가 100% 타입을 보장
    - useLoaderData
      - 런타임에서 데이터를 가져오는 구조로 인해 TypeScript가 데이터를 확신하지 못하므로 명시적인 타입 정의가 필요할 수 있음
      - 런타임에 불확실성이 존재하기 때문에 명시적인 타입 정의가 필요

<br />

- React.FC로 타입 정의하는 방법과 props의 타입을 명시적으로 정의하는 방법 비교
  - React.FC로 타입 정의하는 방법
    - 장점
      - React 컴포넌트라는 것을 명확히 표현
      - children을 기본적으로 포함하므로, 컴포넌트가 children을 사용할 가능성이 있다면 편리
        - children의 타입은 ReactNode로 정의됨
        - `type React.FC<P = {}> = FunctionComponent<P & { children?: ReactNode }>;` 이 내용으로 인해 타입이 ReactNode로 고정
      - children 속성을 선택적으로 받을 수 있음
    - 단점
      - children 속성이 필요하지 않은 경우에도 포함되므로 불필요할 수 있음
      - 타입 정의가 비교적 덜 간결함
  - props의 타입을 명시적으로 정의하는 방법
    - 장점
      - 더 간결하고 읽기 쉬움
      - 가독성과 타입 안정성이 더 높아짐
      - props의 타입만 명확히 정의하므로, 불필요한 속성(children)이 포함되지 않음
    - 단점
      - children이 필요한 경우에는 추가로 타입을 정의해야 함
  - React.FC 방법과 props의 타입 명시적 정의하는 방법을 섞어서 사용해도 되는가?
    - 섞어서 사용해도 무방하지만 일관성 있는 코드 스타일을 유지하는 것이 협업과 유지보수에 더 유리하므로, 상황에 따라 적절한 선택 필요
    - 개인 프로젝트나 소규모 프로젝트에서는 문제가 안될 수 있지만, 팀 협업이나 코드 스타일의 일관성을 중요시하는 프로젝트에서는 조금 문제가 될 수 있음
  - React.FC 추가 내용
    - React.FC를 빈번하게 사용하는가?
      - 최근 React 커뮤니티에서는 React.FC를 사용하지 않는 추세
    - React.FC를 사용하지 않는 이유
      - 기본 제공되는 타입이 충분함
        - React.FC는 기본적으로 제공되는 `React.FunctionComponent`의 별명에 불과함
        - React.FC는 children을 자동으로 포함시키는 등 유용하게 보일 수 있지만, 사실 대부분의 경우 컴포넌트에서 children을 명시적으로 사용하지 않거나, children을 옵션으로 만들기 위해 React.FC를 사용하는 것은 불필요한 의존성을 증가시킬 수 있음
      - 명시적 타입 정의 선호
        - React.FC는 기본적으로 children 속성을 포함하지만, 많은 경우 children이 필요하지 않거나 필요할 때만 사용하는 것이 더 명확하고 효율적
        - children을 명시적으로 타입을 지정하고, props를 직접 정의하는 방식이 더 선호됨
        - children을 사용하지 않는 컴포넌트에서 React.FC를 사용하면, 불필요하게 children을 포함하게 되어 코드가 더 복잡해질 수 있음
      - 자동 children 타입을 피할 수 있음
        - React.FC를 사용하면 자동으로 children 타입이 포함되는데, children을 사용하지 않는 경우 children 속성이 존재하는 것은 불필요할 수 있음
        - 이럴 경우, children을 명시적으로 정의하거나 아예 제거하는 방식이 더 직관적이고 오류를 줄일 수 있음
      - 성능과 최적화
        - React.FC가 기본적으로 children을 포함하는 구조는 성능에 큰 영향을 미치지는 않지만, 불필요한 타입을 포함하게 되어 결과적으로 타입 체크나 인텔리센스에서 더 많은 작업을 하게 될 수 있으며, 이로 인해 컴파일러나 IDE의 성능에 영향을 줄 수 있음
    - 결론
      - React.FC는 사용을 피하는 추세
      - 명시적으로 타입 정의가 더욱 직관적이고 유지보수에 유리
      - 불필요한 children 포함을 방지할 수 있음
      - 명확하고 간결한 타입 관리가 가능함
      - 최신 트렌드에서는 React.FC를 사용하지 않고, 타입을 명시적으로 정의하는 방법을 선호

<br />

- 로딩 스피너 추가 (로딩 인디케이터)
  - 데이터가 넘어오는데 오래 걸리는 경우, 로딩 중이라는 텍스트 표시보다는 로딩 스피너 즉, 로딩 인디케이터를 보여주면 좀 더 좋을 것 같다는 생각에 로딩 인디케이터 내용을 추가하고 사용
  - 프론트엔드
    - LoadingIndicator
      - 로딩 인디케이터 내용을 다른 프로젝트에서 가져와 구성
    - GroupChats
      - 로딩 중이라는 텍스트 대신에 로딩 인디케이터 컴포넌트가 보여지도록 수정
  - CSS
    - LoadingIndicator
      - 원이 돌아가는 모양을 구현하기 위해 애니메이션과 애니메이션 딜레이, transform을 사용해 구성
  - 로딩 중이라는 텍스트 메시지보다 로딩 스피너를 보여주는 쪽이 훨씬 UI 상으로 좋다고 생각되어 추가를 해 주었는데, 이전보다 훨씬 보기 좋아졌다고 생각이 되며 그룹 채팅방 목록에서 테스트를 위해 로딩 스피너를 사용했는데, 추후에는 메인 콘텐츠 쪽으로 옮길 예정이다.
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/93cade21d46167ce4a55cb65ba854785eda52227)

# 오늘 느낀 점

- 빠진 타입 정의 내용을 추가하고, React.FC로 타입 정의하는 대신에 props의 타입을 명시적으로 정의하는 방법으로 변경했는데, 이전보다 코드가 일관성 있게 구성이 되었다고 생각이 된다. 내용을 수정하면서 새롭게 알거나 헷갈리는 부분은 추가로 정리를 해 주었는데, 이번에 정리한 내용은 TypeScript로 타입 정의를 할 때 더 신경써야 하는 부분을 알게 해 줬다고 생각이 되며, 앞으로 정리한 내용을 생각하면서 타입 정의를 해야 할 것 같다. 이제 본격적으로 회원가입과 로그인 기능을 구현해야 하고, 로그인 상태 관리는 Context API가 아닌, Zustand를 사용해야 하는데 처음 사용하는 내용이라서 조금 정리가 필요할 것 같기에 간단하게 정리하고, 로그인 관련 내용을 추가한 후에 Zustand로 상태 관리를 해 봐야 할 것 같다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 구성하는 방법에 대한 정보 필요

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
