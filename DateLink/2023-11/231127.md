# 오늘 한 일

### React 공부

- React + TypeScript

  - 컴포넌트 및 TypeScript 작업하기
    - 기본적인 파일 정리
      - App.test.tsx, logo.vsg, reportWebVitals.ts, setupTest.ts 파일 삭제
      - react-app-env.ts 파일은 그대로 둔다.
        - TS와 내 프로젝트를 연결하는 파일 같은 것이기 때문이다.
      - index.tsx에서 reportWebVitals 파일을 가져오는 부분도 삭제하고, strict mode 부분도 삭제
        - `<React.StrictMode>` 삭제
      - App.tsx
        - 로고 파일을 가져오는 부분을 지우고, react 가져오는 부분도 삭제
          - 모던 React 프로젝트에서는 react 가져오는 부분을 생략해도 된다.
          - TS 프로젝트에서도 마찬가지이다.
        - JSX 콘텐츠 영역도 삭제
      - App.css
        - 모든 코드 삭제
      - index.css
        - 처음 상태 그대로 놔두는데, code 선택자 부분은 삭제하고 body 선택자 부분만 유지
        - 기본으로 설정된 font-family는 남겨둔다.
    - 가장 중요한 부분이자 다행인 점은, 대부분 앞선 강의에서 사용한 것과 동일한 코드를 계속해서 사용할 수 있다는 것이다.
      - 모든 게 갑자기 달라지진 않을 것이다.
      - App.tsx 파일이나 index.tsx 파일을 보면 앞선 강의에서 봤던 코드와 완전히 동일하다. 전혀 차이가 없다.
        - 특이한 타입 표기도 없다.
        - 여기엔 그런 것이 필요하지 않다.
        - 보통 TS가 가진 타입 추론을 사용하지만 이 코드에는 타입이 필요한 부분이 별로 없다.
      - 어떤 부분에 TS를 사용해서 React 코드를 보완할 수 있는지 보게 될 것이다.
    - 단순하게 하고 싶기 때문에 간단한 To do 앱(할 일 정리 앱)을 만들 예정
      - 간단하게 할 일을 추가하고 삭제할 수 있는 앱을 말한다.
      - 복잡하고 화려한 앱은 아니겠지만 반드시 알아야 할 TS의 핵심 기능을 설명하는 데는 충분할 것이다.
    - 기존 React에서 했던 것과 마찬가지로 components 폴더를 생성
      - Todos.tsx 파일을 추가
      - Todos.tsx 파일이 새로 만들 React 컴포넌트를 들고 있을 것이다.
    - React 컴포넌트는 함수나 클래스 모두 가능하지만, 앞선 강의에서 그랬던 것처럼 여기서는 함수형 컴포넌트에 집중할 것이다.
    - Todos.tsx 구성
      - Todos 함수 추가
        - 함수를 export 시켜서 파일 밖에서도 접근할 수 있게 해준다.
      - 기존에 만들었던 React 컴포넌트들처럼 화면에 표시할 수 있는 콘텐츠를 반환해야 하는데 주로 JSX 콘텐츠를 반환한다.
        - 이 부분 역시 달라진 게 없다.
      - JSX 콘텐츠에 순서 없는 목록인 ul을 추가
        - 할 일이 몇 개 있기 때문에 이 내용을 추가해줘야 한다.
      - list item(li) 요소를 몇 개 만들어 할 일을 추가
        - 현재는 정적으로 구성이지만, 목록을 동적으로 바꿔줄 것이다.
        - 사용자가 직접 할 일을 입력할 수 있도록 해줄 것이다.
    - App.tsx 구성
      - Todos 컴포넌트를 App.tsx에서 사용
        - 늘 그랬듯이 컴포넌트를 가져온다.
          - 가져올 때 파일 확장자를 생략해도 된다.
        - div 태그 안에서 Todos 컴포넌트를 넣어주며 사용
    - 현재까지는 굉장히 단순한 React 컴포넌트로 구성이 되어있다.
      - 점점 재미있어질 건데, Todos 컴포넌트에 할 일의 내용을 코드로 고정해놓고 출력하는 게 아닌, props를 통해 사용자로부터 할 일을 받아 출력할 것이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-typescript/commit/15a48943288e51f14a37926590c0fa3db94a205d)

  <br />

  - Props 및 TypeScript 작업하기
    - 하드 코딩한 할 일 목록 삭제
      - props를 받아 사용할 것이다.
    - 여기서 목표는 props에 items나 todos 프로퍼티를 받아서 각 항목을 매핑한 다음 li로 넣을 것이다.
    - Todos.tsx 구성
      - props를 선언했는데, 여기에 벌써 빨간줄이 밑줄이 생겨있다.
        - 커서를 올려서 확인해보면 props가 선언되었지만 사용된 적이 없다고 나온다.
          - props를 사용하지 않고 있다는 경고 메시지이다.
          - TS 프로젝트에 추가된 보조 기능이라 바닐라 JS 프로젝트에서는 볼 일이 없다.
          - 사용하지 않는 불필요한 코드가 있으면 알려줄 것이다.
        - 또 다른 경고 메시지도 있는데, props 매개 변수는 지금 any타입이라는 메시지이다.
          - 여기에 타입을 지정하지 않았다는 뜻이다.
          - 확실하게 타입을 명시하지 않았다.
          - TS로부터 어떤 지원도 받지 못하고 있다.
          - 타입을 정의하지 않았을 때 TS가 이런 메시지를 보내도록 설정할 수 있는 이유이다.
          - 명시적으로 any 타입을 지정하면 경고 메시지가 사라진다.
            - `const Todos = (props: any) => {...}`
            - 명시적으로 props 인자에 대해 더 설정할 정보가 없다고 표시한 것이다.
            - 타입을 any로 지정해서, 어떤 값이든 될 수 있고, 문제될 게 없다.
          - 명시적으로 타입을 지정하지 않으면 내가 이 타입을 전혀 알아낼 수 없다고 말하는 것처럼 보여서 TS가 경고 메시지를 보내는 것이다.
            - 타입을 설정하지 않고 두면 안된다.
            - TS가 이런 사항을 어디까지 경고하도록 할 건지는 `tsconfig.json` 파일에서 설정할 수 있다.
              - tsconfig.json 파일은 나중에 살펴볼 예정이다.
        - 현재 여기서 필요한 것은 분명히 표시하는 것이다.
          - 어떤 props를 받을 건지 이 함수의 props가 어떤 타입이어야 하는지 알려줘야 한다.
            - props는 객체 타입이라고 표시해준다.
            - React에서 props는 언제나 객체 형태이다.
            - 다른 속성들처럼 App.tsx에 있는 요소에 키-값 쌍 형태로 프로퍼티를 추가한다.
      - props 타입 구성
        - todos나 items라는 프로퍼티를 받을 것이며, 형태는 문자열 배열이 될 것이다.
          - `const Todos = (props: { items: string[] }) => {...}`
        - 정리하면 props는 객체고, items를 키로 가지며 문자열 배열을 값으로 갖는다는 뜻이다.
        - props에는 내가 JSX에서 사용하기 위해 컴포넌트에 추가한 키-값 쌍만 있는 게 아니다.
          - props는 객체이기 때문에 당연히 키-값 쌍도 갖고 있다.
          - 하지만 객체에는 항상 특별한 prop이 있다.
            - children 프로퍼티
            - children 프로퍼티의 타입는 모른다.
            - 그래서 어떤 타입으로 설정해야 하는지 찾아내 추가해야 한다.
        - props를 사용하도록 정의한 모든 컴포넌트에 대해 객체에 미리 정의된 props를 매번 추가해야 한다면 매우 귀찮은 일이다.
          - 직접 만든 props도 마찬가지이다.
          - 이 작업은 번거롭고 모든 컴포넌트가 기본으로 갖는 prop 객체 예를 들면 children prop 같은 프로퍼티까지 있기 때문에 React는 다른 방법을 제공한다.
            - React와 TS가 제공하는 방법이라고 할 수도 있다.
            - 바로 제네릭 타입을 이용하는 것이다.
        - 제네릭 타입을 이용해서, 정확히 말하면 함수형 컴포넌트를 바로 제네릭 함수로 변환해서 이용할 수 있다.
          - 이 말이 의미하는 바는 내가 만든 함수형 컴포넌트에서 몇 가지 설정을 추가하여 React 함수형 컴포넌트로 동작하게 만들어 children 같은 기본 props를 사용할 수 있도록 하는 것이다.
            - 그 다음 새로운 props를 추가로 정의한다.
            - 여기서는 items prop 같은 것을 말한다.
            - 새로 추가한 프로퍼티는 props 객체에 합쳐져야 한다.
      - 상수 Todos에 타입을 지정
        - 타입은 React로 지정해야 한다.
          - 이를 위해 react를 가져와야 한다.
            - `import React from "react"`
          - 그리고 React 타입에 `.FC`를 추가
            - `const Todos: React.FC = (props) => {...}`
        - 이 타입은 React 패키지에 정의된 타입이다.
          - 정확히는 `@types/react` 패키지에 정의된 것이다.
          - `import React from "react"`를 쓰면 나머지는 알아서 처리된다.
        - FC에서 ctrl 키를 누른 상태에서 클릭하면 타입 정의를 볼 수 있다.
          - FunctionComponent 라는 타입으로 React 패키지에 내장된 또 다른 타입 정의이다.
        - `React.FC`라고 타입을 정의함으로써 해당 함수가 함수형 컴포넌트로 동작한다는 걸 명확히 하는 것이다.
          - 이것이 FC의 의미이다.
          - 함수형 컴포넌트 (Functional Component)
        - 위처럼 해줌으로써 props 밑에 있던 빨간 줄이 사라진 것을 확인할 수 있다.
      - JSX 코드에서 중괄호 안에 props를 넣고 점을 찍으면 자동 완성 창에 children 프로퍼티가 나타난다.
        - 단지, React.FC라는 타입 표기를 추가함으로써 TS와 개발 툴은 명석하게도 해당 함수가 받는 값이 props 객체라는 걸 이해하게 된다.
          - props는 함수의 첫 번째 인자로 받는 값
        - props 객체에는 항상 children 프로퍼티가 있다.
          - `{props.children}`
        - 이렇게 이해하고 동작할 수 있는 이유는 React.FC라는 타입을 지정했기 때문이다.
      - 제네릭 타입이 중요하다고 말해준 이유는 `FC` 자체가 제네릭 타입이기 때문이다.
        - 내가 새로 정의한 타입을 props 객체에 합칠 수 있다.
          - 함수형 컴포넌트를 위해 내가 만든 프로퍼티와 children 프로퍼티 같은 기본적인 props를 찹히는 것이다.
      - 내가 만든 프로퍼티와 기본 프로퍼티를 합치는 작업
        - 이를 위해 FC 뒤에 `<>`를 추가, 그리고 괄호 사이에 새로 만들 props를 정의
          - 여기서는 <>를 TS의 제네릭 타입을 배울 때 사용했던 것과는 약간 다른 방식으로 사용할 예정
          - 이전에 제네릭 함수를 만들기 위해 <>를 사용할 때는 제네릭 타입 매개변수가 있었다.
            - `const insertAtBeginning = <T>(array: T[], value: T) => {...}`
            - 이름을 붙이면 매개변수인 것이고, 제네릭 타입 T가 있었다.
            - 그리고 함수 안에서 이 타입인 T가 사용되었었다.
            - 이 예시에서는 제네릭 함수를 사용했을 때 TS가 타입을 추론했다.
            - 여기에서는 약간 다르게 사용
        - React.FC는 이미 제네릭 타입이다.
          - React 패키지에서 정의한 타입 설명을 보면 제네릭이라고 되어 있다.
            - 그러니까 이 타입은 이미 내부에서 <>를 사용해 정의된 것이다.
          - React.FC 코드에서 다시 <>를 추가한 다음 T 같은 식별자를 넣어 새로운 제네릭 타입을 만드는 게 아니라, 내부적으로 사용되는 제네릭 타입에 구체적인 값을 집어넣을 것이다.
            - React.FC에 의해 정의된 타입 T에 구체적인 값을 넣는 것이다.
          - 이렇게 하는 이유는 여기에서는 TS가 제네릭 타입을 추론하게 둘 수 없기 때문이다.
            - 앞에서 보여준 예제와 다르다.
            - TS가 타입을 추론하게 둘 수 없는 건 매개변수를 넣고 제네릭 함수를 호출해서 해당 값의 타입을 추론하도록 두는 게 아니라, 함수를 정의하고 TS에게 이 함수를 내부적으로 어떻게 처리해야 하는지 알려주고 싶기 때문이다.
              - 내가 추가한 props를 받아서 모든 함수형 컴포넌트가 갖고 있는 children 프로퍼티 같은 기본적인 props들과 합칠 수 있도록 하는 것이다.
          - 여기서 제네릭 타입의 다른 면을 확인한 것이다.
            - 제네릭 타입을 사용해서 FC라는 제네릭 타입의 용도에 맞게 사용할 하나의 타입을 명시적으로 설정하는 것이다.
            - FC 타입은 제네릭 타입이고, 거기에 집어넣을 값은 내가 만든 props 객체이다.
              - 함수형 컴포넌트에 맞게 props를 정의한 객체
              - 이게 제네릭인 이유는 함수형 컴포넌트마다 props에 대한 정의가 다르기 때문이다.
            - 이것이 React와 TS를 이용해서 제네릭 타입을 사용하는 또 다른 방식이다.
        - <>는 제네릭 타입을 만드는 구문이다.
          - `React.FC<{}>` 이렇게 추가함으로써 FC 타입 내부의 기능을 밖으로 꺼낸 것이다.
          - FC 타입의 기능은 <> 이곳에 어떤 객체 타입을 정의하든 **객체의 기본 타입, children 프로퍼티와 합쳐주는 기능**이다.
        - `React.FC<>` 구성
          - items로 문자열 배열을 받도록 설정
          - `const Todos: React.FC<{items: string[]}> = (props) => {...}`
      - JSX 코드 내의 props
        - `{props}`의 props 뒤에 점을 찍으면 여전히 children 프로퍼티가 있다는 걸 알고 있다.
          - 추가로 items 프로퍼티도 있는 것을 확인할 수 있다.
          - 타입은 문자열 배열
          - 이 프로퍼티를 아는 이유는 React.FC에서 새로운 프로퍼티의 정의를 기본 props 객체 정의에 추가했기 때문이다.
      - 모든 내용들이 아주 복잡하게 들릴 수 있다.
        - 이 내용들은 밑단에서 일어나는 일을 설명해주고 있기 때문에 그런 것이다.
          - 하지만 사용하는 건 매우 간단하다.
        - React와 TS로 함수형 컴포넌트를 만들려면 React.FC 타입을 함수형 컴포넌트의 상수 옆에 사용한다.
          - 그리고 <>를 붙인 다음 그 괄호 사이에 필요한 형태의 props를 정의하는 것이다.
            - props 객체 형태
            - `React.FC<{items: string[]}>`
          - 컴포넌트 안에서 직접 만든 props를 사용하면 된다.
            - `<ul>{props.items}</ul>;`
      - items 프로퍼티 추가 구성
        - map을 사용
          - 배열을 위한 자동 완성 창도 볼 수 있는데, items가 배열이라는 걸 TS가 알기 때문이다.
          - 위에서 `items: string[]`로, 배열 타입을 정의했기 때문이다.
        - items의 각 item을 list item 요소로 바꿀 수 있다.
          - 항목을 넣고, 키에는 item을 넣어준다.
            - 키에는 items 배열의 문자열이 들어간다.
          - `<ul>{props.items.map((item) => <li key={item}>{item}</li>)}</ul>;`
    - React에서 TS를 사용하는 것의 장점은 코드에서 많은 게 설명된다는 것뿐만 아니라 컴포넌트 안에서 작업할 때 자동 완성 기능도 사용할 수 있다는 것이다.
    - App.tsx에서 오류 발생
      - Todos.tsx에서 추가한 타입 표기 때문에 React는 이제 알게 된 것이다.
        - 정확히는 프로젝트 설정에서 내가 Todos 컴포넌트를 사용하는 방식이 잘못됐다는 걸 알게 된다.
        - Todos 컴포넌트의 타입을 정의하는 부분에서 이 컴포넌트는 items 프로퍼티를 갖는다고 명확하게 표시했기 때문이다.
          - 이건 선택적으로 설정할 수 있는 prop이 아니다.
          - 물음표를 추가해 선택적인 prop으로 만들 수도 있지만, 그렇게 하면 item을 갖지 않는 경우에 대해 처리해줘야 한다.
        - 더 이상 Todos 컴포넌트에서 할 수 있는 게 없으므로, App.tsx에서 추가해야 한다.
      - TS를 사용해야 하는 또 다른 이유
        - 컴포넌트의 형태와 해당 컴포넌트에 필요한 props를 모두 작성했다.
        - 컴포넌트를 잘못된 방식으로 사용하는 일, 예로 컴포넌트에 필요한 props를 일부러 넘기거나 하는 일은 발생할 수 없다.
          - 개발 툴이 바로 오류를 알려주기 때문이다.
      - items를 추가해서, 텍스트로 내용을 추가해서 Todos 컴포넌트로 전달
        - `<Todos items={["React", "TypeScript"]} />`
    - 타입 표기를 설몀하는데 오랜 시간을 썼는데, 어떻게 동작하는지 이해하는 것이 좋으며, 무엇보다도 어떻게 사용하는지 알면 좋겠다고 한다.
      - 사용 방식은 매우 간단한데, 새롭게 만들 모든 컴포넌트에 위에서 만든 타입 표기를 추가하면 된다.
      - props도 새롭게 만들어 사용한다면 제네릭 타입을 추가하고, <> 안에 새로운 props의 타입을 정의하면 된다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-typescript/commit/bcbf83ce00cdea88b2ce8f15b4c0500859f23eb0)

  <br />

  - 데이터 모델 추가하기
    - Todo는 단일 문자열, Todo 목록은 문자열 배열
      - Todo를 객체여야 하는 상황도 얼마든지 생길 수 있다.
      - 객체에 ID와 텍스트를 넣을 수 있다.
        - 제목이나 소제목 같은 것들
      - 할 일에 관한 더 많은 부가 정보를 넣을 수도 있을 것이다.
        - 작성한 사람이나 할 일을 작성한 시간 일이 진행 중인지 아닌지 같은 것들
        - 할 일에 관해 기록할 내용은 아주 많다.
        - 지금 이런 정보를 모두 추가하지는 않고, 코드를 조금 다듬기는 할 것이다.
    - src 폴더 아래에 models 폴더 추가
      - 폴더 이름은 마음대로 해도 문제 없다.
        - models로 이름 지은 이유는 다양한 데이터 모델 즉, 프로젝트에서 사용할 다양한 데이터를 만들 것이기 때문이다.
      - todo.ts 파일도 추가
        - tsx가 아닌 ts 파일로 추가
        - 이유는 여기에는 컴포넌트를 생성하지 않을 것이기 때문이다.
    - todo.ts 파일 내용 구성
      - 이 파일에서 Todo의 형태를 정의할 것이다.
      - 필요한 Todo 타입을 생성
        - type 키워드를 사용
        - interface 키워드도 있으니, 이걸 사용해도 된다.
        - 또는 class를 생성하고 객체를 만들어 사용할 수도 있다.
        - 강의에서는 class를 사용할 것이지만, 다른 방식으로도 가능하다.
      - Todo 클래스를 생성
        - 바닐라 JS에서 했던 것처럼 만들 것이다.
        - 모던 JS는 class를 지원하니까 그 기능을 그대로 사용할 것이다. TS도 지원한다.
        - class의 형태를 정의할 건데, JS에서 했던 방식과 약간 다른 점이 있을 것이다.
        - TS의 class를 사용할 때는 class에 추가할 프로퍼티가 있거나 추가할 속성이 있을 경우, 생성자(constructor)를 통해 추가할 필요가 없다.
          - JS에서 하듯이 할 필요가 없다.
          - class의 중괄호 안에서 바로 추가할 수 있다.
            - 다른 프로그래밍 언어에서 사용하는 방식이다.
            - ex) C#
        - Todo 객체가 언제나 id와 text 필드를 갖도록 설정
          - id 필드를 추가하고, 문자열 타입을 지정
          - text 필드도 추가하고, 역시 문자열 타입
          ```
          class Todo {
            id: string;
            text: string;
          }
          ```
      - Todo 클래스 내용을 구성하고, export
      - id 필드와 text 필드에서 오류가 표시된다.
        - 예시로, text 프로퍼티를 초기화하는 부분이 없고 생성자 값이 할당되지 않았다는 내용을 확인할 수 있다.
        - 이 경고 메시지가 말하는 건 현재 정의된 클래스는 인스턴스화 되어야 한다는 것이다.
          - 이게 클래스를 사용하는 주된 목적이다.
        - 지금 id, text 프로퍼티들은 여기에 추가되고 타입도 지정되었지만 값이 할당되는 부분은 없다.
        - 생성자를 추가해 해당 필드에 값을 할당할 수 있다.
          - 생성자에는 인수가 필요하다.
          - todoText라는 인수를 만들어 준다.
            - `constructor(todoText: string) {}`
            - todoText의 ID는 생성자 안에서 동적으로 만들 것이다.
            - todoText도 문자열 타입일 것이기 때문에 string으로 타입 표기를 추가
      - 프로퍼티에도 타입 표기를 추가했고 생성자의 인수에도 추가했다.
        - 생성자 안에서 this.text에 todoText를 넣어준다.
          - `this.text=  todoText`
        - this.id에는 ID를 만들어서 넣어줄 것인데, 여기서는 Date()로 날짜를 가져와 문자열로 바꿔서 사용
          - `this.id = new Date().toISOString()`
          - 완벽하게 구별되는 ID는 아니지만 이 정도면 충분하다.
        - 이제 새로운 Todo를 만들면 ID는 자동으로 생성될 것이다.
      - Todo 객체에 대한 정의, 즉 class의 정의를 TS 파일에 추가했다.
        - 생김새가 JS에서 봤던 것과 아주 비슷한데 다만 JS에서는 프로퍼티를 선언하지 않았다.
          - 생성자 부분만 만들었다.
            - JS에서는 그렇게 해도 동작한다.
          - 하지만 TS를 사용할 때는 미리 프로퍼티를 정의하고 해당 프로퍼티에 어떤 타입을 가진 값이 저장되는지 명확히 밝혀야 한다.
    - App.tsx에서 내용 구성
      - 예시로, 테스트용 Todo를 몇 개 생성
      - todos를 배열 형태로 생성
        - `const todos = []`
      - 배열 안에서 Todo 클래스를 사용해 객체를 만든다.
        - Todo를 먼저 가져와야 한다.
          - `import Todo from "./models/todo";`
        - Todo 클래스를 사용해 객체를 만들면 된다.
          - JS로 했던 것처럼 하면 된다.
        - new Todo()를 두 번 호출해서 Todo를 두 개 만든다.
          - 그리고 todoText에 값을 넘겨야 한다.
          - `const todos = [new Todo("React"), new Todo("TypeScript")];`
      - 이제 todos는 문자열 배열이 아니라 Todo 객체 배열이다.
        - todos 배열을 Todos items 프로퍼티에 값으로 넘겨야 한다.
        - Todo 객체로 구성된 배열을 받으려면 문자열 배열 대신에, 타입 표기를 변경해야 한다.
          - Todos 컴포넌트에서 지금은 문자열 배열을 받는 걸로 정의되어 있다.
      - 좋은 점은 정의된 클래스가 호출되었을 때 새로운 객체를 생성하는 생성자의 역할만 하는 게 아니라 타입 역할도 한다.
        - class 이름은 타입으로도 사용할 수 있다.
    - Todos.tsx 구성
      - Todos 컴포넌트에서 Todo를 가져온다.
        - `import Todo from "../models/todo";`
      - items에 받을 값을 Todo 배열로 바꾼다.
        - `React.FC<{ items: Todo[] }>`
        - Todo 클래스로 만든 배열
        - 즉, items는 객체로 채워진 배열이고 그 객체는 Todo 클래스의 정의에 부합하는 객체이다.
          - 배열의 객체는 타입은 문자열인 id 프로퍼티를 가질 것이며, 타입은 문자열인 text 프로퍼티도 가질 것이다.
          - 정확히는 클래스를 생성자로 사용해 생성된 객체일 것이다.
          - 객체로 구성된 배열을 items props로 받는 것이다.
      - items에 각 item을 가져와 키에 객체를 넣는 대신 item.id를 넣고 text에는 item.text를 넣을 수 있다.
        - `<li key={item.id}>{item.text}</li>`
    - App.tsx에서 내용 수정
      - todos 배열을 items props 값으로 넣어주면 된다.
        - todos를 Todos 컴포넌트의 items props 값으로 넣으면 된다.
      - `<Todos items={todos} />`
    - 화면에 출력되는 것은 바뀐 것이 없지만 코드는 확실히 바뀌었다.
      - 여러 가지 타입 표기와 여기서 사용한 클래스들 덕분에 굉장히 명확해졌다.
      - 어떤 형태의 데이터가 필요한지 어떤 형태의 컴포넌트가 필요한지 명확해졌다.
      - 개발자로서 코드에 이상이 없고, 구조가 명확하다는 걸 알 수 있다.
      - 이렇게 되면 컴포넌트나 데이터를 잘못 사용하는 일도 훨씬 줄어든다.
      - 앱을 테스트하다 오류를 발견하는 것이 아닌, 오류를 개발 과정에서 미리 수정할 수 있다.
      - 여기서 예시로 잘못된 todos를 넘기면 코드 편집 창에 바로 경고 메시지가 나타나기 때문이다.
        - 앱 실행 중에 갑자기 오류를 알리는 대신 편집 창에서 오류를 먼저 알려준다.
        - 이런 것이 TS의 장점이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-typescript/commit/4448b7df50b92ae51af09ab67aebb85d2b6fdd60)

# 오늘 느낀 점

- 초반 내용까지는 잘 따라갔는데, props 작업하는 것도 문제 없었다고 생각이 되었는데 데이터 모델을 추가하는 부분에서 좀 제대로 이해를 못한 것 같다. 일단 무엇보다 갑자기 class를 사용해서 더 이해를 못한 것도 있고, type이나 interface가 있는데 class로 작업한 이유도 잘 이해가 안되며, 결국 TS를 사용하기 위해선 class를 사용해야 하는 것인지 등등 여러가지 의문이 남았다. 결국 class에서 생성자를 추가할 필요가 없다고 하면서 바로 뒤에서 생성자를 추가해서 작업하는 것도 그렇고 온통 이해가 안되는 내용들 투성이였다고 생각이 된다. 그래서 "연습하기" 강의를 듣기 전에 TS 내용에 대해 복습 및 예습으로 좀 찾아보고 다음으로 넘어가야 할 것 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
