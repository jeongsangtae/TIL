# 오늘 한 일

### React 공부

- Next.js (Pretty deep dive)

  - 사전 렌더링 작동 방식 및 직면한 문제
    - 현재 DB가 없기 때문에 DB가 있다고 가정하고 모의실험해보는 작업
    - HomePage 컴포넌트
      - 더미 데이터 대신에 백엔드에 접근할 때 동작하는 방식대로 동작하도록 변경해보기
      - 페이지가 렌더링될 때 HTTP 요청을 보내기위해 일반적으로 useEffect Hook을 사용
        - 의존성 배열은 비워둔다.
          - 비워두면 컴포넌트가 처음 렌더링 될 때마다 useEffect 함수가 실행되고 그 후엔 실행되지 않는다.
        - 데이터를 가져올 수 있고, 컴포넌트의 상태를 관리할 수 있다.
          - useState Hook을 사용하면 된다.
        - useState를 사용해서 모임 목록을 관리할 수 있다.
          - `const [loadedMeetups, setLoadedMeetups] = useState([])`
        - useEffect에서 HTTP 요청을 보내고, 데이터를 가져온다.
          - 위 작업을 진행하고 나면, setLoadedMeetups를 호출한다.
        - 서버에서 가져온 모임 정보를 컴포넌트의 meetups로 설정한다.
      - 더미 데이터를 가져오는 실습
        - 처음부터 바로 사용할 수 있지만, 서버에서 가져왔다고 가정하고 연습
        - promise가 완료 상태이고, 응답을 받았다면 더미 데이터를 loadedMeetups로 설정
          - `setLoadedMeetups(DUMMY_MEETUPS);`
      - DUMMY_MEETUPS를 loadedMeetups로 설정하고 전달
        - JSX 코드에 loadedMeetups를 전달
          - MeetupList에 meetups prop을 통해서 loadedMeetups를 전달한다.
          - `return <MeetupList meetups={loadedMeetups} />;`
    - HomePage 컴포넌트를 변경한 상태로 확인해보면 시작 페이지에서 달라진게 없다.
      - 다시 불러와도 모든 모임이 시작 페이지에 있다.
      - 실제로 HTTP 요청을 보낸 건 아니다.
        - 하지만 기술적으로 차이가 있다.
      - useEffect는 컴포넌트 함수가 실행되고 난 후에 실행되는 방식으로 작동한다.
        - 여기서 이후 라는 것이 중요하다.
        - 다시 말하면 처음 홈페이지 컴포넌트가 렌더링 될 때 loadedMeetups는 비어있는 배열이다.
        - 그 다음에 useEffect 함수가 실행되고 state를 업데이트한 후에 컴포넌트 함수가 다시 실행된다.
          - state가 바뀌었기 때문에 다시 실행되는 것
        - 실제 데이터를 가지고 목록을 다시 렌더링한다.
        - 이렇게 컴포넌트 렌더링이 두 번 일어나게 된다.
          - 첫 번째 렌더링 사이클에서는 홈페이지 컴포넌트가 처음으로 렌더링 되고, loadMeetups 상태는 초기 상태, 즉 비어있는 배열이다.
      - 이 내용을 강조하는 이유는 두 번의 렌더링 사이클 때문에 검색 엔진 최적화에 문제가 생기게 된다.
        - 페이지 소스를 보면 실제 모임 데이터는 없는 걸 볼 수 있는데, 순서가 없는 리스트는 있는데 이 리스트도 비어있는 상태이다.
        - 화면에 보이는 항목들은 HTML 콘텐츠에 들어 있지 않다.
          - 서버에서 가져온 HTML 페이지에는 콘텐츠가 들어 있지 않다.
          - 항목이 없는 이유는 그것들이 두 번째 컴포넌트 실행 사이클에서만 렌더링 되기 때문이다.
        - Next.js가 자동으로 생성하는 사전 렌더링된 페이지는 두 번째 사이클을 기다리지 않는다.
        - 언제나 첫 번째 렌더링 사이클의 결과를 가져와서 사전 렌더링한 HTML 코드를 반환한다.
          - 여기에는 더미 데이터가 없다.
          - 물론 임시 데이터로는 해봤자 소용이 없다.
          - 하지만 말했듯이 서버에서 데이터를 받아온 상황을 모의 실험 해 본 것이다.
          - 그래서 문제가 생긴 건데, Next.js는 가져올 데이터를 기다리지 않고 완전히 사전 렌더링 된 페이지를 반환한다.
            - 첫 번째 렌더링 사이클의 결과만 반환한다.
            - 첫 번째 렌더링 사이클의 결과는 완전히 빈 페이지일 것이다.
    - 위에서 장황하게 설명한 이유는, 여기서 직면한 문제가 무엇인지 설명해주기 위해서 말해준 것이다.
      - 이 부분은 중요한 문제로 정확하게 이 문제를 이해해야 한다.
      - 다행히도 Next.js는 이 문제의 해결책도 가지고 있다.
      - Next.js에 내장된 주요 기능이 더 있는데, 그 기능으로 이 문제를 정확히 해결할 수 있다.
      - 데이터가 있는 페이지를 사전 렌더링해야 하지만 그 데이터는 내가 기다려야 한다.
        - 다 받아왔을 때 Next.js에 알려야 한다.
      - 어떻게 사전 렌더링으로 데이터를 가져올 수 있는지 다음 시간에 배울 예정
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-nextjs/commit/41f549962c596e3ff9abcfe6056436116e25e07c)

  <br />

  - 정적 페이지에 대한 데이터 가져오기
    - Next.js에는 내장된 페이지 사전 렌더링 기능이 있는데, 이 내장된 프로세스에는 단점이라고 하자면 단점일 부분이 있다.
      - 앞에서 해본 것처럼 사전 렌더링한 페이지는 컴포넌트가 첫 번째 렌더링 사이클을 마친 이후의 스냅샷을 콘텐츠로 가지고 있다.
        - 이건 이미 중요한 데이터가 손실된 상태이다.
      - 어떤 라우터가 있다면 요청은 라우터에 전해지고 페이지로 가는데, 여기에서 사전 렌더링한 페이지를 반환하지만 데이터는 손실되었을 것이다.
      - 이게 이론적으로 SEO, 즉 검색 엔진 최적화에 좋을지 몰라도 항상 좋은 건 아닐 수 있다.
        - HTML 페이지를 받은 후에 React가 받아 가서 페이지에 hydrate라고 부르는 작업을 수행한다.
          - 즉, React가 페이지를 SPA로 만들고 제어하는 것이다.
        - useEffect 함수를 실행할 것이고 데이터를 받아와서 페이지를 업데이트한다.
          - 서버에서가 아닌, 브라우저에서 업데이트한다.
          - 사전 렌더링한 페이지에서도 아니다.
          - 페이지를 브라우저에서 받은 후일 것이다.
          - 따라서 이 경우에는 필요한 모든 데이터가 있는 완전한 대화형 페이지나 앱을 갖게 된다.
    - 초기에 반환된 HTML 코드에 이미 데이터가 포함되도록 데이터가 있는 페이지를 사전 렌더링하려면 내장된 사전 렌더링 프로세스를 미세 조정해야 하고 그에 맞는 설정을 해야 한다.
      - 이를 위해 Next.js는 페이지 렌더링 방법을 제어하는데 사용할 수 있는 두 가지 형태의 사전 렌더링을 제공한다.
    - 사전 렌더링을 제공하는 두 가지 방법
      - 정적 생성과 서버 사이드 렌더링
      - 이 둘은 비슷하게 들릴 수도 있지만, 서로 다른 시점에서 코드가 실행된다.
    - 정적 생성 (Static Generation)
      - 일반적으로 사용하는 접근법
      - 정적 생성에서 페이지 컴포넌트가 사전 렌더링 되는 시점은 애플리케이션을 빌드하거나, Next 프롤젝트를 빌드하는 시점, 즉 프로덕션용으로 빌드하는 시점이다.
      - 정적 생성에서는 기본적으로 요청이 서버에 도달했을 때 서버에서 즉각적으로 페이지를 사전 렌더링하지 않는다.
        - 대신에 개발자가 프로덕션용 사이트를 빌드할 때 사전 렌더링한다.
        - 즉, 사이트가 배포되고 나면 사전 렌더링한 페이지는 변경되지 않는다는 것을 뜻한다.
        - 데이터를 업데이트했는데, 사전 렌더링한 페이지를 변경해야 한다면 해당 빌드 프로세스를 다시 시작하고 다시 배포해야 한다.
        - 이 내용이 안좋게 들릴 수는 있지만, 실제로는 그렇게 나쁘지 않다. 많은 애플리케이션이나 페이지가 항상 바뀌는 것은 아니기 때문이다.
          - 페이지 콘텐츠가 매번 바뀌는 건 아니다.
          - 자주 바뀌어야 한다면 대안이 있다.
    - 정적 생성 다루기
      - 기본적으로 Next.js는 페이지를 마련한다.
        - 기본적으로 이미 정적인 페이지를 생성하고, 기본적으로 빌드 프로세스 중에 페이지를 생성한다.
        - 데이터를 기다려야 한다면 즉, 페이지 컴포넌트에 데이터를 가져와서 추가해야 한다면 페이지 컴포넌트 파일 안에서 특수 함수를 export로 내보내면 된다.
          - 아주 중요한데, 이건 페이지 컴포넌트 파일에서만 작동한다.
          - 다른 컴포넌트 파일은 안된다.
          - pages 폴더 안에 있는 컴포넌트 파일들에서만 가능하다.
      - 함수 export 하기
        - getStaticProps 함수
          - `export const getStaticProps = () => {}`
          - 반드시 getStaticProps라고 해야 한다.
            - 정해진 이름이다.
          - Next.js는 이 이름을 가진 함수를 찾는다.
            - 발견하면 이 사전 렌더링 프로세스 중에 이 함수를 실행한다.
            - 따라서 컴포넌트 함수를 바로 호출하지 않고, 반환된 JSX 스냅샷을 HTML 콘텐츠로 사용한다.
            - 우선 컴포넌트 함수를 호출하기 전에 getStaticProps 함수를 호출한다.
          - getStaticProps라는 이름에서 볼 수 있듯이 이 함수는 실제로 이 페이지에서 사용할 props를 준비한다.
            - props는 페이지에서 필요한 데이터를 포함할 수 있다.
          - getStaticProps는 비동기적으로 설정될 수 있어서 유용하다.
            - 여기에 promise를 반환할 수 있다.
          - 여기서 핵심으로, Next.js는 이 promise가 해결될 때까지 기다린다.
            - 다시 말하면 데이터를 읽어 들일 때까지 기다린다.
            - 그 다음에 컴포넌트 함수에서 사용할 props를 반환한다.
            - 이렇게 하면 컴포넌트 함수가 실행되기 전에 데이터를 읽어 들일 수 있어서 컴포넌트를 필요한 데이터와 함께 렌더링할 수 있다.
        - getStaticProps 함수 내의 코드에 대한 내용
          - 일반적으로 서버에서만 돌아가는 어떤 코드든지 전부 실행할 수 있다.
          - 여기에서 파일 시스템에 접근할 수도 있고, DB에 안전하게 연결할 수도 있다.
          - getStaticProps 함수에서 작성하는 모든 코드는 클라이언트 측에 들어가지 않기 때문에 클라이언트 측에서 절대 실행되지 않는다.
            - getStaticProps 함수 내의 코드는 빌드 프로세스 중에 실행되기 때문이다.
          - 서버에서도, 특히 방문자인 클라이언트 측에서도 실행되지 않는다.
          - getStaticProps 함수에서 쓴 코드는 절대 방문자의 컴퓨터에 도달하지 못한다.
            - 방문자 컴퓨터에서 실행될 수가 없다.
        - getStaticProps 함수 구성
          - 원하는 모든 작업을 수행할 수 있다.
            - 예로, API나 DB에서 데이터를 가져오거나 파일 시스템의 일부 파일에서 데이터를 읽어올 수도 있다.
          - 필요한 데이터를 얻는 작업을 모두 완료했으면, getStaticProps에서 객체를 반환해야 한다.
            - 항상 객체를 반환해야 한다.
          - 객체에서 다양한 항목을 구성할 수 있는데, 가장 중요한 것은 일반적으로 여기에 props 프로퍼티를 설정한다.
            - 이름은 반드시 props 여야 한다.
              - `return { props: }`
            - 여기에 다른 객체를 저장하는데, 페이지 컴포넌트 함수에서 받는 props 객체가 된다.
              - `const HomePage = (props) => { ... }`
              - props 객체를 받는데, getStaticProps에서 props로 설정한 객체이다.
          - props 객체에 meetups 키를 넣을 수 있는데, props 객체의 구조는 내 마음대로 정할 수 있다.
            - 여기서는 더미 데이터를 저장
            ```
            export const getStaticProps = () => {
              // fetch data from an API
              return {
                props: {
                  meetups: DUMMY_MEETUPS
                },
              };
            };
            ```
          - 위처럼 하면 getStaticProps에서 더미 데이터를 읽어 들이고 준비한 다음 페이지 컴포넌트에서 사용할 props로 설정된다.
            - `const HomePage = (props) => { ... }`
            - 페이지 컴포넌트의 props로 설정되는 것을 말함
        - 페이지 컴포넌트 구성
          - 페이지 컴포넌트에서는 이제 state를 관리할 필요가 없고, useEffect도 필요하지 않는다.
            - 이제 데이터를 props에서 받기 때문이다.
          - MeetupList 컴포넌트에 전달되는 meetups props도 변경된다.
            - `return <MeetupList meetups={props.meetups} />;`
            - `.meetups`는 getStaticProps에서 추가한 meetups 프로퍼티에서 온 것이다.
      - 이렇게 하면 클라이언트에서 서버 쪽으로, 정확히 말하면 빌드 프로세스 과정 쪽으로 데이터를 가져올 수 있다.
    - 저장하고 페이지를 다시 읽어오면 여전히 모임들이 보이고, 페이지 소스에서 비어있던 순서가 없는 리스트는 보이지 않고 이미지, 제목 등이 들어 있는 항목들이 순서가 없는 리스트에 있는 것을 확인할 수 있다.
      - 사전 렌더링도 했고, 전체 HTML 코드도 포함하고 있게 된다.
      - 당연히 검색 엔진에도 좋아졌다.
      - 이제 클라이언트 측 컴포넌트의 두 번째 렌더링 사이클에서 데이터를 받는 것이 아니라, 초기에 페이지를 사전 렌더링하기 전에 빌드 프로세스에서 받기 때문이다.
    - **사전 렌더링으로 데이터 가져오기**는 굉장한 장점이자 Next.js의 주요 기능중 하나이다.
      - **getStaticProps**는 Next.js로 작업할 때 많이 사용할 함수일 것이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-nextjs/commit/f58e243192ce61a49120e668f45a49b25106c847)

  <br />

  - 정적 사이트 생성(SSG)에 대한 추가 정보
    - getStaticProps를 완전히 이해하고, 이것으로 무엇을 할 수 있는지 알아보기 위해 dev 서버는 잠시 끊고, npm run build를 실행
      - npm run build는 빌드 명령으로, Next.js 사이트를 배포하기 전에 실행해야 하는 것이다.
      - 지금 배포하지는 않을 거지만, 실행해 보는 건 유용하고 흥미롭다고 한다.
      - 프로덕션 빌드를 구축하고, 프로덕션 빌드를 만들고, 결과가 나온다.
    - npm run build를 하고 난 후 결과
      - 정적 페이지 몇 개를 생성했고, 어떤 페이지를 만들었는지도 볼 수 있다.
        - 루트 페이지를 만들었다는 걸 알 수 있다.
        - 동적 페이지도 만들고, new-meetup 페이지도 만들었다.
        - 404 페이지도 만들어 졌는데, 404 페이지는 기본 값으로 자동으로 만들어진다.
          - 유효하지 않은 URL을 입력한 경우에 사용한다.
      - 페이지 옆에 아이콘들도 있다.
        - 하나는 채워진 상태이고, 나머지는 비어있는 상태
      - 더 밑으로 가면 범례가 나와있다.
        - 채워진 원은 정적으로 생성된 사이트(SSG)를 의미한다.
          - `(SSG) prerendered as static HTML (uses getStaticProps)`
          - SSG는 정적 사이트 생성 (Static Site Generation)의 약자이다.
          - HTML로 자동으로 생성된 것이다.
          - 추가로, 나는 JSON이 없는데 JSON은 페이지가 SPA로 전환되면 데이터를 미리 가져오는데 사용된다.
        - 비어있는 원은 정적 생성을 의미한다.
          - `(Static) prerendered as static content`
          - SSG와 거의 비슷한데, 유일한 차이점은 여기에는 초기 props가 없다는 것이다.
          - 따라서 가져온 초기 데이터가 없다.
      - 실제로 루트 페이지에서만 데이터를 가져온다.
        - getStaticProps를 추가한 페이지이기 때문이다.
        - 그래서 루트 페이지는 채워진 원으로 표시되어 있다.
      - new-meetup 페이지는 아무 데이터도 가져올 필요가 없다.
        - 양식을 렌더링할 뿐이기 때문이다.
        - 아무 데이터도 필요 없고, 서버에서 어떤 데이터도 받아오지 않는다.
        - new-meetup 페이지는 늘 아무 콘텐츠가 없는 정적 페이지로 남아 있다.
      - 동적 페이지인 `[meetupId]`페이지는 나중에 SSG 페이지로 바꿀 예정이다.
        - 지금은 시작 페이지, 즉 루트 페이지만 정적으로 생성된 사이트이다.
    - getStaticProps를 사용할 때 생길 수 있는 문제에 대해 생각해보기
      - 어떤 웹 사이트에서 마주할 수 있는 꽤 심각한 문제 중 하나는 데이터에 최신 정보는 없을 수 있다는 것이다.
        - 페이지는 빌드 프로세스에서 생성된다. 그리고 나서 배포한다.
        - DB에 더 많은 모임 정보를 추가해도 사전에 생성된 페이지는 그걸 모른다.
        - 클라이언트 쪽에서 데이터를 가져오지 않는다면 항상 예전 모임만 보게 된다.
          - 이건 문제가 될 수 있다.
        - 데이터가 변할 때마다 사이트를 다시 빌드해서 다시 배포할 수도 있다.
        - 개인 블로그 같은 웹 사이트에서는 괜찮은 방법일 수 있다.
          - 이런 데이터는 아주 빈번하게 바뀌지 않기 때문이다.
        - 데이터가 자주 변한다면 getStaticProps 함수의 반환된 객체에 프로퍼티를 하나 추가해야 한다.
          - `revalidate 프로퍼티`
    - revalidate 프로퍼티
      - getStaticProps에서 반환된 객체에 revalidate 프로퍼티를 추가하면 점진적 정적 생성이라는 기능을 사용할 수 있다.
      - revalidate에는 숫자가 필요한데, 10이라고 가정하고 설명
        - `revalidate: 10`
        - 이 숫자는 요청이 들어올 때, 이 페이지를 다시 생성할 때까지 Next.js가 대기하는 시간을 초 단위로 표시한 것이다.
      - revalidate에 어떤 숫자가 설정되어 있으면 페이지는 빌드 프로세스 중에 바로 생성되지 않는다.
        - 생성되긴 하겠지만 바로는 아니다.
        - 적어도 페이지에 요청이 있다면 서버에서 몇 초 간격으로 생성될 것이다.
        - revalidate 값이 10이라면 이 페이지에 요청이 들어오면 적어도 10초마다 서버에서 페이지를 다시 생성한다는 것이다.
          - 다시 만들어진 페이지들은 사전에 생성했던 오래된 페이지를 대체한다.
        - `revalidate: 10` 이렇게 하면 데이터가 절대 10초보다 오래되지는 않는다.
      - revalidate에 사용하는 숫자는 데이터 업데이트 빈도에 따라 결정하면 된다.
        - 데이터가 한 시간마다 변하는 경우엔 3600으로 설정하면 된다.
        - 항상 변하고 있다면 1초로 해야 한다.
        - 이 숫자를 무엇으로 설정하든 해당 페이지는 배포 후 서버에서 때때로 다시 사전 생성할 것이다.
        - 일부 데이터가 변경되었다고 해서 매번 다시 빌드하고 배포할 필요는 없다.
      - 반드시 알아둬야 할 중요한 기능이고, 위의 예시와 같이 설정할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-nextjs/commit/be5c7bb3f73456a1cd2f3e3154baea54bd68443b)

  <br />

  - "getServerSideProps"를 사용하여 서버 측 렌더링(SSR) 탐색하기
    - revalidate로는 페이지가 배열 다음에 규칙적으로 업데이트되게 할 수 있다.
      - 하지만 주기적인 업데이트로도 부족할 수 있다.
      - 요청이 들어올 때마다 페이지를 다시 만들어야 할 때가 있다.
        - 따라서 서버가 배열된 뒤에 페이지를 동적으로 사전 생성해야 한다.
        - 빌드 프로세스가 아니고, 매초도 아니다. 요청이 있을 때만이다.
        - 이렇게 하는 것이 목표라면 다른 대인이 있다.
    - getStaticProps 대신 getServerSideProps를 사용
      - `export const getServerSideProps = async () => {};`
      - 이것 또한 getStaticProps처럼 지정된 이름이다.
        - next.js가 찾게 된다.
      - getStaticProps와 차이점이라면 getServerSideProps 함수는 빌드 프로세스 중에는 실행되지 않는다.
        - 하지만 대신 배열 다음에 서버에서 실행된다.
      - getServerSideProps 함수 또한 여전히 객체를 return한다.
        - props 프로퍼티도 포함
        - getServerSideProps 함수는 여전히 페이지 컴포넌트에 props를 받기 때문이다.
      - 여전히 API에서 데이터를 패치한다. 아니면 파일 시스템일 수도 있다.
      - getServerSideProps 함수에 쓰는 코드는 어떤 코드라도 서버에서 실행된다.
        - 클라이언트는 아니다.
        - 따라서 여기서 서버 사이드 코드를 실행할 수 있다. 그리고 자격을 이용하는 운영을 실행할 수 있다.
          - 사용자에게는 노출되지 않는다.
          - 코드는 서버에서만 실행되기 때문이다.
      - props 객체 구성
        - `meetups: DUMMY_MEETUPS`
        - meetups 키가 있고, 더미 데이터가 저장된다.
      - getServerSideProps에는 revalidate를 설정할 수 없다.
        - 말이 안되기 때문이다.
        - getServerSideProps 함수는 요청이 들어올 때마다 실행된다.
          - 따라서 시간을 지정해서 revalidate 할 필요가 없다.
      - getServerSideProps에서 할 일은 매개변수를 받는다.
        - context 매개변수를 받는다.
        - 추가로, getStaticProps도 받는다고 한다.
          - context 매개변수인지는 정확히 모르겠음
          - 이 부분은 나중에 다시 보기로 함
      - context 매개변수에서 요청 객체에 접속할 수 있다. 그리고 응답 객체가 돌아온다.
        - `const req = context.req`
        - `const res = context.res`
        - 이 부분은 전에 Node.js와 express로 작업한적이 있다면 익숙할 거라고 한다.
          - 거기에는 요청 객체와 응답 객체가 있고, 미들웨어에서 함께 작업한다.
        - 콘크리트 요청 객체에 접근하는건 도움이 될 수 있다.
          - 예로, 인증 작업을 할 때나 세션 쿠키를 확인할 때나 그런 때에 도움이 된다.
          - 이건 Next.js에서 보여줄건데 여기서는 조금 어려울 것이라고 한다.
        - 들어오는 요청에 접근하고 헤더와 필요하다면 요청 비다에도 접근한다.
          - 그러면 추가 데이터나 정보를 준다.
            - getServerSideProps에서 실행되는 코드를 위해 필요한 정보
        - 응답 객체에서는 응답을 return하지 않는다.
          - 대신 props 키로 객체를 return한다.
          - props 키가 페이지 컴포넌트 함수 props를 저장하고 있다.
      - 이와 같이 getServerSideProps를 이용할 수 있는 것이다.
        - 페이지를 위한 데이터를 준비하는 것이다.
    - getServerSideProps를 사용해서 다 저장한 뒤에 시작 페이지를 리로드하면 작동하는 걸 볼 수 있다.
      - 페이지 소스를 보면 데이터가 있는 걸 확인할 수 있다.
      - 정렬되지 않은 리스트에 리스트 아이템이 있다.
      - 정확히 배운 대로 작동한다.
        - 하지만 페이지가 요청이 들어올 때마다 사전 생성된다.
    - getStaticProps와 getServerSideProps 중에 어떤 걸 사용할 것인가 ?
      - getServerSideProps이 더 좋아 보일 수 있다.
        - 모든 요청을 실행하기 떄문이다.
          - 하지만 그게 단점이 될 수 있다.
          - 요청이 들어올 때까지 페이지가 만들어지기 기다려야 한다는 뜻이기 때문이다.
        - 항상 바뀌는 데이터가 없다면, 매초 여러 번 바뀔 것이다.
      - 요청 객체에 접속할 필요가 없다면, getStaticProps이 좀 더 낫다.
        - ex) 인증
        - 여기서는 HTML 파일을 사전 생성하기 때문이다.
          - 그 파일은 CDN에 저장되고 서브된다.
        - 요청이 들어올 때마다 데이터를 다시 만들고 패치하는 것보다 빠르다.
      - 내 페이지가 getStaticProps일 때 더 빠를 것이다.
        - 항상 다시 만드는 대신에 캐시하고 다시 사용하기 떄문이다.
      - 콘크리트 요청 객체에 접속해야 한다면 getServerSideProps 사용해야 한다.
        - getStaticProps에서는 요청과 응답에 접속하지 않기 때문이다.
      - 매초 여러 번 바뀌는 데이터를 가지고 있다면 revalidate도 도움이 안 될 것이다.
        - 그 때는 getServerSideProps가 좋은 선택이다.
      - 프로젝트의 MeetupList에서 getServerSideProps는 좋은 선택이 아니다.
        - 주기적으로 바뀌는 데이터가 아니기 때문이다.
        - 여기서는 들어오는 요청에 작업할 필요도 없다.
    - getServerSideProps를 커맨드 아웃하고, getStaticProps를 커맨드 인
      - 이렇게 하면 캐시를 이용할 수 있고, 페이지를 여러 번 사전 생성할 필요가 없다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-nextjs/commit/236eb38633c106ae75b190775a60ccc6fd83fafa)

  <br />

  - SSG 데이터 가져오기를 위한 Params 작업하기
    - getStaticProps와 getServerSideProps에 관해서 많은 얘기를 했는데, 이것들은 아주 중요한 개념이다.
      - Next.js에 있는 아주 중요한 함수로, 항상 사용할 것이다.
      - 풀 블록 작업을 할 때 두 가지 함수를 항상 사용한다.
    - MeetupDetail에서 getStaticProps 또는 getServerSideProps 사용하기
      - getStaticProps와 getServerSideProps 어느 것이 나을 까?
        - 데이터가 얼마나 자주 바뀌는지에 따라 다르다.
        - 그리고 요청 객체에 접속하는지도 관건이다.
        - Meetup 데이터는 자주 바뀌지는 않고, 그리고 Meetup 데이터를 바꾸는 부분도 없고, Meetup을 추가만 할 수 있다.
          - Meetup 데이터를 바꾸더라도 Meetup이 매초 여러 번 바뀌지는 않을 것이다.
        - 위 내용을 종합하면 getStaticProps가 더 좋다고 생각이 된다.
      - getStaticProps 함수 구성
        - async를 추가
        - props와 함께 return
        - props에서 meetupData props를 입력
          - 이게 Next.js 객체가 될 것이다.
          - MeetupDetail로 전달하는 하드 코딩된 데이터를 가져와서 사용
          ```
          return {
            props: {
              meetupData: {
                image:
                  "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Hong_Kong_Harbour_Night_2019-06-11.jpg/1200px-Hong_Kong_Harbour_Night_2019-06-11.jpg",
                id: "m1",
                title: "A First Meetup",
                address: "Some Street 5, Some City",
                description: "The meetup description",
              },
            },
          };
          ```
          - 이 내용은 props 데이터가 된다. 컴포넌트 함수에 보낸 것이다.
    - 여기서 작은 문제가 있는데, 이게 동적 페이지라는 걸 기억해야 한다.
      - 따라서 API에 가서 single meetup에 데이터를 패치할 때 meetup을 확인할 방법이 필요하다.
        - 예로, ID 같은 것이 필요하다.
        - 다행히도 ID가 URL에 인코드되어 있다.
    - router Hook을 이용해서 router 객체에 접속하고 query 프로퍼티를 사용하면 된다.
      - 하지만 문제는 useRouter는 컴포넌트 함수에서만 쓰일 수 있다는 것이다.
        - getStaticProps는 불가능하다.
        - getStaticProps에서는 React Hook을 사용할 수 없다.
        - 따라서 meetup ID를 얻을 수 없다.
        - useRouter을 이용해서 URL에서 얻을 수 없다.
    - getStaticProps에서는 useRouter Hook을 사용할 필요가 없다.
      - context 매개변수를 사용하면 된다.
      - getStaticProps를 이용할 때 context는 요청과 응답을 저장하지 않는다.
        - 하지만 params 키가 있다.
          - `context.params`
      - `const meetupId = context.params.meetupId`
        - 이게 ID 객체가 된다.
        - 그리고 대괄호 사이에 있는 건 프로퍼티가 된다.
        - 그리고 value는 URL에 인코드 되어 있다.
        - `meetupId`는 `context.params.meetupId`에 접속할 수 있다.
        - `meetupId`가 대괄호 사이에 가지고 있는 ID이기 때문이다.
        - 이게 콘크리트 meetupId가 된다.
      - console.log로 meetupId를 확인해보면 알 수 있다.
        - `console.log(meetupId)`
        - 콘솔 로그로 인해 작동하는지 파악할 수 있다.
      - id 프로퍼티에서 meetupId로 설정해준다.
        - `id: meetupId`
        - 컴포넌트 함수에 노출하고 싶다면 이렇게 해줘야 한다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-nextjs/commit/9cff9ebd348d9cd2292859d176cfcdd6198e1331)

<br />

# 오늘 느낀 점

- React 방식을 사용해서 구성했을 때 발생하는 사전 렌더링 문제에 대해 알아보고 그 문제를 해결하기 위해 2가지 방법을 사용해서 연습해보았다. 결국 이 사전 렌더링 문제를 처리하는 이유는 React 방식은 페이지 소스에서 내용이 보여지지 않기 때문에 SEO에 좋지 못하기 때문이다. 그래서 정적 생성과 SSR을 사용해서 처리하면 페이지 소스도 확인할 수 있고 SEO도 유지할 수 있기 때문에 거의 필수로 사용된다고 할 수 있다. 정적 생성과 SSR을 사용하는 함수의 이름은 변경할 수 없고, 정해진 이름을 사용해서 구성을 해야 하지만, 이름이 명확해서 어떤 역할을 하는지 확실하게 알 수 있다. 그리고 정적 생성과 SSR은 처리해야 하는 데이터가 어떤 식으로 변경되는 지에 따라 둘 중에 어떤 것을 사용할 지 결정되는데, 서로 장단점이 있고 상황에 맞게 사용하면 된다. 이렇게 정적 생성과 SSR은 Next.js에서 아주 중요한 기능이기 때문에 꼭 기억하고 사용할 줄 알아야 한다고 생각된다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
