# 오늘 한 일

### React 공부

- React 앱에 애니메이션 넣기

  - 스크롤 기반 애니메이션
    - 시작 페이지를 보면 무척 단조로운 것을 확인할 수 있다.
      - 단조로움을 좀 줄이기 위해 이미지와 시작 페이지의 전체 영역에 애니메이션을 추가
      - 패럴랙스를 추가할 건데, 스크롤 할 때 서로 다른 이미지들이 서로 다른 속도로 움직이는 효과를 적용해 더 세련된 느낌을 준다.
        - 프레이머 모션을 활용하면 꽤 간단하게 구현할 수 있다.
    - pages 폴더의 Welcome.jsx 에서 첫 번째 이미지 작업
      - div, img 2개를 애니메이션화 해야 한다.
        - 사용자가 얼마나 스크롤하는지에 따라서 애니메이션이 적용되어야 한다.
      - motion 컴포넌트 import
      - motion.div, motion.img로 변경
      - 까다로운 부분은 애니메이션을 적용할 실제 값을 가져오는 것이다.
        - 지금은 고정 코드화된 애니메이션 값이 없기 때문에 animate의 y에 고정된 값을 주거나 할 수가 없다.
          - 사용자가 스크롤할 때 animate 같은 값은 바뀌게 되기 때문이다.
        - 고정된 값을 주는 대신 사용자가 얼마나 스크롤을 내렸는지 파악할 방법이 필요하다.
          - 해당 정보를 애니메이션 값으로 전환해서 div와 이미지에 반영해야 한다.
            - 프레이머 모션을 활용하면 아주 간단한 작업이다.
          - 이 작업에 아주 유용하게 쓸 수 있는 Hook을 제공하는데, 첫 번째는 useScroll Hook, 두 번째로 중요한 Hook은 useTransform Hook
      - useScroll Hook
        - 스크롤 이벤트를 듣고 사용자가 스크롤을 얼마나 내렸는지 파악하도록 도와준다.
        - 이 Hook은 몇 가지 유용한 속성을 지닌 객체를 return한다.
          - scrollY 속성은 사용자가 수직축을 따라 스크롤을 얼마나 내렸는지 px로 알려준다.
          - 수평축에 쓸 수 있는 scrollX도 있다.
          - scrollYProgress 속성은 상대적인 스크롤링 값을 제공한다.
            - 값은 0에서 1사이에 있고 1은 사용자가 완전히 아래까지 스크롤을 내렸음을, 0은 전혀 스크롤을 내리지 않았음을 의미한다.
        - 여기에서는 scrollY와 px의 절댓값을 얻을 것이다.
          - 그 다음 px 값이 애니메이션이 쓰일 수 있는 값으로 전환될 것이다.
      - useTransform Hook
        - 애니메이션에 사용할 수 있는 값으로 전환해준다.
          - 예로, 스크롤에서 얻은 값을 y 축을 따라 이동하는 애니메이션에 반영할 수 있는 값으로 전환해주는 것이다.
        - useTransform이 취해야 하는 값
          - 변환되어야 하는 값을 먼저 취한다.
            - 여기에서는 scrollY의 값, 즉 사용자가 스크롤을 내린 만큼에 해당하는 px 값
            - scrollY는 사용자가 스크롤을 내린 px 수라는 것을 잘 기억해야 한다.
          - 두 번째 값으로 중단점으로 구성된 배열을 취한다.
          - 세 번째 값으로는 중단점들과 그 중단점들 사이에 있는 값들이 변환되어야 하는 값의 배열이 들어간다.
          - `useTransform(scrollY, [], [])`
      - 요소를 이동시키기 전에 불투명도를 적용한 애니메이션부터 시작
        - 불투명도로 시작한 다음 스크롤 값을 불투명도 값으로 전환하면 useTransform Hook을 이해하는데 조금 더 도움이 된다고 한다.
        - 사용자가 스크롤을 내릴수록 이미지가 점점 더 옅어지다가 결국에는 완전히 투명해지도록 해야 한다.
      - img 작업
        - 스크롤을 충분히 내리면 값이 0이 되어야 하고, 처음에는 잘 보이도록 1로 설정해야 한다.
          - ex) `animate={{opacity: }}`
        - 따라서 스크롤을 내림에 따라 scrollY 값이 1과 0 그리고 그 사이의 모든 값이 되도록 변환해야 한다.
          - 이게 useTransform이 해주는 역할이다.
        - useTransform 구성
          - 페이지 상단에서 시작할 경우 초기 값은 0이 된다.
            - 하지만 어느 시점에 수직축을 따라 200px 정도 스크롤을 내리게 된다.
            - `useTransform(scrollY, [0, 200], [])`
          - px 값을 처음에는 불투명도 1로 변환해야 한다.
            - 스크롤을 내리지 않은 상태에선 도시 이미지가 완전히 보일 것이다.
            - 불투명도가 0.5가 되면 50% 정도 투명해진다.
              - 즉, 스크롤을 200px 내리면 50% 투명해지는 것이다.
              - 중간 값은 프레이머 모션이 알아서 보관해준다.
            - `useTransform(scrollY, [0, 200], [1, 0.5]);`
          - 이것이 useTransform을 활용해 px 값을 불투명도 값으로 변환하는 방법이다.
          - 현재 여기까지 구성된 것은 값을 두 개만 넣었는데, 꼭 두 개만 넣을 수 있는 것은 아니다.
            - 세 번째 중단점을 300, 네 번째이자 마지막을 500을 넣어준다.
            - 변환된 배열에도 상응하는 값을 추가해줘야 한다.
              - 300px을 내린 다음에도 불투명도는 0.5로 유지, 사용자가 200px 이상 스크롤을 내려도 불투명도는 변함없게 된다.
              - 마지막 값으로 0을 넣으면 300px이 지나고 500px이 될 때까지 불투명도는 0.5에서 0으로 변해가게 된다.
            - `const opacityCity = useTransform(scrollY, [0, 200, 300, 500], [1, 0.5, 0.5, 0]);`
          - 실제로는 스크롤할 때마다 컴포넌트 함수를 다시 렌더링 하지 않도록, motion 값 객체로 감싼다.
            - 하지만 컴포넌트 함수를 다시 렌더링 하지 않고도 뒷단에서 변환된 값을 관리한다.
            - 전체 애니메이션이 컴포넌트 렌더링 사이클에 영향을 미치지 않도록 한다.
            - 이 내용을 꼭 기억해둬야 한다.
          - 이미지에 대한 불투명도를 opacityCity로 설정하고, 이 opacityCity 값을 이미지의 애니메이션 업데이트에 사용할 수 있다.
        - 이번에는 animate 속성을 활용하지 않는다. 대신 style 속성을 사용한다.
          - motion 컴포넌트는 style 속성을 지원하는데, 이건 일반 컴포넌트도 지원하는 속성으로, 이 style은 좀 더 향상된 속성이다.
          - 프레이머 모션이 지켜보는 속성으로, style 속성에 적용된 값이 변할 때 프레이머 모션이 자동으로 애니메이션을 플레이해서 새 값을 반영한다.
          - style 속성은 useTransform에서 얻은 결과와 함께 사용해야 한다.
            - 말했듯이 useTransform 값들은 뒷단에서 프레이머 모션이 관리하고 있고, 값이 변할 때 컴포넌트 함수는 재실행되지 않는다.
            - 따라서 animate에는 useTransform과 같이 특수한 값을 넣어 사용할 수가 없다.
            - 하지만 style 속성은 가능하다.
          - opacity에 opacityCity를 넣을 수 있다.
            - `style={{ opacity: opacityCity }}`
            - 이러면 프레이머 모션이 값의 변화를 감지하고 시작 페이지의 컴포넌트가 재실행되지 않아도 자연스럽게 이미지 컴포넌트에 애니메이션을 적용할 것이다.
    - 저장하고 시작 페이지를 다시 로딩하고 스크롤을 내리면 배경의 도시 이미지가 차츰 투명해지다가 어느 지점에 이르면, 사라지는 것을 확인할 수 있다.
      - devtool에서도 확인할 수 있는데, 스크롤을 내릴 때 이미지의 불투명도의 값이 변하는 것을 확인할 수 있다.
      - 이 방식이 스타일을 업데이트하고 프레이머 모션이 스크롤링 값을 기반으로 애니메이션을 플에이 하는 방식이다.
        - scroll 값을 style 속성에 사용할 수 있는 특수한 값으로 변환해서 구성
        - 물론 이미지의 불투명도를 조절하는 데만 이 기능을 쓸 수 있는 건 아니다.
    - pages 폴더의 Welcome.jsx 에서 첫 번째 이미지 추가 작업
      - 이미지의 y 위치를 변경하는 데도, 즉 수직축을 따라 위치를 이동시키는 데도 사용할 수 있다.
      - useTransform을 사용해서 스크롤 값에 따라 변환
        - 범위는 0에서 200
        - y축의 이동 범위는 원래 위치인 0에서 -100으로 이동
          - 이러면 위로 살짝 올라가게 된다.
        - `const yCity = useTransform(scrollY, [0, 200], [0, -100])`
      - 이미지의 style 속성에 y에 대한 값으로 yCity를 넣는다.
        - `style={{ opacity: opacityCity, y: yCity }}`
    - 저장하고 확인해보면 아주 자연스러운 패럴랙스 효과가 연출되는 것을 볼 수 있다.
      - 배경의 도시 이미지와 슈퍼 히어로 이미지, 텍스트가 다른 속도로 움직이는 것을 확인할 수 있다.
      - 도시 이미지를 다른 범위 다른 픽셀에 매핑했기 때문에 스크롤 위치에 따라 애니메이션이 적용된다.
    - pages 폴더의 Welcome.jsx 에서 두 번째 이미지 작업
      - 첫 번재 이미지와 같은 효과를 두 번째 이미지에도 적용
      - 두 번째 이미지에서 스크롤은 같은 범위를 적용하고, 이동 범위는 0에서 -150으로 다르게 연결
        - 스크롤을 내릴 때 두 번째 이미지가 첫 번째 이미지보다 더 위로 올라가게 된다.
        - `const yHero = useTransform(scrollY, [0, 200], [0, -150]);`
      - opacity 관련된 범위는 0 다음 300, 500으로 설정, 불투명도는 300px까지 계속 보이게 한 다음 300을 지나 500까지 서서히 투명해지도록 해준다.
        - `const opacityHero = useTransform(scrollY, [0, 300, 500], [1, 1, 0]);`
      - 두 번째 이미지에 style 속성을 추가하고, opacity에는 opacityHero, y에는 yHero를 연결해준다.
        - `style={{ opcity: opacityHero, y: yHero }}`
    - pages 폴더의 Welcome.jsx 에서 텍스트 크기 작업
      - y축을 따라 변하는 스크롤 위치를 변환하고, 범위는 0에서 300, 처음에는 원래 크기인 1에서 1.5로 커지도록 구성
        - 300px이 될 때까지 50% 더 커진다.
        - `const scaleText = useTransform(scrollY, [0, 300], [1, 1.5]);`
      - 값 할당
        - motion.div에 style 속성을 추가해서 scale에 scaleText를 할당
        - `<motion.div id="welcome-header-content" style={{ scale: scaleText }}>`
      - 텍스트에서도 y축을 따라 움직이도록 해줘야 한다.
        - useTransform으로 scrollY를 변환하고 범위는 0, 200, 300, 500으로 설정하고 이동 범위는 0, 50, 50, 300으로 연결
          - 200~300px 사이에서 텍스트는 기존 위치에서 50px만 내려가 있는 상태가 된다.
          - 300~500px 사이에는 더 아래로 내려간다.
        - `const yText = useTransform(scrollY, [0, 200, 300, 500], [0, 50, 50, 300]);`
      - div의 style 속성에서 y에 yText를 할당
        - `<motion.div ... style={{ scale: scaleText, y: yText }}>`
    - 저장하고 페이지를 다시 로딩하면 아주 멋진 패럴랙스 효과가 적용된 것을 확인할 수 있다.
      - 히어로와 도시 이미지가 서로 조금 다른 속도로 움직이고, 텍스트는 스크롤을 내리면 점점 커진다.
      - 하단의 텍스트 위에 자리할 때까지 텍스트가 오게 된다.
    - 이번 강의를 통해 프레이머 모션을 사용하면 스크롤 값을 애니메이션에 연결 가능한 값으로 변환해 적절한 애니메이션을 적용하도록 하는 작업이 생각보다 쉽다는 걸 이해하고 가면 좋다.
    - 추가 내용: 패럴랙스 효과란 ?
      - 패럴랙스 효과는 사용자가 특정 행동을 취할 때 여러 요소가 서로 다른 속도로 움직이도록 하여 웹 페이지에 깊이와 움직임이 있는 듯한 착각을 불러일으키는 데 사용되는 기법이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/d2e1b0024404e003aa23eebd8975cfb5092976da)

  <br />

  - 다른 접근법: ReactTransitionGroup으로 작업하기
    - 여기서부터 나머지 강의는 이전 강좌에서 가져온 것으로, 당시에 React 앱에서 애니메이션을 제어하는데 ReactTransitionGroup이라는 다른 서드 파티 패키지를 사용했는데, 이 방식은 지금도 유효하므로, 이전 강의를 그대로 두었다고 함
    - 프레이머 모션으로 충분하다고 생각되면 ReactTransitionGroup 강의는 건너 뛰어도 괜찮다고 하는데, 아무래도 실적용을 하는데 프레이머 모션을 사용할 지, ReactTransitionGroup를 사용할 지 모르기 때문에 일단은 모듈 소개를 듣고, 내용도 조금 들어보는 게 좋다고 생각되어 진행할 생각이다.
      - 만약 사용하기 복잡하고 프레이머 모션이 훨씬 유용할 것 같다고 판단되면 다음 섹션으로 넘어갈 생각이다.
    - ReactTransitionGroup
      - 전환 시작 및 종료를 정의하는데 유용하고 간단한 구성 요소를 노출한다고 한다.
      - ReactTransitionGroup는 React-Motion과 같은 애니메이션 라이브러리가 아니며, 자체적으로 스타일에 애니메이션을 적용하지 않는다.
        - 대신 전환 단계를 노출하고 클래스 및 그룹 요소를 관리하며 유용한 방식으로 DOM을 조작하여 실제 시각적 전환 구현을 훨씬 쉽게 만든다고 함
      - 설치
        - `npm install react-transition-group --save`
        - `yarn add react-transition-group`

  <br />

  - 모듈 소개
    - React 앱과 컴포넌트들에 애니메이션을 적용하는 방법을 알아보는 시간
      - 정적인 스타일과 컴포넌트에서 동적인 스타일과 컴포넌트로 넘어가는 방법에 대해서 배우는 시간
      - 매끄러운 전환과 단순하지만 보기 좋은 애니메이션으로 더 나은 UX로 이어질 수 있도록 해준다.
    - CSS 전환 및 애니메이션에 대해 알아볼 것이며, 어떤 경우에 이것들 만으로 충분한지와 어떤 경우엔 이것들 만으로는 부족한지, 왜 오직 CSS 애니메이션 만으로는 때때로 해결할 수 없는지에 대해 알아볼 예정
    - 사용할 수 있는 몇몇의 타사 라이브러리에 대해서도 알아볼 예정
      - 여기서 특정 타사 라이트러리를 사용할 것이다.
      - 이것을 사용하면 React 컴포넌트에 애니메이션을 적용할 수 있다.
    - 데모 프로젝트가 있는데, 여기에서는 함수형 컴포넌트와 Hook이 아닌, 클래스 기반 컴포넌트를 사용한다.
      - 이유는 단순히 데모 프로젝트를 이미 구 버전에서 만들었기 때문이라고 한다.
        - 그 때 클래스형 컴포넌트만을 사용했다고 한다.
    - 이 프로젝트를 진행하는 것은 꽤 수월할 거라고 한다.
      - 만약 이해하는데 어려움을 겪는다면, 섹션 중 클래스 기반 컴포넌트에 대한 섹션을 꼭 보라고 함
    - 과정의 마지막에는 몇 개의 React 컴포넌트와 함께 React 정규 프로젝트가 있다고 한다.
      - 구체적으로는 이 프로젝트에서는 세 개의 React 컴포넌트가 있다고 한다.
        - Backdrop, List, Modal 컴포넌트
    - 이 과정 전반에서, Modal이 나타나고 사라지는 것에 애니메이션을 적용하는 것과 List를 작업해야 한다.
      - 먼저 애니메이션이 아닌 주제부터 시작하고, Modal이 조건에 따라서 나타나도록 해볼 것이라고 한다.

  <br />

  - ReactTransitionGroup에 대한 추가 정보 그리고 framer-motion 및 결론 정리
    - ReactTransitionGroup에 대한 모듈 소개를 듣고, ReactTransitionGroup과 관련된 정보를 찾아서 추가로 정리, 그리고 framer-motion에 대한 내용도 추가 정리, 그 정보를 바탕으로 스스로 내린 결론에 대해 정리해서 기록하는 내용
    - API의 직관성 및 선언문 구문
      - React-Transition-Group
        - 상대적으로 더 낮은 수준의 API를 제공하며, **클래스 기반**의 접근을 통해 애니메이션을 처리한다.
        - 좀 더 프로그래머틱인 방식으로 동작하며, 상태 및 라이프사이클 메서드를 직접 다뤄야 한다.
      - framer-motion
        - 선언적이며 직관적인 API를 제공하며, 애니메이션의 속성들을 컴포넌트의 JSX 내의 정의하는 방식이다.
        - 개발자가 코드를 더 읽기 쉽게 만들고 애니메이션 로직을 이해하기 쉽게 한다.
    - 커뮤니티 및 지속적인 업데이트
      - React-Transition-Group
        - 많은 사용자를 보유하고 있지만, framer-motion에 비해 업데이트 사이클이 다소 느릴 수 있다.
      - framer-motion
        - 사용자 친화적인 API와 빠른 개발 사이클을 유지하면서도 활발한 커뮤니티와 지속적인 업데이트를 통해 발전하고 있다.
    - 성능
      - 두 라이브러리 모두 성능에 중점을 두고 있지만, framer-motion은 GPU 가속을 적극적으로 활용하여 부드러운 애니메이션을 제공하는 데 강점이 있다.
    - 사용 용도
      - React-Transition-Group
        - 트랜지션 효과를 중심으로 한 라이브러리이다.
      - framer-motion
        - 주로 모션과 애니메이션을 다루는 데 중점을 둔다.
    - React-Transition-Group
      - 주로 클래스형 컴포넌트에서 사용되는 라이브러리이다.
        - 주로 클래스형 컴포넌트에서 사용될 뿐이지, 함수형 컴포넌트에서 사용하지 못하는 것은 아니다.
      - 트랜지션과 애니메이션을 처리하는 데 주로 라이프사이클 메서드와 클래스 기반의 접근을 사용한다.
      - TransitionGroup
        - 자식 요소의 진입 및 이탈에 대한 애니메이션을 관리하는 데 사용한다.
          - 이를 위해 클래스 기반의 컴포넌트를 사용하는 것이 편리하다.
        - TransitionGroup은 CSSTransition이나 Transition과 함께 사용되어 특정 상황에서 애니메이션을 추가하거나 제거할 수 있다.
        - 이러한 컴포넌트들은 클래스 이름을 통해 CSS 트랜지션 클래스를 트리거하고 라이프사이클 이벤트를 활용하여 애니메이션의 시작과 종료를 처리한다.
    - framer-motion
      - 선언적이고 직관적인 API을 제공하여 애니메이션 및 모션을 쉽게 구현할 수 있도록 돕는다.
        - 이는 특히 함수형 컴포넌트와 함께 사용할 때 더욱 편리하다.
      - 함수형 컴포넌트와 Hook을 사용하는 현대적인 React 프로젝트에서는 framer-motion을 사용하는 것이 더 흔하다고 한다.
      - 코드의 가독성을 향상시키고 더 간편한 구문을 제공한다.
      - GPU 가속을 적극적으로 활용하여 성능 면에서도 우수한 퍼포먼스를 제공한다.
    - 함수형 컴포넌트와 관련된 Next.js 내용
      - Next.js는 주로 함수형 컴포넌트와 Hook을 사용하는 추세가 강하다.
      - Next.js는 React의 최신 기능과 함께 제공되며, 함수형 컴포넌트와 Hook을 이용하여 페이지 및 컴포넌트를 구현하는 것이 일반적이다.
        - 함수형 컴포넌트와 Hook을 사용하면 코드의 간결성과 가독성이 향상되며, 빠르게 개발할 수 있다.
      - 클래스형 컴포넌트도 여전히 사용 가능하지만, 주로 레거시 코드나 특별한 상황에서 사용될 수 있다.
      - Next.js의 최신 버전에서는 기본적으로 함수형 컴포넌트를 사용하는 것이 권장되고 있다.
      - 최신 Next.js 프로젝트를 개발할 때는 함수형 컴포넌트를 중심으로 사용하는 것이 일반적이며, 이를 통해 React의 최신 기능 및 라이프사이클 특징을 적극적으로 활용할 수 있다.
      - Next.js에서 애니메이션을 구현할 때, 함수형 컴포넌트와 Hook을 주로 사용하기 때문에 이 경우에 framer-motion과 같은 라이브러리가 적합하다고 한다.
        - Next.js에서 애니메이션을 구현하는 경우, 함수형 컴포넌트와 framer-motion을 활용하여 빠르고 간편하게 멋진 애니메이션을 만들 수 있다고 한다.
    - 추가 내용
      - 함수형 컴포넌트에서 애니메이션을 구현하려면 React-Transition-Group를 사용하는 대신 useEffect와 같은 Hook을 사용하여 직접 라이프사이클 이벤트를 처리하는 방법도 있으나, framer-motion과 같은 라이브러리가 더 간단하게 사용될 수 있기 때문에 framer-motion을 사용하는 것이 좋다고 생각된다.
      - 최근에는 함수형 컴포넌트와 Hook을 사용하는 추세가 높아지면서 framer-motion과 같은 라이브러리가 함수형 컴포넌트와 더 잘 통합되어 사용된다.
        - framer-motion은 선언적이고 직관적인 API를 제공하여 애니메이션 및 모션을 쉽게 구현할 수 있도록 돕는데, 이는 특히 함수형 컴포넌트와 함께 사용할 때 더욱 편리하다고 한다.
      - 최신 React 프로젝트에서는 함수형 컴포넌트와 framer-motion 같은 라이브러리를 고려해 볼 수 있으며, 이를 통해 코드의 가독성을 높이고 더 간편하게 애니메이션을 다룰 수 있다.
    - 결론
      - React 그리고 더 나아가 Next.js에서 새로운 프로젝트를 시작할 때, 클래스형 컴포넌트가 아닌 함수형 컴포넌트를 거의 기본적으로 사용하기 때문에 애니메이션을 구현한다면 React-Transition-Group 대신 framer-motion을 사용하는 것이 맞다고 생각이 된다.

# 오늘 느낀 점

- 오늘 프레이머 모션의 스크롤 기반 애니메이션까지 배워서 마무리하고 나서 React-Transition-Group에 대해 배우려고 했는데, React-Transition-Group는 클래스 기반 컴포넌트에서 주로 사용하는 라이브러리라는 것을 알게 되었다. 그래서 정보를 찾아보고 정리까지 한 결과 굳이 지금 React-Transition-Group에 대해서 배우고 배운 내용을 정리까지 할 필요는 없다고 느껴졌다. 요새 React로 새로운 프로젝트 시작하는 경우, 거의 함수형 컴포넌트로 진행하기 때문에 framer-motion을 사용하는 것이 코드의 가독성을 향상시키고 더 간편한 구문을 제공하기에 굳이 React-Transition-Group를 사용할 필요는 없다고 생각이 된다. 그리고 나는 React도 React지만, React 기반 프레임워크인 Next.js 또한 제대로 공부하고 사용해보고 싶은데, React와 Next.js 모두 최근에는 함수형 컴포넌트를 기반으로 작업을 하기 때문에 애니메이션을 구현해야 한다면 framer-motion를 사용하는 것이 맞다고 생각되어, React-Transition-Group에 대한 내용은 한 번은 보고 가는게 좋다고 생각되기 때문에, 정리하고 실습하면서 진행하는 것이 아닌, 한 번 쭉 보는 걸로 일단은 진행할 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
