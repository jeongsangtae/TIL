# 오늘 한 일

### React 공부

- React App 테스트 (유닛 테스트)

  - 사용자 상호 작용 및 State 테스트하기
    - 현재 작성한 테스트 코드는 유용하지 않다.
      - 컴포넌트를 조금 더 강하게 만들면 더 유용한 것을 테스트할 수 있다.
    - Greeting.js에서 state를 추가하고, state는 버튼을 클릭할 때 바뀌어야 하고, 버튼 클릭 시 화면에 있는 텍스트도 바뀌는 동작이 잘 작동되는지 테스트 해보는 연습
      - Greeting.js에서 간단한 버튼과 useState를 추가, 버튼 클릭 시 실행되는 함수를 추가해서 구성
        - 이 내용을 저장하면 컴포넌트는 변경되었지만, 테스트는 여전히 통과 상태이다.
        - 여태까지 유일하게 한 테스트는 컴포넌트에 가한 변화에 대해 신경 쓰지 않기 때문이다.
          - 여전히 "Hello World"가 존재하는지만 테스트하기 때문에 통과하는 것이다.
    - Greeting.js에서 추가한 새로운 기능으로, 컴포넌트를 어떻게 테스트할 지에 대한 아이디어가 적어도 두 개 있다.
      - 이미 갖고 있던 테스트에 더해서 2개 있음
      - 두 가지 아이디어 중 첫 번째는 텍스트를 볼 수 있는지를 테스트하는 것이다.
        - `{!changedText && <p>It's good to see you.</p>}`
          - state가 아직 변하지 않았다면, 즉 버튼이 아직 클릭 되지 않았을 경우
        - `{changedText && <p>Changed!</p>}`
          - 버튼을 클릭했을 땐 다른 텍스트가 보이는지 확인
        - 이게 중요한 이유가 테스트들을 작성할 때 가능한 한 모든 시나리오를 테스트 해보고 싶을 것이다. 모든 시나리오를 테스트 하지 않으면 테스트하는 의미가 없기 때문이다.
          - 하나의 경우만 놓고 테스트한다면 절대적 또는 적어도 어떤 변화들 때문에 다른 시나리오들이 실패했다는 걸 알아차릴 수가 없기 때문이다.
          - 그래서 말이 되고 가능한 모든 경우를 테스트하고 싶은 것이다.
    - Greeting.test.js에서 새로운 테스트 추가
      - 새로운 테스트 두 개를 작성
        - 이 테스트 중 적어도 하나는 스스로 작성해보는 것이 좋다.
        - 테스트하는 곳의 테스트에서 버튼이 클릭 되지 않았다면 텍스트가 보이는 지 확인하는 테스트
          - 버튼을 어떻게 클릭하는지는 사실상 아직은 모르기 때문에 그 테스트는 스스로 작성할 순 없을 것이다.
          - 하지만 p 태그를 확인하는 다른 테스트는 스스로 작성해 볼 수 있어야 한다.
        - 혼자서 테스트 코드를 짜서 실행했는데, 테스트를 통과해서 정상적으로 진행되었다.
      - 첫 번째 테스트 코드
        - 보통 잘 만들어진 문장처럼 읽히는지도 확인해야 한다.
          - 이게 전형적으로 이름을 붙이는 방식이다.
          - 직접 테스트 이름을 정하고 괜찮은 문장의 테스트 이름을 갖는 것이다.
        - "renders good to see you if the button was NOT clicked" 이와 같이 테스트하고 있는 걸 설명하는데, 여기서 버튼 설명 부분은 당연히 중요한데 반대 경우의 테스트를 위해 다른 테스트를 작성해야 하기 때문이다.
        - 준비, 실행, 단언으로 구성
          - 준비에서는 전과 같이 Greeting을 렌더링
          - 실행에서는 전과 같이 아무것도 하지 않는다.
            - 버튼을 클릭하지 않기 때문에 아무 것도 하지 않는다.
          - 단언 단계도 꽤 비슷하다.
            - 전과 같이 텍스트로 받는데, 정확히 매치시키거나 정확히 매치시키지 않고 단순히 "good to see you"를 찾게 할 수 있다.
            - 단순히 일부의 텍스트만 확인하도록 하려면 `{exact: false}`를 추가해서 설정해줘야 한다.
        - 첫 번째 테스트 코드는 내가 한 방식과 거의 비슷하게 작성되었다.
          - 조금 차이가 있다면 나는 단언 단계에서 텍스트를 정확히 매치시키도록 구성했고, 강의에서는 일부만 확인되면 진행되도록 해주는 차이점이 있었다.
      - 두 번째 테스트 코드
        - 버튼을 클릭할 수 있는 테스트 코드
        - 준비
          - 준비는 앞서 했던 것처럼 Greeting을 렌더링한다.
        - 실행
          - 이번에는 실행도 해야 한다.
          - 여기에서 실행은 바로 버튼을 클릭하고자 하는 것이다.
          - 다른 패키지에서 특징을 불러올 수 있는데, 이 특징 역시 박스 밖에서 설치되어 있다.
            - `"@testing-library/user-event": "^13.5.0"`
              - testing-library/user-event 패키지에서 불러오는 것이다.
            - testing-library/user-event 패키지에서 userEvent를 불러온다.
              - `import userEvent from "@testing-library/user-event";`
          - userEvent
            - 실제 화면에서 사용자 이벤트를 작동시키도록 돕는 객체이다.
            - 단순히 userEvent를 사용해서 전형적인 이벤트들을 사용할 수가 있는데 클릭, 더블 클릭, 호버링, 인풋에 타이핑하기와 같은 것들이 이에 해당된다.
              - 여기에서는 click이 필요하다.
              - `userEvent.click()`
            - click
              - 적어도 하나의 매개변수가 필요한데, 클릭을 시뮬레이션 해볼 수 있는 element가 필요하다.
              - 여기에서는 버튼이 필요한데, 버튼을 다시 텍스트로 선택해도 되지만 섞어서 다르게 선택해도 된다.
              - 강의에서 보여주는 대안
                - screen을 사용하고 getByRole이라고 해서 element를 가져오고 버튼이 element가 화면 상에서 가질 수 있는 역할이 되는 것이다.
                  - 여기에 버튼이 하나밖에 없으므로 하나뿐인 버튼에 액세스할 수 있다.
                  - `const buttonElement = screen.getByRole('button')`
                - buttonElement 이게 클릭을 시뮬레이션 해보는 버튼인데, 이걸 userEvent.click으로 전달하면 된다.
                  - `userEvent.click(buttonElement)`
              - 당연히 getByText를 다시 사용해도 되는데, 전혀 문제가 되지 않는다.
        - 단언
          - 다시 텍스트를 이용해 element로 액세스
            - `const outputElement = screen.getByText("Changed!");`
          - 실제로 단정을 지어야 한다.
            - `expect(outputElement).toBeInTheDocument();`
    - 이 상태로 확인해보면 강의에서는 모두 pass 되지만, 나는 마지막에 실패한다.
      - 이유를 찾아보니 비동기 동작이 완료되기 전에 테스트가 실행되어서 이러한 문제가 발생한 것 같다.
      - `waitFor`을 사용하고 비동기 작업을 처리해주면 정상적으로 pass가 되지만, 강의에서와 똑같은 코드로는 마지막 테스트는 실패한다.
      - 강의의 프로젝트 의존성과 테스트 라이브러리 버전이 달라서 이러한 문제가 발생하는 것으로 예상
        - 의존성과 테스트 라이브러리를 변경하고 확인해보니 강의의 저번에서는 정상적으로 되는 것을 확인할 수 있었다.
    - Greeting.test.js에서 또 다른 테스트 추가
      - 개발자로서 오류를 내서 첫 번째 문단을 렌더링하는 걸 잊어버리면 어떻게 될까 ?
        - 내가 테스트한 모든 것들이 여전히 작동하기 때문에, 테스트들이 이걸 알아채지 못하고 모든 테스트들이 성공했다고 나오게 된다.
      - 하지만 버튼을 클릭했을 때는 첫 번째 문단이 절대 보이면 안된다는 걸 내가 알고 있다면, 버튼이 일단 클릭되고 나면 첫 번째 문단이 사라지는지를 테스트하는 테스트도 필요하다.
        - 이 예시를 말이 되게 만들 수 있는 네 번째 테스트를 추가
      - 네 번째 테스트
        - 버튼을 클릭했을 때 텍스트가 있는 문단이 보이지 않는지를 확인하는 테스트
        - 버튼을 클릭했었던 테스트 코드의 내용을 복사해서 가져온다.
          - 이유는 다시 한 번 버튼을 클릭하려고 하기 때문이다.
        - 여기서 "Changed!" 문단이 있는지는 확인하지 않고, 대신에 "good to see you" 텍스트가 있는 element를 찾아서 `exact: false`로 작성해 매치가 되지 않도록 한다.
          - `const outputElement = screen.getByText("good to see you", { exact: false });`
        - 만약 element가 찾아지지 않는다면 getByText는 실패한다.
          - 실제로 예상하는 바도 element가 찾아지지 않는 것이다.
          - `expect(outputElement).not.toBeInTheDocument();`
        - 다시 한 번 강조하지만, getByText가 찾아지지 않는다면 오류를 낼 거라서 이 테스트는 절대 통과할 수가 없다.
          - element가 찾아지지 않는다면 실패
            - element가 찾아지지 않는다면 단순히 null을 반환한다.
          - 이것이 바로 queryByText를 사용하는 이유이다.
            - `const outputElement = screen.queryByText("good to see you", { exact: false });`
          - outputElement가 null인지를 확인하려 하는데, 그러기 위해 toBeNull 메서드가 온다.
            - `expect(outputElement).toBeNull();`
        - 최종적으로 정리하면 null인지 확인하고, null일 것이라고 예상하는데 버튼이 클릭 됐을 때 element가 찾아지지 않았으면 좋겠다고 생각해서 구성한 것이다.
    - 마지막 테스트를 돌려보면 예상대로 실패로 나온다.
      - 내 컴포넌트에 오류가 있기 때문이다.
      - 해당 텍스트를 가진 element가 없어야 오류가 발생하지 않는다.
      - 마지막 테스트는 실패한 걸 알 수 있으며, 개발자로서 컴포넌트 코드로 가서 해당 버그를 고칠 수 있다.
        - 고치고 다시 테스트해보면, 모든 테스트가 통과하는 것을 확인할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/114ca94d79a1ae26cf7e28d182ef1fdf44dc2e41)

  <br />

  - 연결된 컴포넌트 테스트하기
    - 여러 컴포넌트가 상호 작용하는 방법과 이를 테스트하는 법을 알아보는 시간
      - props와 테스트를 다루는 법도 함께 알아보는 시간
    - 새로운 컴포넌트인 Output.js 추가
      - 무언가를 출력하는 컴포넌트
      - 이 컴포넌트는 테스트 개념을 학습하기 위해 간단하게 구성
      - `{props.children}`을 아웃풋한다.
    - Greeting.js에서 구성
      - 문단을 렌더링하는 대신 Output 컴포넌트를 렌더링
      - 문단을 Output 컴포넌트로 변경하고 테스트해도 여전히 작동한다.
        - 이게 render의 좋은 점이다.
          - 여기에서 요구되는 컴포넌트 트리 전체를 렌더링한다.
          - 즉 Greeting을 렌더링하면서 JSX 코드에서 사용된 다른 컴포넌트를 무시할 뿐 아니라, Output 컴포넌트와 같은 컴포넌트의 콘텐츠를 렌더링한다.
          - 그래서 이것을 통합 테스트라고 부를 수도 있다.
      - 통합 테스트
        - 하나 이상의 unit, 하나 이상의 컴포넌트가 관여됐기 때문이다.
        - 자체적 논리가 없는 wrapper 컴포넌트를 다루는 상황이기 때문에 통합 테스트란 건 정확한 표현이 아니다.
        - 두 컴포넌트의 결합을 테스트하는 것도 충분히 가능하다.
        - 위 같은 상황에서도 반드시 테스트를 분리할 필요가 없다.
          - Output 컴포넌트가 만약 좀 더 복잡해진다던가 state를 관리하기 시작하면 테스트를 분리하는 것이 좋다.
          - Output 컴포넌트가 복잡해지면 Greeting 컴포넌트의 핵심 논리와 테스트를 분리해야 한다.
          - 하지만 현재 예시는 간단하게 구성했기 때문에 Greeting.test.js에 존재하는 테스트를 이전과 같이 유지할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/a14fcd2912d9bdeaedf7aa93d690da3a74d71c11)

# 오늘 느낀 점

- 오늘 목표는 테스팅 관련 내용을 마무리 짓는 것이 목표였지만, 중간에 강의에서 했던 방식과 똑같이 여러 테스트를 추가해서 작업했는데 의존성과 테스트 라이브러리 버전이 달라서 계속 테스트가 실패해서 관련 내용을 찾아보며 이것저것 방법을 찾아보다보니 테스트 관련 내용을 다 듣지 못한게 좀 아쉽다고 생각이 된다. 물론 테스트가 실패하는 부분은 waitFor과 비동기 작업을 추가해, 작동되도록 했기 때문에 스스로 찾아보고 배운 것도 많다고 생각이 된다. 그리고 지금까지 테스팅 해본 결과 아직까지는 간단한 내용으로 테스팅을 진행하기 때문에 엄청 큰 어려움이 없는데, 코드가 많이 작성된 상태에서 테스팅은 얼마나 복잡하게 진행될 지 솔직히 감이 잡히지 않는다. 이 섹선의 테스팅 관련 내용은 입문 단계의 내용이기 때문에 나중에 테스팅 관련 내용에 대해 더 찾아보고 공부할 필요성을 느낀다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
