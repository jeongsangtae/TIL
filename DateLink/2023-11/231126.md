# 오늘 한 일

### React 공부

- React + TypeScript

  - 타입 추론 (type inference) 이해하기
    - 앞에서 나열된 예시를 보면, 변수를 선언하면서 타입도 지정했다.
      - 그 다음 값도 설정했음
      - 코드를 작성할 땐 이 두 가지를 한 번에 하기도 한다.
      - 변수를 만들면서, 바로 시작 값을 할당한다.
    - 타입 추론
      - 변수를 하나 추가
        - 변수에는 간단한 문자열로 구성
        - `let course = "React - The Complete Guide"`
      - 변수에 숫자를 저장
        - `course = 12345`
        - 이미 문자열로 된 변수에 숫자를 저장하면 오류가 발생한다.
        - 문자열 타입 변수에는 숫자를 할당할 수 없기 때문이다.
        - 근데 여기서 어떻게 이 오류가 발생했을까 ?
          - 아무데도 타입을 정의하지 않았는데 어째서 ?
      - TS의 핵심 기능인 타입 추론이 사용된 것이다.
        - 기본적으로 TS는 가능한 많은 타입을 유추하려고 한다.
        - 어떤 타입을 어디에 사용해야 할지 알아내려고 한다.
        - 명시적인 타입 표기가 없어도 알아내려고 한다.
        - 이는 내가 작성할 코드가 줄어든다는 뜻이다.
          - 배운대로 직접 타입을 지정할 수도 있다.
            - `let course: string = "React - The Complete Guide"`
          - 잘못된 건 아니다. 단지, 불필요한 작업이다.
      - 변수를 만들고 바로 초기화하면 TS는 할당된 값의 자료형을 볼 것이다.
        - 여기서 예시는 `let course = "React - The Complete Guide"` 이 코드
        - 변수에 저장된 값이 문자열이라는 것을 알게 된다.
        - 해당 값의 자료형을 해당 변수의 타입으로 여기고 사용한다.
        - 이후 다른 타입의 값을 할당하려고 하면 오류가 발생한다.
          - 타입 추론 때문에 오류가 발생
    - 타입 추론 기능을 활용해서 코드를 작성하는게 권장되는 방식이다.
      - 불필요하게 타입을 지정하지 않아도 되기 때문이다.
      - 물론 명시적으로 타입을 지정해도 된다.
        - 하지만 확실히 불필요한 작업이다.
        - 내가 작성한 코드가 몇 줄 늘었다는 의미가 된다. 되도록 안 쓰는게 좋다.
        - 가능한, 타입 추론을 사용하는 것이 좋다.
      - 타입 추론 역시 강조하고 싶은 핵심 기능 중 한 가지라고 함
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/from-javascript-to-typescript/commit/2c427e69f77046fdedfd2da9e35ab034f37fbc0d)

  <br />

  - 유니온 유형 사용하기
    - 앞에서 TS와 그 핵심인 Type에 대해 배웠다.
      - 하지만, 지금까지 살펴본 상황에선 모든 변수가 타입을 하나만 갖고 있다.
        - 그래서 한 개의 변수에는 한 가지 자료형만 저장할 수 있었다.
        - 숫자만 저장 또는 문자열만 저장, 부울 값만 저장했었다.
        - 보통 이렇게 사용한다.
      - 다양한 타입을 여러 개 저장하는 경우도 있다.
    - reactCourse 변수로 설명
      - `let reactCourse = "React - The Complete Guide";`
    - reactCourse 변수에서 문자열을 저장하는데는 문제가 없다.
      - 여기에 숫자로 된 강좌 ID도 저장해야 한다고 가정
        - 무엇을 구축하는지에 달린 문제지만, 충분히 있을 만한 상황이다.
        - 하나의 변수에 문자열과 숫자를 함께 저장해야 할 수도 있다.
      - 서로 다른 형태의 객체를 동일한 변수에 저장해야 하는 경우는 얼마든지 생길 수 있다.
        - 한 개 이상의 타입을 지정할 수 있게 해주는 기능으로, 유니온(union) 타입이라는 기능이 있다.
    - 유니온 타입
      - 유니온 타입은 타입을 정의할 때 한 개 이상의 타입을 사용할 수 있다.
      - 다른 타입들과 마찬가지로 콜론을 변수 이름 뒤에 붙이고 등호의 왼편에 정의한다.
        - 여기에 타입이 들어간다.
      - 명시적으로 문자열 타입을 지정하는게 불필요한 작업이라고 말해줬었는데, 타입 추론을 사용하고 싶지 않다면 불필요한 작업이 아니다.
        - 유니온 타입으로 정의하려는 것이기 때문이다.
        - 여러 타입을 지정할 수 있도록 해줘야 한다.
      - 유니온 타입 지정은 첫 번째 타입 뒤에 파이프 문자(|)를 넣고 뒤에 다른 타입을 추가하면 된다.
        - `let reactCourse: string | number = "React - The Complete Guide";`
        - 저장할 타입을 필요한 만큼 추가해서 사용할 수 있다.
          - `let reactCourse: string | number | boolean = "React - The Complete Guide";`
        - `reactCourse = 12345;`
          - 이 예시처럼 숫자열을 입력해도 오류가 발생하지 않는다.
        - 이제 변수에는 숫자도 저장할 수 있기 때문이다.
      - 유니온 타입은 타입을 지정한 곳이면 어디든 사용할 수 있다.
        - 타입 추론을 사용하는 경우가 아니라면 가능하다.
        - 앞에서 사용한 변수인 userName에 유니온 타입을 사용해 문자열 또는 문자열 배열을 저장하도록 할 수도 있다.
          - `let userName: string | string[];`
          - 이렇게 하면 배열에는 사용자의 성과 이름을 저장할 수 있다.
    - 유니온 타입은 TS의 핵심 기능 중 하나로, 값과 타입을 좀 더 유연하게 정의할 수 있게 해준다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/from-javascript-to-typescript/commit/e8cc7b6269be173842448167bfa4fe2163839f0f)

  <br />

  - Type Aliases의 이해
    - TS 코드를 작성하다 보면 어느 시점부터는 동일한 타입을 반복해서 정의하는 일이 많아진다.
      - 앞에서도 동일한 타입을 정의한 적이 있다.
      - people을 선언할 때, 객체 배열을 만들려고 했는데 그 위에 있는 person 객체와 똑같다.
        - 타입 정의는 동일하다. 배열 형태는 아니지만 객체 타입은 같다.
        - 동일한 타입을 정의해도 문제될 건 없다.
        - 코드 중복을 원하지는 않을 것이다.
          - 그래서 타입 별칭(Type Alias)라는 것을 만든다.
      - 직접 기본(Base) 타입을 만들어 거기에 복잡한 타입을 정의해두고, 그 타입 별칭을 사용하는 것이다.
        - 반복해서 타입을 정의하는 대신 타입 별칭을 사용
    - 타입 별칭
      - 예로, 객체를 처음 사용하기 전에 타입의 형태를 타입 별칭으로 정의해놓는다.
        - type 키워드를 사용해서 정의한다.
        - 일반적인 JS에는 type 키워드가 없지만 TS에는 추가되어 있다.
      - type 키워드 뒤에 원하는 이름을 붙이면, 그게 새로운 타입의 이름이 된다.
        - 이름 뒤에 등호를 넣은 다음, 옆에 타입을 정의하면 된다.
          - 이건 TS에만 존재하는 기능이기 때문에 JS로 컴파일하면 코드에서 사라지게 된다.
          - 등호 오른쪽에 있는 건 JS 값이 아니라, 타입을 정의한 것이고 내가 만든 객체 타입이다.
        - `type Person = { name: string, age: number }`
      - 객체 타입을 사용했던 모든 곳에 내가 만든 별칭을 대신 넣을 수 있다.
        - `let person: Person`
        - 여전히 동일한 타입을 사용하지만 정의는 한 번만 하면 된다.
        - 필요한 모든 곳에 반복해서 사용할 수 있다.
          - `let people: Person[];`
          - 이와 같이 변형하는 것도 가능하고, Person을 단독으로 사용해도 되고 배열 형태로 배꿔서 사용할 수도 있다.
    - 타입 별칭은 매우 중요한 기능이다.
      - 작성해야 할 코드 양을 줄일 수 있기 때문이다.
      - 코드가 좀 더 간결해지고, 관리하기도 수월해진다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/from-javascript-to-typescript/commit/ce1e47c53ae83dd3206531be4b122e0253b4db6e)

  <br />

  - 함수 및 함수 유형
    - 함수와 타입이라고 말하는 이유는 함수를 사용할 때 타입을 지정하는 위치가 따로 있기 때문이다.
    - 앞에서 봤던 add 함수를 추가
      - add 함수는 매개변수를 가질 수 있다.
      - 매개변수에 타입을 지정할 수 있다.
      - 변수에 타입을 지정할 수 있는 것처럼 매개변수에도 타입을 지정할 수 있다.
      - 명확하게 표시할 수 있다.
        - `const add = (a: number, b: number) => { return a + b }`
    - add 함수에는 타입이 추론되는 부분이 있다.
      - 함수에서 값을 반환하고 이를 통해 TS는 반환 값의 타입을 알게 된다.
      - 함수의 반환 값이 갖는 타입을 통해 함수 타입을 추론한다.
      - 함수 이름 "add"에 커서를 올려보면 타입을 볼 수 있다.
        - TS가 해당 함수를 어떻게 정의하는지 볼 수 있고, 함수가 가진 매개변수에 대해서도 각각의 타입을 볼 수 있다.
        - 여기서는 내가 지정한 숫자 타입으로 표시된다.
      - 함수 이름과 매개변수 목록 뒤쪽에 타입이 또 있다.
        - `const add: (a: number, b: number) => number`
        - 이건 내가 설정한 것이 아니다.
        - 코드를 추가한 적이 없다.
        - 반환 값의 타입에서 추론된 것이다.
      - TS는 함수에서 숫자가 반환된다는 것을 알고 있다.
        - 숫자 타입의 매개변수를 대입하면 결과는 항상 숫자가 된다.
        - 다른 타입을 가진 값은 반환될 수 없다.
        - 그래서 반환 값을 숫자형이라고 추론한 것이다.
      - 명시적으로 지정할 수도 있고, 함수의 반환 타입을 직접 지정할 수 있다.
        - 함수의 매개변수 목록 뒤에 콜론을 붙이고 그 뒤에 반환 타입을 지정하면 된다.
          - `const add = (a: number, b: number): number => { return a + b };`
        - 숫자형, 문자열, 또는 유니온으로 지정하는 것도 가능하다.
        - 직접 지정하는 것도 가능하긴 하지만 꼭 지정해야 할 이유가 없다면 지정하지 않는 것이 좋다.
          - TS가 알아서 타입을 추론하기 때문이다.
          - 타입이 내가 원하는 자료형이라면 굳이 명시적으로 정의할 필요가 없다.
    - 함수에서 타입을 사용할 때는 매개변수의 타입뿐만 아니라, 반환 값의 타입도 생각해야 한다는 것이다.
      - 놓치기 쉽지만 아주 중요한 부분이다.
      - 함수에는 입력만 있는 게 아니라 출력도 있기 때문이다.
        - 그래서 반환 타입이 있는 것이다.
    - 특별한 반환 타입
      - printOutput라는 새로운 함수를 추가
        - value라는 매개변수를 만들고 타입은 any로 지정
          - value 매개변수로 값을 받아서 할 일은 콘솔에 출력하는 것뿐이기 때문이다.
          - 이 같은 이유로 value에 명확한 타입을 지정할 필요는 없다. 출력만 할 것이기 때문이다.
        - `const printOutput = (value: any) => { console.log(value) };`
      - printOutput 함수에서 중요한 것은 이 함수가 아무것도 반환하지 않는다는 것이다.
        - return 문이 없다.
        - 이럴 경우에 갖는 특별한 반환 타입이 바로 "void"이다.
          - `const printOutput: (value: any) => void`
      - void
        - void는 null 또는 undefined와 비슷하지만, 항상 함수와 결합해서 사용한다는 특징이 있다.
        - voide는 함수에 반환 값이 없다는 것을 뜻한다.
        - 만약 printOutput 함수의 반환 값을 받아 작업하려면 undefined 타입으로 값을 받아야 한다.
        - void는 함수에만 있는 특수한 타입으로 함수의 반환 타입에 사용된다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/from-javascript-to-typescript/commit/58550482565ab530505cedb2bf1e0888938db342)

  <br />

  - 제네릭으로 뛰어들다
    - 이 기능은 약간 어렵지만, 매우 중요한 TS 기능이다.
      - 좀 어려워서 이해하기 힘들 수도 있다.
    - insertAtBeginning 이라는 함수를 추가
      - 이 함수는 array과 value을 매개변수로 갖는다.
      - array는 타입이 상관없으니 any 타입으로, value 역시 any로 구성
      - 이 함수에서는 array에 숫자, 문자열 또는 직접 정의한 객체가 있어도 괜찮다.
      - `const insertAtBeginning = (array: any[], value: any) => {};`
    - 타입에 상관없이 insertAtBeginning 함수에서 하고 싶은 것은 새로운 배열을 만드는 것이다.
      - 전개 연산자를 이용해서 기본 배열을 복사하고, 복사한 배열 앞에 새로운 값을 집어넣는다.
        - 전개 연산자는 모던 JS도 지원하고, TS도 지원한다.
        - `const newArray = [value, ...array];`
      - 이 다음 newArray 배열을 반환
        - `return newArray`
    - insertAtBeginning 함수는 직접 만든 유틸리티 함수나 헬퍼 함수라고 할 수 있다.
      - 이 함수가 있으면 호출하기만 해도 기존 배열은 유지한 상태로, 배열에 새로운 값을 추가할 수 있다.
      - 이 함수의 장점은 기존 배열을 변경하지 않는다는 것이다.
        - 대신 아예 새로운 배열을 얻게 된다.
    - demoArray 라는 배열을 만들고, 값을 3개 넣어준다.
      - `const demoArray = [1, 2, 3]`
    - updatedArray를 선언해서 insertAtBeginning 함수를 호출
      - 인수로 demoArray를 넘기고, 또 다른 인수로 -1을 넘긴다.
        - `const updatedArray = insertAtBeginning(demoArray, -1)`
      - 이렇게 하면 updatedArray는 demoArray 배열 앞에 -1이 삽입된 배열이 될 것이다.
        - `[-1, 1, 2, 3]` 배열이 반환된다.
    - updatedArray에 마우스 커서를 올려보면 추론된 배열의 타입이 any라는 것이다.
      - any 타입의 값이 들어있는 배열이라는 것
      - TS는 이 배열에 숫자만 들어있다는 것을 인식하지 못한다.
        - 이유는 insertAtBeginning에서 타입을 any로 지정했기 때문이다.
          - 그렇다고 숫자형으로 타입을 지정할 수도 없다.
          - 문자열 배열에 대해 유틸리티 함수를 사용할지도 모르기 때문이다.
      - any 타입이 필요하긴 한데 any를 사용하면 함수를 호출한 다음 TS로부터 어떤 지원도 받을 수 없게 된다.
        - updatedArray에 대해 TS의 지원을 받을 수 없다.
        - TS는 배열에 들어있는게 any 타입의 객체나 any 타입의 값이라고 생각하기 때문이다.
          - 그래서 제대로 지원할 수 없다.
        - 예로, 배열의 첫 번째 요소를 가져와 split()을 호출
          - 문자열에서 사용하는 함수인데 오류 표시가 생기지 않는다.
            - 하지만 실행하면 오류가 발생한다.
            - 숫자 값에서는 split()을 호출할 수 없기 때문이다.
            - 하지만 TS는 updatedArray의 첫 번째 값이 숫자라는 것을 알 수 없다.
            - 나는 개발한 사람이니까 알지만, 내가 필요해서 정의한 타입 때문에 TS는 알 수가 없다.
          - `updatedArray[0].split('')`
    - 위 문제를 해결하기 위해 "제네릭" 이라는 기능을 사용한다.
      - 왜 제네릭 기능이 필요한지 이해하는 것이 중요하다.
      - 제네릭 기능을 사용해서 insertAtBeginning 함수를 제네릭 함수로 변환할 수 있다.
      - 이를 위해 특수한 구문을 사용할 것이며, 함수 이름과 매개변수 목록 사이에 "<>"를 추가한다.
        - 일반적인 JS는 지원하지 않는 기능으로 여기서만 사용할 수 있다.
          - TS를 사용하고 있기 때문이다.
        - `const insertAtBeginning = <>(array: any[], value: any) => {...}`
      - insertAtBeginning 함수에 제네릭 타입을 정의
        - 함수 안에서만 사용할 수 있는 타입이다.
        - 보통 Type의 T를 따서 사용하지만, 어떤 식별자를 사용해도 상관없다.
          - `const insertAtBeginning = <T>(array: any[], value: any) => {...}`
        - 이제 이 타입을 함수와 매개변수 목록에서 사용할 수 있다.
          - array 배열에서 사용
            - `<T>(array: T[], ...)`
            - array 배열은 T 타입 값으로 채워진다.
          - value에서 사용
            - `<T>(..., value: T)`
      - 위 처럼 바꾼 내용이 어떻게 문제를 해결해줄까 ?
        - `const insertAtBeginning = <T>(array: T[], value: T) => {...}`
        - 위 예시의 코드가 마치 수수께끼처럼 보일 것이다.
          - 하지만 이 함수를 호출하면, 이제 TS는 들어온 인수의 정확한 값을 살펴봐야 한다는 것을 알 수 있다.
          - 첫 번째 인수는 숫자로 구성된 배열이고, 두 번째는 숫자라는 걸 파악한다.
          - 자연스럽게 updatedArray가 숫자 배열이라는 것도 알게 된다.
            - `const updatedArray: number[]`
        - 제네릭 타입을 사용해 TS에게 any 타입이 아니라는 걸 알려줬기 때문이다.
          - any 타입의 값이 아니고, 대신 array 배열과 value 값이 같은 타입을 가져야 한다는 걸 알려줬다.
          - 배열이지만 배열을 구성하는 값들의 타입은 value 값의 타입과 같다는 것을 알려주었다.
          - 이제 TS는 demoArray의 타입을 볼 수 있고, 그러면 demoArray 배열이 숫자 배열이라는 걸 알게 된다.
            - 추론이 가능하다.
            - 그 다음 insertAtBeginning에 들어가는 두 번째 인수 타입을 본다.
            - 논리적으로 함수에서 만들어지는 배열은 입력으로 들어온 배열과 같은 타입을 가진다는 걸 파악한다.
            - 결국 함수를 통해 내가 받고자 하는 겂이 숫자 배열이라는 걸 추론해낸다.
    - insertAtBeginning 함수에 문자열을 넣고 호출
      - `const stringArray = insertAtBeginning(["a", "b", "c"], "d")`
      - TS는 이번에도 맞는 타입을 추론한다.
        - 마찬가지로 배열의 타입과 인수의 타입을 보고 반환 타입은 매개 변수로 받은 배열의 타입과 같아야 한다는 걸 알아냈고, 이번에도 맞는 타입을 추론한 것이다.
    - split() 함수를 호출한 코드에서 오류 표시
      - `updatedArray[0].split("");`
      - `const updatedArray = insertAtBeginning(demoArray, -1);`
        - `const updatedArray: number[]`
      - updatedArray를 보면, 숫자로 구성된 배열이라는 걸 알기 때문에 split 함수를 호출한 곳에서 오류도 표시할 수 있다.
        - 숫자 타입에는 존재하지 않는 함수라고 알려준다.
    - 제네릭의 주요 기능을 살펴보았는데, 여기서는 함수 작성에 도움을 주었다.
      - 함수에 타입 안정성과 유연성을 주었다.
      - 자유롭게 어떤 타입이든 사용할 수 있지만, 특정 타입을 사용해 함수를 실행하고 나면 해당 타입으로 고정되어 작동한다.
      - 이 기능은 두 가지 측면에 모두 도움이 된다.
        - 유연성과 타입 안정성 측면
    - 제네릭 기능은 분명히 어렵고 이해하기 힘들지만, 곧 React와 TS에서 실제로 사용하면서 동작 방식과 중요성에 대해 더 명확히 깨닫게 될 것이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/from-javascript-to-typescript/commit/ca74f40fbf8a1644591bf5f2fdd23f3ddc9f1e62)

  <br />

  - 제네릭 자세히 살펴보기
    - 예제와 함께 자세히 살펴보는 내용
    - `let numbers = [1, 2, 3];`
      - 이 예시는 유형이 유추되지만, 명시적으로 할당하면 다음과 같이 할 수 있다.
      - `let numbers: number[] = [1, 2, 3];`
      - number[] 는 TS 표기법으로써 "이것은 숫자의 배열입니다" 라고 정의하는 것이다.
      - 그러나 실제로, number[]는 문법적 설탕이다.
        - "문법적 설탕(syntactic sugar)"이라는 표현은 TypeScript에서 배열 타입을 간편하게 표기하기 위해 제공되는 문법적인 편의를 나타낸다.
      - 실제 유형은 Array이며, 모든 배열은 Array 유형이다.
      - 배열 유형은 배열의 항목 유형도 설명하는 경우에만 의미가 있으므로, Array는 실제로 제네릭 유형이다.
    - `let numbers: Array<number> = [1, 2, 3];`
      - 위의 예를 이렇게 작성할 수도 있다.
      - 여기에 다시 "<>"가 있다.
        - 그러나 이번에는 (이전 강의에서 했던 것처럼) 자신의 유형을 만드는 것이 아니라 TypeScript에 실제 유형이 "generic type placeholder (일반 유형 자리 표시자)"에 사용되야 한다고 하는 것이다.
      - 지난 강의에서 본 것처럼 TypeScript는 이것을 추론할 수도 있다.
      - `let numbers = [1, 2, 3];` 이와 같이 작성할 수도 있고, 명시적으로 유형을 설정하는 것도 가능하다.
        - `let numbers: Array<number> = [1, 2, 3];`
    - 물론 위처럼 길고 투박한 유형을 작성하는 것은 약간 성가실 수 있다.
      - 그래서 배열에 대해 대안(문법적 설탕)이 있다.
        - `let numbers: number[] = [1, 2, 3];`
      - 이전 강의의 예를 들면 자리 표시자에 대한 구체적인 유형을 설정할 수도 있다.
        - `const stringArray = insertAtBeginning<string>(['a', 'b', 'c'], 'd');`
        - "T"를 명시적으로 사용
      - 따라서 "<>"를 사용하여 제네릭 유형을 정의할 수 있을 뿐만 아니라 제네릭 유형을 사용하고 사용해야 하는 자리 표시자 유형을 명시적으로 설정할 수도 있다.
      - 때로는 TypeScript가 (올바른) 유형을 유추할 수 없는 경우에 필요하다.
        - 이 내용에 대한 더 자세한 내용은 섹션의 뒷부분에서 살펴볼 예정이다.
    - 정리
      - 1

  <br />

  - React + TypeScript 프로젝트 만들기
    - React에서 TS를 설치하고 설정하는데 여전히 create-react-app을 사용한다.
    - [create-react-app.dev](https://create-react-app.dev/docs/getting-started) 페이지에서 create-react-app 사용법뿐만 아니라, TS와 통합하는 방법 또한 볼 수 있다.
      - Building your App을 클릭하면 Adding TypeScript 문서가 나온다.
        - 물론 이 문서의 위치는 시간이 지나면 바뀔 수도 있다.
        - 다른 위치에서 문서를 찾아야 할 수도 있다.
      - 구글에서 create react app typescript를 검색하면 내가 찾고 있는 Adding TypeScript 문서에 바로 갈 수 있다.
        - Adding TypeScript에서 React 프로젝트에 TS를 추가하는 방법을 볼 수 있다.
    - 가장 쉬운 방법은 프로젝트를 만들 때 TS 기반 프로젝트로 생성하는 것이다.
      - [Adding TypeScript](https://create-react-app.dev/docs/adding-typescript)
      - 기존 프로젝트에 TS를 추가하는 방법도 설명되어 있고, TS 기반 프로젝트를 생성하는 방법도 볼 수 있다.
      - 여기서는 새로운 프로젝트를 생성할 것이다.
        - `npx create-react-app my-app --template typescript`
          - 이 명령어를 사용해서 생성할 것이다.
        - 평소에 React 앱을 생성할 때처럼 npx create-react-app 뒤에 내 프로젝트 이름을 넣고, `--template`라는 중요한 플래그를 명령어에 추가해야 한다.
        - 그 다음 typescript로 설정해야 한다.
      - 위와 같이 하면 특정 템플릿을 사용해서 프로젝트를 생성하기 때문에 TS 기반의 프로젝트가 생성된다.
    - 강의에서는 JS에서 TS를 사용한 폴더와 React에서 TS를 사용할 폴더를 폴더로만 나누어서 하나의 폴더에서 구성했지만, 나는 그냥 별개로 아이에 다른 폴더 구성으로 각각 따로 구성해주었다.
    - TypeScript에서 마찬가지로 npm start로 개발 서버를 구동시킬 수 있다.
      - 이번에는 React 프로젝트에서 TS를 사용하도록 구성했을 뿐이다.
    - 기존의 React 프로젝트와 좀 다른 부분이 있다.
      - src 폴더를 열어보면 `.js` 파일 대신에 `.tsx` 파일이 있다.
        - 이것은 TS를 사용하고 있음을 나타낸다.
        - 확장자가 `.ts`가 아니라 `.tsx`인데 그 안에서 JSX 문법을 사용하기 때문이고, JSX 문법을 사용할 때 개발 툴에 불필요한 경고창이 뜨지 않게 하려면 확장자로 `.tsx`를 사용해야 한다.
          - 파일에서 JSX 문법을 사용한다면 반드시 `.tsx`로 해줘야 한다.
      - 나머지는 기본적으로 앞에서 배운 강의 코드와 동일하다.
        - 특별한 사항은 없다.
    - 다시 실행한 개발 서버에 관해 알아둬야 할 게 있다.
      - 서버는 이전처럼 동작하지만, 밑단에서 추가로 한 가지 작업을 더 수행한다는 것이다.
        - 내가 작성한 TS 코드를 JS로 컴파일하여 최적화하는 작업을 수행한다.
      - React와 바닐라 JS를 사용했을 때 단순히 이 개발 서버는 JS 코드를 받아 파일들을 하나로 묶는 작업을 수행하고, 최적화 단계는 별도로 제공했다.
        - 지금은 이러한 과정에 더해 추가적으로 TS를 JS로 컴파일하는 단계가 있다.
          - 이 작업은 보이지 않는 곳에서 진행이 된다.
          - JS를 TS로 직접 변환할 필요가 없다.
          - TS를 직접 컴파일하거나 컴파일러를 호출할 필요가 없다.
          - 이 작업들은 밑단에서 수행되기 때문이다. 또한 이 과정은 npm run build 명령어를 통해 코드를 빌드한다면 자동적으로 수행되기도 한다.
    - 의존성 (dependencies)
      - package.json을 보면 대부분 전에 봤던 의존성과 동일하다.
      - 하지만 몇 가지 의존성이 추가된 것을 확인할 수 있다.
        - typescript, @types/jest, @types/node, @types/react
      - typescript 의존성
        - TS용 컴파일러 언어로 이 프로젝트 안에 설치되어 있다.
        - 그래서 해당 프로젝트에서 TS를 사용할 수 있다.
        - 이 의존성은 바로 앞에서 공부한 강의에서 사용한 의존성에도 있었다.
      - 여기에 더해 types 패키지도 있다.
        - 이 패키지들도 아주 중요하다.
        - `@types` 패키지는 번역기 역할을 한다.
          - 바닐라 JS 라이브러리와 TS 프로젝트 사이에서 번역기 역할을 한다.
        - 현재 이 프로젝트에서 react와 react-dom을 라이브러리로 사용하고 있다.
          - 두 라이브러리는 JS로 작성되어 있다.
          - 앞선 강의에서 react와 react-dom을 사용할 때 JS만을 사용했었다.
        - 이제 TS에서 react와 react-dom 하이브러리를 사용하고, TS 및 개발 툴이 제공하는 기능과 자동 완성 같은 기능을 사용하기 위해서는 언어 변환이 필요하다.
          - JS로 작성된 바닐라 JS 라이브러리와 TS 프로젝트 사이에 필요하다.
          - 말하자면 타입 표시 기능을 JS 라이브러리에 추가해주는 것이다.
        - 이게 @types/react와 @types/react-dom이 하는 일이고, 모든 라이브러리에 언어 변환이 필요한 것은 아니다.
          - 어떤 라이브러리에는 타입 표시 기능이 내장되어 있다.
          - JS만으로도 사용할 수 있도록 내장되어 있음
          - 하지만 몇몇 라이브러리는 타입 표기 기능이 없기 때문에 타입 표기를 위한 의존성이 추가된 것이다.

# 오늘 느낀 점

- JS 프로젝트에서 TS를 사용하는 방법을 배우고, 기본적인 타입 사용 방법 그리고 타입 추론, 유니온 유형 등등 여러 중요한 핵심 기능들을 배웠는데 이제는 JS 프로젝트가 아닌, React에서 TS를 추가해서 React + TypeScript로 작업하는 내용을 배워봐야 한다. 현재는 React에서 TypeScript 기반으로 프로젝트를 생성해주었다. 그 후에 기존의 React 프로젝트 내용과 무엇이 다른지 확인해보고, 밑단에서 어떤 작업이 이루어지는지, 그리고 가볍게 package.json 내용도 살펴보았다. 이제 본격적으로 React에서 TypeScript를 사용해서 어떻게 구성하는지에 대해 배우고 실습해보아야 한다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
