# 오늘 한 일

### React 공부

- React 앱에 애니메이션 넣기

  - 조건 값 사이에 애니메이션 넣기
    - View Details 버튼을 누르면 아이콘에 애니메이션이 적용되게 할 텐데, 이번에는 CSS 트랜지션이 아닌 프레이머 모션으로 좀 더 현실감을 줘서 구성
    - CSS 애니메이션은 더 이상 쓰지 않으니, 삭제 그리고 index.css 파일 업데이트
      - ChallengeItem.jsx에서 className에 `expanded`가 조건부로 들어오는 부분을 삭제
      - index.css 파일에서 `challenge-item-details-icon`의 transition 프로퍼티를 추가한 부분 삭제
        - 그리고 `expanded`가 포함된 규칙도 지워도 된다. 애니메이션에 바닐라 CSS는 더 이상 쓰지 않기 때문이다.
    - ChallengeItem.jsx에서 프레이머 모션 사용
      - motion 컴포넌트 import
      - 아이콘의 span 부분에서 motion.span으로 바꿔준다.
        - 프레이머 모션에서 제공하는 컴포넌트로 더 많은 애니메이션을 활용하게 해준다.
        - `<motion.span>...</motion.span>`
      - motion.span을 사용했으니, 요소의 애니메이션을 제어하는 animate 프로퍼티 추가
        - 회전에 애니메이션을 넣기 위해 rotate 추가
          - 상세 정보가 보이지 않을 때, 즉 버튼을 클릭하지 않았을 땐 `rotate: 0` 이어야 한다.
          - 클릭했을 땐 `rotate: 180`이 되도록 해야 한다.
          - 이 컴포넌트엔 isExpanded 프로퍼티가 있어서 상세 정보가 보이는지 알려줄 수 있다.
          - animate 프로퍼티의 rotate 프로퍼티가 isExpanded를 확인하도록 조건을 지정해준다.
            - `animate={{rotate: isExpanded ? 180 : 0}}`
    - 저장하고 테스트해보면, 아이콘의 애니메이션이 이전과 살짝 다른 것을 확인할 수 있다.
      - 약간의 튕김이 들어가서 더 자연스러워 보인다.
      - 사소하지만, 이런 사소한 점이 웹 사이트 방문자들에게 한결 더 자연스럽고 기분 좋은 경험을 선사한다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/413f723088edb70bf8fa98b4c43c75ef8e408b9a)

  <br />

  - 진입 애니메이션 추가하기
    - 모달 창의 진입 애니메이션을 CSS에서 프레이머 모션으로 바꾸는 작업
      - 이걸 바꾸는 이유는 2가지로 첫 번째는 역시 자연스러움 때문이다.
        - 지금도 괜찮지만, 단지 자연스러움 때문이라면 바꾸지 않는 게 나을 것이다.
      - 두 번째는 한 단계 더 나아가 창이 사라지는 애니메이션을 구현할 것이기 때문이다.
    - Modal 컴포넌트에서 작업하기 전에, index.css 파일에서 기존의 CSS 애니메이션 삭제
      - `.modal` 선택자에 추가해놓은 CSS 내용과 직접 정의한 CSS 애니메이션 내용을 삭제
    - Modal.jsx 컴포넌트에서 작업
      - 프레이머 모션을 import
      - dialog를 motion.dialog 컴포넌트로 변경
        - `<motion.dialog open className="modal">...</motion.dialog>`
        - `motion.`을 붙이는 이유는 프레이머 모션으로 애니메이션을 넣을 수 있게 해준다.
      - animate 프로퍼티를 추가
        - 애니메이션을 적용할 값을 정의할 텐데, 까다로운 점이 있다.
          - Modal 컴포넌트 안에 있는 dialog는 늘 화면에 포함되어 있고 컴포넌트 안에는 값 변화를 통해 모달 창이 나타났다고 알려줄 프로퍼티나 state가 없다.
            - 따라서 다른 값이 되도록 애니메이션을 넣기 까다롭다.
          - 모달 창이 방금 추가됐는지 아니면 열려 있었는지 알려줄 지표가 따로 없기 때문이다.
          - ChallengeItem.jsx에선 isExpanded 프로퍼티를 이용해 두 값을 오갈 수 있었지만 Modal 컴포넌트에선 그런 프로퍼티나 state가 없다.
            - 하지만 굳이 필요 없다. motion 컴포넌트가 컴포넌트에 지정할 수 있는 유용한 프로퍼티를 제공하기 때문이다.
      - initial 프로퍼티
        - 이 요소가 DOM에 추가된 직후 곧바로 재생될 애니메이션의 초기 state를 정의할 수 있다.
        - 다시 말해 요소의 시작 state를 지정할 수 있다.
        - 만약 그 state가 animate 상태에서 벗어나면 프레이머 모션이 자동으로 애니메이션을 재생해 목표로 하는 animate 상태에 도달한다.
        - initial과 animate 함께 사용 예시
          - initial에 `opacity: 0`을 지정해 처음에 DOM에 나타날 때 투명하게 하고 y: 30으로 30px만큼 올릴 수 있다.
            - `initial={{ opacity: 0, y: 30 }}`
          - 여기서 animate에는 `opacity: 1`로 지정해서 opacity의 목표 값을 1로 하고 `y: 0`을 지정
            - `animate={{ opacity: 1, y: 0 }}`
          - 이렇게 initial과 animate로 애니메이션의 초기 값이 목표 값이 될 떄까지 재생한다.
    - 이 상태로 저장하고 확인하면 밑에서 위로 모달 창이 올라오는 것을 확인할 수 있다.
      - 튕김 효과도 약간 들어간 것을 확인할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/548270ee7e44c3132297b8a30598eaa5ceeb421c)

  <br />

  - 요소가 사라지는/삭제되는 애니메이션 넣기
    - 모달 창이 사라지는 애니메이션을 추가 해야 한다.
      - CSS만 써서는 불가능하기 때문에 프레이머 모션을 사용해야 함
    - 프레이머 모션 패턴
      - 요소가 DOM에 나타날 때의 시작 상태
        - initial 프로퍼티
      - 나타난 직후 애니메이션 상태
        - animate 프로퍼티
      - 요소가 DOM에서 삭제될 때 적용하고 싶은 애니메이션 상태
        - exit
    - Modal.jsx 컴포넌트에서 작업
      - exit 프로퍼티 추가
        - initial 상태를 exit에 복사
          - `exit={{ opacity: 0, y: 30 }}`
          - 물론 이건 내 마음대로 설정하면 된다. 프레이머 모션이 알아서 animate에서 exit로 가는 방법을 알아내기 때문이다.
        - exit를 추가해도 아무런 애니메이션 없이 모달창이 즉시 사라진다.
          - 이유는 motion 컴포넌트를 썼다고 해도 React가 요소를 처리하는 방식은 그대로 동일하기 때문이다.
          - React는 요소가 컴포넌트 함수에 의해 return되지 않으면, 즉 Header 컴포넌트이자 모달을 포함한 NewChallenge 컴포넌트가 isCreatingNewChallenge가 거짓이라 return 값에 포함되지 않았을 경우 DOM에서 즉시 삭제한다.
            - `{isCreatingNewChallenge && <NewChallenge onDone={handleDone} />}`
            - 동의 따위 구하지 않고 곧장 삭제해 버린다.
            - 하지만 프레이머 모션을 쓰면 이걸 피할 수 있다.
            - 위 예시 코드를 래핑하는 특수한 컴포넌트를 제공하는데, 그 컴포넌트를 사용하면 해당 기능을 끄거나 제어할 수 있다.
    - Header.jsx 컴포넌트에서 작업
      - motion말고 다른 컴포넌트를 import
        - 프레이머 모션이 제공하는 AnimatePresence 컴포넌트
        - `import { AnimatePresence } from 'framer-motion';`
      - AnimatePresence 컴포넌트
        - 이 컴포넌트는 어떤 요소에 애니메이션을 적용할 때, 정확히는 요소를 사라지게 하는 애니메이션을 적용할 때 조건에 따라 요소를 표시하거나 삭제하는 코드를 감싸는 래퍼로 쓰인다.
        - AnimatePresence로 코드를 감싸면 프레이머 모션이 코드가 실행될 때 코드가 렌더링하는 요소, 즉 모달 창이 즉시 삭제되는 걸 막고 exit 애니메이션이 있는 요소가 있는지 확인한다.
          - 그런 요소를 발견하면 exit 애니메이션부터 실행한 뒤, 모든 요소를 삭제한다.
        ```
        <AnimatePresence>
          {isCreatingNewChallenge && <NewChallenge onDone={handleDone} />}
        </AnimatePresence>
        ```
    - 이대로 저장하면 창을 여닫을 때 모두 애니메이션이 실행되는 것을 확인할 수 있다.
      - 백드롭을 클릭하면 창이 내려가면서 서서히 사라지는 exit 애니메이션이 잘 실행되는 것을 확인할 수 있다.
      - AnimatePresence 컴포넌트가 코드의 래퍼로 쓰여 exit 프로퍼티가 있는 motion 컴포넌트를 포함한 Modal을 렌더링하는 코드를 감싸고 있기 때문이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/4577ed80a65f36738e210e8b2f45d034e3d9e617)

  <br />

  - 마우스 오버 애니메이션으로 튀어나오는 듯한 효과 주기
    - Header 컴포넌트에서 프레이머 모션을 활용해 애니메이션화 하고 싶은 button 요소가 있다.
      - 사용자가 커서를 올리면 버튼이 더 튀어 보이도록 만들고 싶다.
      - 크기도 좀 키우고 더 튕겨 나오도록 만들어야 한다.
      - 프레이머 모션을 활용하면 쉽게 할 수 있다.
        - 실제 같은 자연스러운 느낌의 애니메이션을 제공해주기 때문이다.
    - Header.jsx 컴포넌트에서 작업
      - motion 컴포넌트 import
      - button을 motion.button으로 변경
      - 지금껏 해본 적 없는 작업으로, animate 속성을 설정하지 않을 것이기 때문이다.
        - 버튼의 크기를 바꿀 수 있다. 그리고 사용자가 커서를 위에 올리면 튀어나오게 할 수도 있다.
        - animate 속성을 활용해 버튼을 애니메이션화 한다는 건 onHover 이벤트를 듣고 버튼 크기를 바꿔야 한다는 뜻이다.
          - 사용자가 버튼에 커서를 올릴 때, 그리고 버튼 밖으로 커서를 옮길 때
        - 할 수 있는데 불필요한 작업이 많이 수반되기 때문에, 프레이머 모션에서 프레임워크 컴포넌트에 추가할 수 있는 특수한 속성을 사용해서 구성
      - while
        - `whileHover`나 `whileTap`과 같은 속성도 있는데, 이를 적용하면 사용자가 탭 하거나 커서를 올릴 때만 적용되는 애니메이션 상태를 정의할 수 있다.
        - 요소가 보이는 동안, 즉 페이지에 표시되는 동안에만 적용할 수 있는 `whileInView`
        - 여기에서는 whileHover을 사용할 예정
      - whileHover
        - 이 안에 animate 속성에 추가하듯이 애니메이션 객체를 설정할 수 있다.
        - 예시로, 크기를 1.1로 바꾸면 버튼이 10% 커진다.
          - `whileHover={{ scale: 1.1 }}` 이렇게 하면 끝
          - 이 상태로 저장하고 확인하면 커서를 올렸을 때 버튼이 커지는 것을 확인할 수 있다.
            - 하지만 크기만 커지고 튕겨 나오는 느낌은 없다.
            - 프레이머 모션은 스프링 애니메이션을 기본으로 적용해 주지 않기 때문이다.
      - transition 프로퍼티
        - type을 spring으로 설정해서 튕겨나오는 효과를 추가
        - 이 속성이 정말 유용한 건 해당 요소에 적용된 모든 애니메이션에 반영해 준다는 것이다.
          - animate로 설정했든, exit로 했든, whileHover로 했든 상관없다.
        - spring으로 바꾼 다음에 stiffness(강성)이라는 설정을 추가
          - stiffness는 500으로 설정
          - stiffness 역시 튕김 효과에 영향을 준다.
          - `transition={{ type: "spring", stiffness: 500 }}`
        - 이 외에 mass(질량) 등 여러 속성도 있기 때문에 다양한 값을 주면서 효과가 어떻게 변하는지 살펴보면 좋다고 한다.
    - 저장하고 확인해보면 버튼에 커서를 올리고 내릴 때 튕기는 듯한 느낌의 효과가 더해지는 것을 확인할 수 있다.
      - 이전보다 훨씬 더 튀어 오르는 느낌을 받을 수 있다.
      - 지금이 훨씬 더 자연스러워 보이는데, 이제 모달이 뜨고 사라지는 애니메이션 외에도 버튼이 자연스럽게 튕겨 나오는 애니메이션이 더 해져서 한층 더 자연스러워 보이는 것을 확인할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/b2ee26db15c1a2699b94751ffa6edb5a67f439a5)

  <br />

  - 애니메이션 상태 재사용하기
    - Modal 컴포넌트에서 initial과 exit 애니메이션은 똑같이 생겼는데, 이걸 재사용할 수 있게 구성
      - 상수를 하나 추가해서 여기에 객체 내용을 저장해서 사용할 수 있다.
        - `const hiddenAnimationState = { opacity: 0, y: 30 }`
      - initial, exit에서는 객체 대신에 상수를 대신해서 사용한다.
        - `initial={hiddenAnimationState}`
        - `exit={hiddenAnimationState}`
      - 이렇게 하면 수정이 필요할 때 두 군데 각각 바꾸는 대신 한 군데만 수정을 하면 된다.
    - 특정 애니메이션 값이나 상태를 다시 사용하는 다른 방법이 있다.
      - motion 컴포넌트에 `variants` 속성을 추가하면 된다.
      - variants의 주요 개념은 조금 달라서 다음 강의에서 구체적으로 알아볼 예정이다.
      - 지금은 variants 속성이 특정 애니메이션 상태를 정의하거나 재사용하는데 유용하다는 것만 알고 넘어가면 된다.
    - variants 속성
      - variants는 객체를 취하는데 애니메이션 객체가 아니라, 원하는 키를 설정할 수 있는 객체가 들어간다.
      - hidden이라는 키를 넣고, 이 키에 대한 값으로 애니메이션 객체를 넣으면 된다.
        - 이렇게 하면 커스텀 식별자를 정의하게 되고 식별자가 타겟팅되면 애니메이션 상태가 적용되는 것이다.
        - 식별자를 타겟팅하는 법은 곧 배울 예정
        - `hidden : { opacity: 0, y: 30 }`
      - visible을 하나 더 추가
        - 여기에는 animate의 애니메이션 상태를 넣어준다.
        - `visible: { opacity: 1, y: 0 }`
      - 여기서 hidden이나 visible은 원하는 이름으로 설정하는 것이다.
        - 정해진 이름이 아님
      - 이제 서로 다른 배리언트를 타겟팅해서 각각의 애니메이션 상태를 적용할 수 있다.
        - 이 식별자들을 initial과 animate, exit의 값으로 넣을 수 있다.
        ```
        variants={{
          hidden: { opacity: 0, y: 30 },
          visible: { opacity: 1, y: 0 },
        }}
        initial="hidden"
        animate="visible"
        exit="hidden"
        ```
        - initial, animate, exit에 넣은 키는 variants의 객체에서 구성한 키와 동일해야 한다.
          - 오탈자가 없도록 잘 확인해야 한다.
      - 위처럼 구성하면 variants를 일단 한 번 정의해놓고 재사용하면 되는 쉬운 방법이 생긴 것이다.
        - 예시로, whileHover나 다른 속성에서 사용할 수도 있다.
    - 이 상태로 확인해보면 모달은 여전히 진입하고 나오는 애니메이션을 보여준다.
      - 결과는 이전과 같지만 이번엔은 variants를 사용한 것이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/13d965017a05183f4b4fe34c680f02ccb320c4dd)

  <br />

  - 중첩 애니메이션과 variants
    - variants는 애니메이션 상태를 정의하고 재사용하는 데만 쓰이는 게 아니라, 컴포넌트 트리 안 깊숙한 곳에서 애니메이션을 트리거하는데 쓰일 수도 있다.
      - 조상 컴포넌트에서 애니메이션을 특정 variants로 설정해주면 된다.
    - variants의 기본적인 개념은 래퍼나 부모 컴포넌트에서 특정 애니메이션 상태를 variants로 설정할 수 있다는 것이다.
      - 래핑된 컴포넌트 또는 자식 컴포넌트 안에서 동일한 variants를 정의할 수 있다.
      - 앞에서 정의한 hidden, visible을 같은 이름으로 쓸 수 있다는 것이다.
      - 활성화하기 위해서 별도의 설정을 할 필요는 없고, 부모 컴포넌트나 래핑 컴포넌트에서 활성화되어 있다면, 자식 컴포넌트에서 자동으로 활성화된다.
        - 이게 유용한 이유는, 예시로 모달의 경우 하단의 이미지가 나타나는 모습을 애니메이션화 할 수 있다.
        - variants 기능 덕분에 NewChallenge.jsx의 순서 없는 리스트에서 이미지에 해당하는 리스트 항목에 접근하여 motion 리스트 항목으로 바꿔 variants로 애니메이션화할 수가 있다.
    - NewChallenge.jsx에서 프레이머 모션 사용
      - motion import
      - 리스트 항목에서 motion.li로 바꿔준다.
      - 리스트 항목이 표시될 때 애니메이션이 플레이되도록 할 건데, 이때 animate나 initial을 넣을 필욘 없다.
      - variants 속성으로 hidden과 visible만 정의해주면 된다.
        - 이걸 래핑하고 있는 부모 컴포넌트, 즉 모달 컴포넌트에 의해 자동으로 활성화 되기 때문이다.
        - Modal 컴포넌트에서 이미 hidden이라는 variants를 initial 상태의 값으로 설정해두었고, visible은 animaite 상태의 값으로 설정해놨기 때문이다.
        - 그리고 initial, animate, exit와 같은 정보는 어떤 시점에 어떤 variants가 활성화되는지에 대한 정보는 프레이머 모션에 의해 모든 래핑 또는 자식 컴포넌트에 전달될 것이다.
          - 당연히 리스트 항목에도 전달이 되게 된다.
        - hidden과 visible이라는 variants만 정의해주면 된다.
          - 그러면 부모 컴포넌트가 활성화될 때 자동으로 함께 활성화될 것이다.
          - hidden 구성
            - 이미지들은 처음에는 투명한 상태에, 크기는 좀 더 작아서 눈에 보이기 시작하면서 크기가 더 커지도록 만들어준다.
            - `hidden: { opacity: 0, scale: 0.5 }`
          - visible 구성
            - 불투명도와 크기 모두 1로 설정
            - `visible: { opacity: 1, scale: 1 }`
      - 자식 애니메이션 요소에도 사용할 수 있는 transition 속성도 추가해서 spring 애니메이션 type을 설정해준다.
        - `transition={{ type: "spring" }}`
    - 여기까지 진행된 내용으로 확인해보면, 모달을 열었을 때 하단의 이미지들이 튕기는 효과가 적용된 것을 확인할 수 있다.
      - 하지만 여기에서 모달을 닫을 때, 이상한 효과가 적용되는 것을 확인할 수 있는데 백드롭이 사라지는데 시간이 좀 걸린다.
        - 이와 같은 동작이 나타나는 이유는 모달에서 exit 속성을 hidden variants로 설정해서 그렇다.
        - 따라서 자식 컴포넌트에서도 활성화가 되는 것이다.
      - 이미지들이 자식 컴포넌트에서 애니메이션화가 된다는 건데, 모달을 닫을 때 보면 모달이 사라지기 직전에 줄어드는 것을 확인할 수 있다.
        - 프레이머 모션이 이미지 애니메이션이 종료된 다음에, 백드롭을 포함해서 모든 요소를 DOM에서 지우려고 기다리는 것이다.
        - 이렇게 되는 것은 원하는 결과가 아니기 때문에 수정을 해줘야 한다.
    - NewChallenge.jsx에서 추가 작업
      - 문제가 있는 동작을 고치기 위해 자식 컴포넌트인 NewChallenge의 리스트 항목 컴포넌트에서 exit 속성을 visible로 설정
        - `exit="visible"`
        - 이렇게 하면 리스트 항목에서 exit 상태로 들어갈 때 활성화되는 variants를 오버라이드하게 된다.
        - 다른 컴포넌트는 제외하고 이 컴포넌트에 한해서만 visible variants를 설정하는 것이다.
        - 모달에 해당하는 부모 컴포넌트의 exit 상태는 여전히 hidden이고, 자식 컴포넌트 즉, 중첩된 리스트 항목에서의 exit 상태는 visible로 설정한 것이다.
          - 애니메이션이 플레이되지 않도록 한 것이다.
          - 이미 visible 상태에 있기 때문이다.
    - 이제는 모달이 닫힌 직후 바로 백드롭이 사라지는 것을 볼 수 있다.
      - 하지만 이번에는 진입 시 이미지에 적용된 애니메이션이 다시 사라진 것을 확인할 수 있다.
        - 모달을 열면 이미지가 튀어 오르는 듯한 효과가 다 사라짐
      - 위와 같은 문제가 생기는 이유는 애니메이션을 활성화하고자 variants 기능을 사용할 때 자식 컴포넌트에서 initial이나 animate, exit와 같은 애니메이션 속성 중 하나를 설정할 경우, variants의 이름을 사용할 수 없다.
        - 그 대신, 해당 variants에 할당된 값을 복사해서 붙여 넣어야 한다.
          - variants 기능을 사용하려면 꼭 해결하고 넘어가야 하는 부분이다.
        - `exit={{ opacity: 1, scale: 1 }}`
        - 나중에 위 같은 방법이 수정될 수도 있지만, 강의를 녹화했을 때와 마찬가지로 지금도 variants의 이름을 사용할 수 없고, 위 예시처럼 구성해줘야 한다.
    - 수정을 해주고 모달을 열면 이미지 애니메이션이 다시 돌아온 것을 확인할 수 있다.
      - 닫히는 것도 문제 없이 작동한다.
      - 진입 애니메이션도 활성화되었고, 모달도 빠르게 닫힌다.
      - 부모 컴포넌트 안에 있는 자식 컴포넌트에서 variants를 사용해 애니메이션도 활성화 되어 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/005fb58807d19818023953c2203716af68b0492a)

  <br />

  - 리스트 애니메이션에 staggering(스태거링) 효과 주기
    - 리스트를 렌더링할 때 모든 리스트 항목이 같은 시점에 나타나거나 애니메이션화되길 원치 않을 때가 있다.
      - 그 대신 하나씩 차례대로 애니메이션화 되는게 필요한 때가 있을 것이다.
        - 이 기법을 staggering(스태거링)이라고 한다.
    - staggering 기법
      - 리스트 항목이 애니메이션으로 나타나는데 시차를 두는 것을 말함
      - 동시에 플레이되는게 아니라 하나씩 플레이 되도록 하는 것이다.
      - 프레이머 모션을 활용하면 손쉽게 구현할 수 있는 기능이다.
    - staggering 사용
      - staggering을 적용하고 싶은 리스트 항목의 부모 요소로 간다.
        - ex) ul 요소, 순서 없는 리스트 요소
      - ul 요소에서 motion.ul 요소로 바꾼다.
      - 여기까지 하면 자식 애니메이션 활성화에 variants를 사용했기 때문에 부모에도 variants 속성을 추가해야 한다.
        - 여기서는 visible을 넣어준다.
        - 하지만 여기에선 순서 없는 리스트의 불투명도나 크기를 애니메이션화하는게 아니라, 해당 리스트의 모습이나 동작에 만족하기 때문에 리스트 전체를 애니메이션 할 것도 아니고, 리스트 항목만 애니메이션 할 것이기 때문에, 그런 속성들은 건드리지 않고 특별한 transition 속성을 설정한다.
        - 전체 컴포넌트에 적용된 transition 속성과 같은 설정을 적용할 수 있게 해준다. 그리고 해당 컴포넌트의 모든 애니메이션을 특정 애니메이션에 적용할 수 있다.
        - 추가로, 이 기능은 variants에서만 가능한 건 아니다.
          - 가끔 어떤 컴포넌트에 있는 모든 애니메이션이 적용되도록 설정해야 할 때가 있는데, transition 속성은 어디든 넣어서, 가령 exit 애니메이션만 제어하거나 exit 애니메이션에만 다른 설정을 적용하는 방식으로도 쓰일 수 있다.
          - 다른 애니메이션에 적용된 설정과는 다르게 할 수 있다.
          ```
          exit={{ opacity: 1, scale: 1, transition: {} }}
          transition={{ type: "spring" }}
          ```
        - variants에 사용할 때는 리스트 항목의 부모 컴포넌트의 visible에 transition을 설정해서 특별한 설정 옵션을 넣을 수가 있다.
          - staggerChildren 설정 옵션
        - staggerChildren 옵션은 부모 요소에 속한 자식 요소가 애니메이션을 시작하는 시점의 차이를 조절하는데 쓰인다.
          - 기본 값은 모두 동시에 시작하도록 설정되어 있고, staggerChildren의 값을 0 외의 값으로 설정하면 모든 자식 항목 사이에 그 값에 해당하는 시차가 생기게 된다.
          ```
          variants={{
            visible: { transition: { staggerChildren: 0.05 } },
          }}
          ```
          - 이 경우 두 번째 애니메이션은 첫 번째 애니메이션이 나오고 0.05초 후에 시작한다.
          - 세 번째는 두 번째 애니메이션이 나오고 0.05초 후에 시작하고, 그 뒤에도 똑같이 0.05초 후에 시작한다.
    - 위에서 설정한 시차를 가지고, 모달을 열면 하단의 이미지들이 동시에 나타나지 않고 하나씩 차례대로 나타나는 것을 확인할 수 있다.
      - 시차의 값에 어떤 값을 넣을지는 내 마음대로고, 강의에서는 값을 낮춰서 staggering 효과가 적용은 되도록 해주며, 애니메이션은 전체적으로 빠르게 진행되도록 하는 걸 추천했다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/db90686bdc687ddda6ee1fc126677bcb80587a7c)

  <br />

  - 색상 애니메이션 추가 및 키 프레임으로 효과 주기
    - 이번 섹션에서 지금까지는 여러 애니메이션 속성 값으로 숫자만 할당했다.
      - 불투명도나 크기 같은 속성들에 숫자만 넣어줬었음
      - 당연하게도, 애니메이션화를 할 때 가장 중요한 속성들이 불투명도, 크기, X, Y 같은 것들이기 때문이다.
      - 하지만 반드시 단순한 숫자에만 국한되지 않는다는 점을 짚고 넘어가는 내용이다.
    - Header.jsx에서 버튼 수정
      - 현재는 마우스 Hover되면 튀어나오는 버튼으로 되어있다.
        - 버튼 색깔도 애니메이션화 할 수 있다.
      - 색깔을 애니메이션화할 때는 숫자가 아니라, 헥스 코드로 설정해야 한다.
      - whileHover 속성에서 수정
        - backgroundColor의 속성값을 추가한다.
        - 이렇게 하면 크기만 애니메이션화 하는 게 아니라, 배경색도 바꿀 수 있다.
        - 애니메이션으로 바꾸고자 하는 색의 헥스 코드가 포함된 문자열을 입력하면 된다.
          - `#8611f0`을 추가해서 보라색 배경으로 만들어준다.
        - `whileHover={{ scale: 1.1, backgroundColor: "#8b11f0" }}`
        - 버튼의 색깔도 튀어 오르는 효과와 더불어 미세하게 바뀌는 모습을 확인할 수 있다.
          - transition 설정이 색에도 적용된 것이다.
      - 여기서 중요한 건 애니메이션 효과는 숫자를 값으로 취하는 크기나 불투명도 위치 등에만 국한되지 않는다는 것이다.
        - 프레이머 모션을 활용하면 색깔과 같은 더 복잡한 설정도 조절할 수 있다.
        - 다른 유형의 값을 넣을 수도 있다.
    - NewChallenge.jsx에서 작업
      - staggering 효과가 적용된 리스트 항목 애니메이션 부분을 보면 visible variants가 있다.
        - 여기서 크기를 1로 설정해놓았는데, 크기가 0.5에서 1로 커지는 애니메이션이 표시된다.
        - 요소의 크기가 절반에서 원래 크기가 되도록 설정해둔 상태이다.
        - 여기에 단순한 숫자가 아니라 배열을 값으로 넣을 수도 있다.
          - 애니메이션의 속성에 대한 값으로 배열을 넣으면 항목들이 애니메이션으로 표시될 때 프레이머 모션이 거치는 키 프레임의 배열을 생성하게 된다.
          - 첫 번째 값과 마지막 값만을 지니는 대신 애니메이션이 거치게 될 여러 단계를 정의할 수 있다.
      - 리스트 항목의 visible variants에서 배열을 추가해 작업
        - 배열에 여러 숫자를 넣을 수 있다.
        - 시작은 80% 크기였다가, 다음은 1.3까지 커지고 원래보다 30%가 더 커졌다가, 마지막에는 1로 끝나게 구성
          - `visible: { opacity: 1, scale: [0.8, 1.3, 1] }`
          - 50% 크기에서 80%, 130%까지 커졌다가 1로 종료가 된다.
    - 저장하고 모달창을 확인해보면, 하단의 이미지들이 하나씩 튀어 오르듯 표시되는데 위에서 설정한 키 프레임에 기반해서 이전과는 조금 다른 모습으로 뜬다.
      - 이 역시 알아 둬야 하는 또 다른 기능이다.
      - 애니메이션화 하는 속성에 대한 값으로 키 프레임을 넣을 수 있다는 것을 알아둬야 한다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/5b6fefc728806bb65b88d7804e521e0ca1551987)

  <br />

# 오늘 느낀 점

- 프레이머 모션을 사용해서 여러 애니메이션을 구현했는데, 초반에는 정말 간단하며 쉽다고 생각이 들었는데, 조금씩 내용이 복잡해지는게 느껴진다. 간단한 애니메이션을 추가할 때도 정말 유용하고 편리하다고 생각이 되었는데, 조금 복잡한 애니메이션을 추가할 때는 더 유용하고 실용적인 기능들이 많았다고 생각이 된다. 프레이머 모션은 CSS 애니메이션보다 더 자연스러운 느낌을 주기 때문에 웹 사이트에 방문한 사용자들이 기능을 작동했을 때 기분 좋은 경험을 줄 수 있을 것 같다. 앞으로는 좀 더 복잡하지만 유용한 기능들이 많이 남아있기 때문에 제대로 배워서 활용할 수 있도록 해야 할 것 같다.

- 모달창처럼 요소가 나타나고, 사라지는 상태를 구현할 때, 프레이머 모션에서 세트로 알고 있어야 하는 속성이 있다. 요소가 DOM에 나타날 때의 시작 상태는 initial 프로퍼티로 정의하고 나타난 직후 애니메이션의 상태는 animate로 정의, exit로는 요소가 DOM에서 삭제될 때 적용하고 싶은 애니메이션 상태를 정의한다. 보통 이렇게 요소가 나타나고, 사라질 때는 initial-animate-exit 이렇게 세 가지가 고정이라고 생각하고 기억해두면 좋을 것 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
