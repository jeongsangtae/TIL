# 오늘 한 일

### React 공부

- React 앱에 애니메이션 넣기

  - 명령적 접근법으로 애니메이션 구현하기
    - 지금까지는 기본적인 프레이머 모션의 motion 컴포넌트로 JSX 코드에서 속성을 통해 선언형으로 애니메이션 설정을 정의하는 기본적인 접근법만 다뤘다.
      - 대부분 이런 방식으로 프레이머 모션을 활용해 애니메이션을 정의하고 제어한다.
      - 하지만 가끔은 선언형이 아닌, 명령적 방식으로 애니메이션을 시작해야 하는 경우나 사례가 있다.
    - 사용자가 유효하지 않은 form을 제출했다고 가정하고 시작
      - 여러 입력 필드가 공란이거나, 최소 하나의 입력 필드가 공란이라는 가정
      - 사용자가 입력 필드에 유효한 값을 입력하지 않은 채로 제출하려고 할 때, 모든 입력 필드에 흔들리는 효과를 애니메이션으로 추가해보는 연습
      - 선언형 접근법으로도 이 효과를 구현할 수 있지만, 명령적 방식으로는 어떻게 하는지 보여주는 섹션
        - 프레이머 모션은 명령적 방식도 지원한다.
      - 명령적 접근법을 사용해 흔들리는 효과를 애니메이션으로 구현
    - NewChallenge.jsx 컴포넌트에서 작업
      - useAnimate Hook을 프레이머 모션에서 가져와서 사용
      - useAnimate Hook
        - 두 개의 중요한 요소를 포함한 배열을 return한다.
          - scope와 animate 요소
          - 이름 짓는건 마음대로
        - 첫 번째 요소는 ref가 된다. 요소에 추가할 수 있다.
          - scope에 대한 내용은 뒤에서 추가 작성
        - 두 번째 animate 요소는 함수가 된다.
          - 특정한 애니메이션을 명령적으로 트리거 하기 위해 코드에 사용할 수 있는 함수다.
      - 애니메이션이 트리거 되는 if문에서 작업
        - 입력값에 유효하지 않은 값이 있지는 않은지 확인하고 없다면 바로 return한다.
        - 여기에 animate를 호출해서 특정 애니메이션을 트리거 하여 입력과 텍스트 영역 요소를 흔들도록 할 것이다.
        - animate에는 첫 번째 인수에 문자열을 입력
          - 애니메이션화 되어야 하는 요소를 타겟팅 하기 위해 CSS 선택자를 사용
            - `animate("input, textarea")`
              - 이렇게 모든 input과 textarea를 넣는다.
            - 또는 `animate(".some-input")`
              - CSS 클래스를 넣어도 된다.
        - 애니메이션화 할 두 번째 인수로, 플레이되어야 하는 애니메이션을 설명하는 객체를 입력한다.
          - 이 객체는 아래에서 exit나 initial, animate 또는 variants에 입력했던 것과 같은 객체이다.
            - 어떤 속성이 어떤 값으로 애니메이션화 되어야 하는지 정의했던 객체들을 말한다.
          - 예로, x 위치를 애니메이션 한다고 하면 요소가 x축을 따라 이동하고 키 프레임을 정의해서 좌측으로 10px 이동하고 중앙으로 돌아왔다가 우측으로 10px 이동했다가 다시 중앙으로 돌아오게끔 구성
            - `animate("input, textarea", { x: [-10, 0, 10, 0] });`
            - 이렇게 하면 모든 요소가 좌우로 흔들리는 모습이 된다.
            - 여기에 불투명도처럼 opacity를 추가해서 원하는 속성을 설정해도 된다.
        - 세 번째 인수로는 설정 객체를 넣어서 애니메이션이 어떤 식으로 플레이 되는지 설정할 수 있다.
          - transition 속성이나, variants에 추가하는 transition 속성과 같다.
          - 따라서 마지막 객체에는, type은 spring 애니메이션이며, 지속 시간은 0.2초라고 설정하고 좀 더 멋지게 해보기 위해 delay 속성을 추가해 애니메이션이 시작되기 전 지연 시간을 설정할 수도 있다.
            - `animate("input, textarea", { x: [-10, 0, 10, 0] }, {type: "spring", duration: 0.3, delay: });`
            - delay 자체로는 뭐가 멋진가 싶을 수 있다. 하지만 프레이머 모션이 제공하는 다른 명령적 함수와 함께 사용하면 멋있는 기능이 된다.
              - 여기서 추가로 stagger 함수를 가져온다.
          - stagger는 익숙한데 앞에서 staggerChildren이라는 설정을 사용해서 자식 리스트 항목의 애니메이션에 시차를 주었었다.
            - 각 항목의 애니메이션 사이에 지연 시간을 더했었다.
            - stagger 함수도 명령적 방식으로 애니메이션을 설정할 경우 같은 걸 할 수 있게 해준다.
              - animate 함수를 사용할 때 stagger 함수를 사용하면 staggerChildren과 같이 작동하게 할 수 있다.
          - delay를 stagger라고 설정하고, 값으로 0.05를 할당하면 순서 없는 목록에서 staggerChildren에 한 것과 같은 결과를 얻을 수 있다.
            - `delay: stagger(0.05)`
            - CSS 선택자가 타겟팅한 서로 다른 요소에 대한 각각의 애니메이션 사이에 시차를 더해준다.
            - 한꺼번에 전체를 흔드는 게 아니라 하나씩 차례대로 할 수 있게 해준다.
        - 애니메이션을 명령적으로 트리거 하는 전체 코드
          ```
          animate(
            "input, textarea",
            { x: [-10, 0, 10, 0] },
            { type: "spring", duration: 0.3, delay: stagger(0.05) }
          );
          ```
          - 이걸로는 아직 불완전하다. useAnimate가 return하는 배열의 첫 번째 요소인 scope 요소를 설정해줘야 한다.
      - scope는 결국 ref이다.
        - useRef로 직접 생성할 수 있기 때문이다.
        - scope는 animate 함수에서 설정하는 CSS 선택자의 범위를 정해 주는 JSX 요소에 연결된다.
          - 모든 페이지가 아니라 정해진 영역에서만 input과 textarea 요소를 선택하기 위해서 사용
      - form에서 ref를 추가해 scope 사용
        - form에 ref를 추가하고, form의 ref 속성에 대한 값으로 scope라는 ref를 입력한다.
          - `<form id="new-challenge" onSubmit={handleSubmit} ref={scope}>`
        - 이렇게 하면 animate는 다른 페이지는 제외하고 form 안에 있는 input과 textarea만 선택한다.
    - 위처럼 useAnimate를 활용해 애니메이션을 명령적으로 트리거 하도록 설정한 상태로, form에 유효하지 않은 값이 있는 채로 제출하면 각 입력 필드가 좌우로 흔들리는 것을 확인할 수 있다.
      - 동시에 흔들리지 않고 차례대로 시차를 두고 흔들린다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/822037ac406dede0f0581dd25dfebd6e21b4bac5)

  <br />

  - 레이아웃 변화에 애니메이션 적용하기
    - 상단에 탭이 여러 개 있는데, 여기에 어떤 애니메이션도 적용되어 있지 않다.
      - 탭 사이를 전환할 때도 그렇지만, 여러 개의 항목 중에서 "완료"로 표시한 항목이 다른 탭으로 이동할 때도 애니메이션이 없다.
        - 그냥 사라지고 다른 탭에 생긴다.
      - 현재로선 어떤 애니메이션도 없이 그냥 업데이트한다.
      - 이 부분은 더 개선할 수 있는 부분이고 지금부터 구성해 볼 내용이다.
    - ChallengeItem.jsx 컴포넌트에서 작업
      - 도전 항목을 "완료"로 표시할 때의 애니메이션부터 추가해야 한다.
        - 구체적으로 말하면 항목이 사라질 때 지금의 리스트가 즉시 업데이트 되지 않고, 화면도 갑작스럽게 전환되지 않으며, 상기 항목이 사라지면 남은 항목이 부드럽게 위로 올라오는 애니메이션을 구현할 것이다.
      - 리스트 항목을 motion.li 항목으로 대체한다.
        - 이미 motion이 import되어 있기 때문에 motion 컴포넌트로 바꿔주기만 하면 된다.
      - layout 프로퍼티
        - 특별한 속성으로 motion 컴포넌트에 이 속성을 추가하면 프레이머 모션이 해당 컴포넌트에 속한 레이아웃 변화에 자동으로 애니메이션을 적용해 준다.
          - 이 경우 motion.li 항목에 적용된다.
          - `<motion.li layout>`
        - 예로, 항목이 두 개 있는 리스트에서 첫 항목을 "실패"로 표시하여 옮기면 아래의 두 번째 항목은 당연히 그대로 남는다.
          - 단순히 위로만 올라갈 뿐이다.
          - 이 올라가는 동작이 프레이머 모션에 의해 애니메이션화 된다는 것이다.
        - 모션 컴포넌트에 layout이 추가된 상태에서 첫 번째 항목을 "실패"로 표시하여 목록에서 지우면 두 번째 항목이 자연스럽게 위로 올라간다.
          - 항목에 하나만 남은 상태에서 "실패" 표시를 해도 애니메이션이 없을 것이다.
          - 위로 올라가거나 하는 것이 아닌, 탭에서는 그냥 사라지고 다른 탭에 나타나기 때문이다.
          - 요소가 다른 위치로 이동해야 하는 상황에서는 애니메이션이 적용된다.
          - 이게 작동하는 이유는 이동하는 요소에 layout 속성을 추가한 덕분이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/1bdf25af6211891c898e112285f48ba7c99d91b2)

  <br />

  - 여러 요소 애니메이션 조율하기
    - 탭 요소에 애니메이션을 적용할 게 더 남아있다.
      - 항목이 사라질 때 애니메이션을 적용할 수도 있다.
      - 남은 항목이 새 위치로 이동할 때뿐만이 아니라 사라지는 항목에도 적용할 수 있다.
        - 근데 이 작업은 모달 사례에서 요소가 사라질 때 애니메이션을 적용해 본 적이 있다.
        - 이번에는 Challenges.jsx 파일에서 적용해야 한다.
          - 리스트 항목들을 렌더링하고 있는 파일이기 때문이다.
          - 표시되는 항목의 개수를 통제하고 또 항목들에 변동 사항이 생기면 리스트를 업데이트 하는 코드가 있는 부분이기 때문이다.
    - Challenges.jsx 컴포넌트에서 작업
      - AnimatePresence를 import
      - 도전 항목 리스트의 렌더링을 AnimatePresence로 래핑해준다.
        - `<AnimatePresence> {displayedChallenges.map(...)} </AnimatePresence>`
    - ChallengeItem.jsx 컴포넌트에서 작업
      - motion 컴포넌트가 된 list 항목에 exit 속성을 추가해서 항목이 제거될 때 플레이하고 싶은 애니메이션을 정의한다.
        - 종료될 때 y위치, 즉 수직축이 -30px 움직이도록 설정
          - 위로 30px 올라간다.
        - 불투명도는 0으로 바꿔준다.
        - `<motion.li layout exit={{ y: -30, opacity: 0 }}>`
        - 이제 리스트에서 항목을 지울 때마다 exit 애니메이션이 플레이 된다.
          - 해당 항목은 투명해지고 위로 올라가게 된다.
    - 리스트에서 확인해보면, 위로 올라가면서 사라지고 나면 다른 항목이 위로 올라온다.
      - 잘 적용되는데, 마지막으로 남은 항목을 지우면 이건 여전히 갑자기 사라진다.
      - 아직도 갑자기 사라지는 이유는 Challenges.jsx 파일에서 보면, 순서 있는 리스트 전체가 DOM에서 사라진 걸 볼 수 있다.
        - displayedChallenges, 즉 화면에 표시되어야 하는 도전 배열이 비어버리면 AnimatePresence가 적용될 대상이 사라지게 된다.
        - 조건부 렌더링 블록의 영향으로 전부 지워졌기 때문에 배열이 비어있는 상태가 되어버린다.
    - Challenges.jsx 컴포넌트에서 추가 작업
      - 마지막 항목에도 애니메이션이 적용되도록 만들기 위해서는 전체 리스트도 AnimatePresence로 래핑해주고 기존의 순서 있는 리스트는 motion.ol로 전환한다.
      ```
      <AnimatePresence>
        {displayedChallenges.length > 0 && (
          <motion.ol className="challenge-items">
            <AnimatePresence>
              ...
            </AnimatePresence>
          </motion.ol>
        )}
      </AnimatePresence>
      ```
      - motion.ol에 exit 애니메이션을 설정해준다.
        - 개별 항목에 적용한 것과 같은 설정을 적용해준다.
          - 사라질 때 전체 리스트에도 애니메이션이 적용되도록 해주는 것이다.
        - `<motion.ol exit={{ y: -30, opacity: 0 }} ... >`
    - 확인해보면, 마지막 항목에도 애니메이션이 적용된 것을 확인할 수 있다.
      - 이제 항목이 있는 리스트에서 없는 탭으로 전환 했을 때도 애니메이션이 플레이 된다.
        - 탭을 전환할 때 뒷단의 코드에서는 상태 변화가 일어나고 displayedChallenges가 빈 배열이 되기 때문이다.
        - 필터링 코드에서 데이터를 가져오고 있기 때문에 리스트가 변경됨에 따라 빈 리스트만 남게 된다.
          - 따라서 탭을 전환할 때 displayedChallenges가 때에 따라 빈 리스트가 된다.
        - 전체 리스트가 제거되면 exit 애니메이션이 플레이 되는 것이다.
          - 그래서 항목이 있는 탭에서 없는 탭으로 전환할 때 애니메이션이 플레이 되는 것이다.
      - 마지막 항목이 사라진 다음 텍스트 문구가 리스트가 사라지기 전에 나타나는 것을 확인할 수 있다.
        - 이 동작 또한 수정을 해줘야 한다.
    - Challenges.jsx 컴포넌트에서 또 다시 추가 작업
      - 이 문제는 AnimatePresence를 단순히 리스트만이 아니라 선택된 탭의 리스트에 항목이 없을 때 나타내는 대체 문구까지 감싸도록 해서 해결할 수 있다.
        ```
        <AnimatePresence>
          {displayedChallenges.length > 0 && (
            <motion.ol
              exit={{ y: -30, opacity: 0 }}
              className="challenge-items"
            >
            ...
          {displayedChallenges.length === 0 && <p>No challenges found.</p>}
        </AnimatePresence>
        ```
        - 하지만 이걸로는 충분하지 않다.
          - 다시 리스트를 비우면 항목이 위로 올라가면서 사라지는 것이 아닌, 갑자기 사라진다.
      - 순서 있는 리스트에 다시 exit를 불러오려면 순서 있는 리스트와 텍스트 문구 부분을 수정해야 한다.
        - 현재 리스트와 문구를 감싸고 있는 AnimatePresence에는 리스트와 문구, 두 요소가 있다.
        - 두 요소의 타입이 순서 있는 리스트와 문구로 서로 다르기는 하나, key 속성을 추가해서 프레이머 모션에 둘이 별개임을 알려줘야 한다.
          - ChallengeItem과 관련한 AnimatePresence 부분에도 똑같이 필요한데, 여기에는 이미 있다.
            - ` <ChallengeItem key={challenge.id} ...>`
          - 조건적으로 NewChallenge 컴포넌트를 렌더링 했던 Header에서 key를 필요로 하지 않았던 건 AnimatePresence 사이에 컴포넌트가 하나만 있었기 때문이다.
            - 하지만 두 개 이상이 있으면 AnimatePresence에 있는 각 요소에 key를 추가해야 한다. 그래야 프레이머 모션이 서로 별개임을 안다.
        - 여기에는 고정 코드화된 키를 넣으면 된다.
          - 순서 있는 리스트에는 list라는 키를, 대체 문구에는 fallback을 넣으면 된다.
          - `<motion.ol key="list">`
          - `<p key="fallback">No challenges found.</p>`
      - 키를 추가하고 나면 리스트를 비울 때 애니메이션은 회복됐지만, 대체 텍스트는 여전히 마지막 항목이 애니메이션과 함께 사라지는 시점에 나타난다.
        - 이 동작을 고치기 위해서는 하나만 더 처리하면 된다.
      - 순서 있는 리스트와 문구를 감싸고 있는 AnimatePresence를 설정하면 된다.
        - AnimatePresence 옆에 mode 속성을 추가하여 wait라고 설정하면 된다.
          - `<AnimatePresence mode="wait">`
        - 기본 값은 sync이다.
          - 이 컴포넌트 안에 있는 모든 애니메이션을 동시에 플레이한다.
          - 리스트처럼 어떤 요소가 사라지거나 문구처럼 어떤 요소가 나타나면 두 애니메이션을 동시에 플레이한다.
        - 여기에서는 mode를 wait로 설정해서 첫 번째 요소가 사라지기를 기다렸다가 나타나는 애니메이션을 플레이 하도록 한다.
    - AnimatePresence의 mode를 wait로 설정하고 나면 첫 번째 항목과 두 번째 항목까지 사라지기를 기다렸다가 대체 문구 애니메이션을 표시한다.
      - 사실 지금 문구에는 애니메이션이 없다. 그래서 애니메이션을 추가해줘야 한다.
    - Challenges.jsx 컴포넌트의 문구에 애니메이션 추가
      - 일반 문구에서 motion.p로 변경
      - initial과 animate 그리고 exit 속성을 추가해 진입 및 종료 애니메이션을 넣는다.
      - initial에는 객체를 부여해 불투명도 0으로 설정, 항목은 위로 20px 올라가도록 구성
        - `initial={{ opacity: 0, y: -20 }}`
      - animate 역시 객체를 할당하고 불투명도 1로 설정, y는 0
        - 이건 진입 애니메이션이 플레이될 때 원하는 상태가 된다.
        - `animate={{ opacity: 1, y: 0 }}`
      - exit는 불투명도 0, y는 -20으로 돌아오도록 구성
        - `exit={{ opacity: 0, y: -20 }}`
      - 여기에서 variants를 활용할 수 있겠지만, 그냥 기본 객체만으로 설정
    - 저장후 확인해보면, 탭을 전환할 때 문구에도 애니메이션이 적용되어 있다.
      - 리스트를 비우면 마지막 항목이 애니메이션과 함께 사라지고 애니메이션과 함께 문구가 나타난다.
      - 이렇게 여러 항목에 AnimatePresence를 사용하면 각기 다른 항목에 애니메이션 동작 방식과 상호 관계 속에서 애니메이션이 적용되는 방식을 통제할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/1a73f1000c3c283e9092c71cf8ac82f7c4c67237)

  <br />

  - 레이아웃 애니메이션과 다른 애니메이션 통합하기
    - 최소 두 개로 구성된 리스트에서 한 항목의 세부 사항을 보려고 하면 항목들이 이상하게 울렁거린다.
      - 이미지도 잠깐이지만 왜곡되고, 깔끔해 보이지 않는다.
      - 이런 이상한 동작이 나타나는 이유는 리스트 항목이 있는 ChallengeItem에 layout 속성이 적용되어 있기 때문이다.
      - layout을 지우고 확인해보면 이상하게 울렁거리지 않는다. 대신 이제는 갑자기 사라진다. 그리고 남은 항목이 올라가는 듯한 애니메이션도 사라진다.
      - layout이 적용될 시 항목들이 이상하게 꿀렁거리는 동작이 발생하는 이유는 layout을 통해 프레이머 모션이 해당 리스트의 레이아웃 변경 시 애니메이션을 적용해 주기 때문이다.
      - 컴포넌트에 layout이 적용되어 있으면 프레이머 모션이 애니메이션을 적용하는 또 다른 레이아웃 변화로는 해당 컴포넌트의 높이 변화가 있다.
    - 위 문제를 해결하는 방법은 텍스트가 나타날 때 애니메이션을 적용하는 것이다.
      - 항목이 나타나는 것에 명시적으로 애니메이션을 적용하면 갑자기 높이 변경이 일어나지 않고, 레이아웃 애니메이션을 트리거 하지 않을 것이기 때문이다.
    - ChallengeItem.jsx 컴포넌트에서 작업
      - 항목이 나타날 때 애니메이션을 적용하려면 div를 motion.div로 바꾸고 initial 애니메이션 상태를 추가해 세부 사항 영역이 확장될 때의 진입 애니메이션을 설정한다.
        - initial과 animate로 구성
        - initial
          - 항목의 높이를 0으로 설정, 아직 나타나기 전이기 때문이다. 그리고 투명하도록 불투명도도 0으로 설정
          - `initial={{ height: 0, opacity: 0 }}`
        - animate
          - 높이를 auto으로 설정, 불투명도를 1로 설정해서 투명하지 않도록 만든다.
            - 높이의 auto 또한 값으로 넣을 수 있는 설정이다.
            - 꼭 고정된 값만이 아니라 사전에 높이를 정확히 모른다면 auto도 사용할 수 있다.
          - `animate={{ height: "auto", opacity: 1 }}`
    - 저장하고 세부 사항 영역을 클릭하면 좀 더 부드럽게 확장되는 것을 볼 수 있다.
      - 닫힐 때는 여전히 좀 이상하지만, 확장할 때는 괜찮다.
      - 닫힐 때 모습이 여전히 왜곡되는 이유는 isExpanded가 거짓일 경우 항목이 DOM에서 즉시 지워지기 때문이다.
      - 플레이할 exit 애니메이션이 없어지는 것이다.
      - exit 애니메이션을 추가해도 즉시 삭제될 것이기 때문에 플레이 되지 않을 것이다.
      - 여기서 예전에 썼던 방식을 적용해야 한다.
        - AnimatePresence를 다시 사용해야 한다.
    - ChallengeItem.jsx 컴포넌트에서 추가 작업
      - AnimatePresence로 항목 부분을 래핑한다.
        ```
        <AnimatePresence>
          {isExpanded && (
            <motion.div
              ...
            </motion.div>
          )}
        </AnimatePresence>
        ```
      - 초기 상태로 돌아오게끔 exit 애니메이션을 추가해야 한다.
        - `exit={{ height: 0, opacity: 0 }}`
    - 저장하고 다시 보면 열고 닫는 동작 모두 자연스러운 애니메이션이 적용된 것을 볼 수 있다.
      - 이제 항목의 다른 부분을 왜곡하지 않는 것을 확인할 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/e87956581c551bdd79848a0fac54bcb457d829c5)

  <br />

  - 공유된 요소에 애니메이션 적용하기
    - 탭 부분에서 두 가지만 더 손 보면 된다.
      - 첫 번째로 손 보고 싶은 부분은 항목이 없는 빈 탭에서 항목이 있는 탭으로 이동할 때 항목이 나타나는 애니메이션이 없다.
        - 그냥 휙 하고 나타난다.
        - 나쁠 건 없지만, 좋다고도 할 수는 없다.
      - 두 번째 개선점은 탭 아래에 있는 선을 개선해야 한다.
        - 이 선에도 애니메이션을 적용해서 탭 이동 시 부드럽게 전환되도록 하고 싶다.
    - Challenges.jsx 컴포넌트에서 작업
      - 순서 있는 리스트, 즉 exit 애니메이션이 적용되어 있는 곳에서 여기에 리스트가 나타날 때 플레이 되는 애니메이션을 추가해야 한다.
      - 대체 문구에 있는 initial과 animate 속성값을 그대로 가져와서 리스트에도 같은 애니메이션을 적용
    - 적용하고 확인해보면 항목이 없는 탭에서 항목이 있는 탭으로 이동하면 한층 더 자연스럽게 항목이 나타나게 된다.
    - 탭 전환 시 바에 애니메이션을 적용하는 일은 어렵고 복잡하게 들릴 수 있지만, 다행히도 그리 어렵지 않다.
      - 프레이머 모션에는 이런 사용 사례를 위해 특별히 내장된 기능이 있다.
        - UI와 함께 움직여야 하는 공유된 요소가 있는 경우
      - 여기에서 잘 알아둬야 하는 건 바가 위치해 있는 ChallengeTabs의 Tab 컴포넌트에서 세 개의 바를 다루는 셈이라는 것이다.
        - 각 탭에는 탭이 선택되는 경우 조건부로 표시되는 각각의 바가 있다.
        - 따라서 하나의 DOM 요소가 이동하는 게 아니라, 탭의 선택 여부에 따라 추가되거나 삭제되는 세 개의 DOM 요소를 다루는 것이다.
        - 그리고 프레이머 모션에는 이와 같은 사용 사례에 애니메이션을 적용해 주는 내장 기능이 있다.
    - ChallengeTabs.jsx 컴포넌트에서 작업
      - JSX 코드에서 공유된 요소가 생성된 위치에 가서 요소를 motion 컴포넌트로 변환한다.
        - `{isSelected && <motion.div className="active-tab-indicator" />}`
      - 특별한 새 속성인 layoutId 사용
        - layout이 아닌, layoutId
        - 이름에서 알 수 있듯 이 요소에는 ID를 할당해야 한다.
          - ex) `<motion.div layoutId="tab-indicator" ... />`
        - motion 요소에 layoutId를 추가하면 프레이머 모션이 마법을 부린다.
          - 페이지의 다른 위치에 있는 같은 layoutId를 지닌 다른 요소가 렌더링 되는 때를 자동으로 감지해서 알아서 부드러운 애니메이션을 적용해 준다.
        - layoutId를 추가하고 저장하면 끝
    - 확인해보면 탭 하단의 바에 부드러운 애니메이션이 적용된 것을 볼 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/c8c47b11a23e7dd31eb54530f4c6ebb8a143e5ee)

  <br />

  - key를 활용해 애니메이션 다시 트리거하기
    - 이미 플레이된 애니메이션을 다시 트리거 하는 법을 배우는 시간
      - 이를 위해 badge의 숫자가 바뀔 때마다 badge도 튀어 나오도록 만들어야 한다.
      - 항목을 완료 목록에서 실패 목록으로 이동시키면 숫자가 바뀌었으니 두 탭의 badge가 튀어 오르게 하는 작업
    - Badge.jsx 컴포넌트에서 작업
      - 프레이머 모션의 motion import
      - span을 motion.span으로 변경
      - initial, animate 속성 추가 또는 animate만 써도 된다.
        - 키 프레임을 설정해서 initial을 정의하지 않고도 여러 단계를 정의할 수 있기 때문이다.
        - 지금 보여주는 건 대안적인 방식이다.
      - animate
        - 크기부터 애니메이션화, 그리고 키 프레임을 설정해서 처음 크기는 1, 다음에는 1.2, 다시 1
        - `animate={{ scale: [1, 1.2, 1] }}`
      - transition
        - 애니메이션의 지속 시간도 0.3으로 설정
        - `transition={{ duration: 0.3 }}`
    - 저장하고 확인하면 페이지를 다시 로딩할 때마다 badge가 튀어 오르는 걸 볼 수 있다.
      - 하지만 한 번으로 끝난다.
      - 항목을 이동시켜도 badge는 그대로이다.
        - 이유는 애니메이션의 요소가 처음 나타나는 때 한 번만 플레이 되기 때문이다.
      - 한 번으로 끝나는 애니메이션을 다시 시작할 수 있다.
        - 컴포넌트를 재설정해서 방금 나타났다고 React가 생각하도록 할 수 있다.
    - ChallengeTabs.jsx 컴포넌트에서 작업
      - Badge 컴포넌트가 있는 곳에서 key를 추가하면 된다.
      - 리스트에서 key를 많이 접했을 건데, 항목을 매핑해서 리스트를 출력할 때마다 모든 항목에 key를 추가해야 했다.
        - 이게 이 강의에서 배운 내용이고, React 개발자라면 알아야 하는 내용이다.
        - 그리고 이번 섹션에서는 프레이머 모션을 사용할 때 여러 자식 항목에 AnimatePresence를 적용할 경우, 역시 key가 필요하다는 사실을 배웠다.
      - React에선 프레이머 모션을 활용하지 않는 경우에 키는 다른 용도로도 쓰일 수 있다.
        - 어떤 요소에 key를 추가하고 key에 할당된 값을 변경하면 (예로 state 변화 같은 걸 말함) React는 이전 컴포넌트 인스턴스를 없애고 새 것을 렌더링 한다.
          - 따라서 원하는 컴포넌트에 key 속성을 추가하고 값을 변경하면 React가 해당 컴포넌트를 다시 생성해 준다.
          - 이로써 해당 컴포넌트에 저장된 내부 상태는 재설정되고, 플레이 되어야 하는 진입 애니메이션이 다시 트리거 된다.
      - Badge 컴포넌트에 key 속성을 추가하고 badgeCaption을 설정한다.
        - `<Badge key={badgeCaption} ... >`
        - badgeCaption은 badge와 연결된 리스트에 속한 항목의 개수이다.
          - 항목의 개수가 바뀔 때마다 badge의 숫자도 바뀔 테고, 리스트에 속한 항목의 개수가 바뀔 때마다 키 역시 바뀐다.
          - 이러면 badge는 다시 생성되고, 진입 애니메이션도 다시 플레이 된다.
      - 이게 키를 활용해 프레이머 모션이 애니메이션을 다시 플레이 하도록 만드는 방법이다.
    - badge에 키를 추가하고 나서 다시 badge를 관찰해보면, 항목을 "실패"나 "성공"으로 표시하면 완료와 실패 탭의 배지가 튀어 오르는 것을 볼 수 있다.
      - 이 내용은 알고 있으면 무척 유용한 패턴이다.
      - 키를 설정하고, 키에 다른 값을 설정하면 컴포넌트를 다시 생성할 수 있고, 진입 애니메이션을 재실행하는 데 쓸 수 있다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-animation/commit/b17f2690113d05c2052ceec656172805cf92bfb7)

# 오늘 느낀 점

- 오늘 배운 프레이머 모션의 기능들 또한 정말 유용한 기능들이 많았다. 모든 기능들이 유용하지만, 그 중에서 layout을 사용해 자동으로 변화를 시키는 내용과 layoutId를 사용해서 공유되는 다른 요소가 렌더링 될 때, 자동으로 감지해서 알아서 애니메이션을 적용하는 부분이 정말 유용하고 신기하다고 생각이 되었다. 추가로 엄청 유용해보이는 기능이 하나 더 있었는데, 마지막에 배운 key를 활용해 애니메이션을 다시 트리거하는 기능이 정말 유용하다고 생각이 되었다. 이제까지 key를 많이 사용하긴 했지만, key에 할당된 값을 변경하면 React가 해당 컴포넌트를 다시 생성해준다는 내용은 처음 들어서 더 놀라웠던 것 같다. 이 내용을 이용해서 진입 애니메이션을 다시 트리거하는 방식은 정말 유용하고 좋은 방법이라고 생각이 되었다. 앞에서 얘기한 기능들 외에 다른 기능들 또한 모두 유용하고 실용적이기 떄문에 잊지 않고 꼭 다시 봐야 할 것 같다. 이제 내일은 스크롤 기반 애니메이션에 대해 배우고, 추가로 CSS 전환 및 CSS 애니메이션에 대해서 배울 거 같은데, 남은 내용들도 제대로 배워서 나중에 프로젝트를 만들 때 사용할 수 있도록 해야 할 것 같다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
