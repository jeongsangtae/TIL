# 오늘 한 일

### React 공부

- React App 테스트 (유닛 테스트)

  - 비동기 코드 테스트하기
    - 좀 더 복잡한 시나리오 테스트 다루는 내용
      - 더욱 복잡한 컴포넌트를 다룬다.
    - Async.js 컴포넌트 파일을 추가
      - 이 내용은 강의에서 제공한 파일로, 컴포넌트 자체는 복잡하지 않다.
      - state와 useEffect를 사용하고 있다.
      - useEffect에서는 더미 API에 HTTP 요청을 전송해서 더미 post들을 가져오고 있다.
      - post들은 state로 설정되어 JSX에서 list로 렌더링 된다.
      - 이 내용으로 개발 서버를 구동하면 더미 API {JSON} Placeholder에서 post를 가져와서 렌더링한 내용이 보여진다.
      - Async.js에서 이 강의를 통해 배운 핵심 메커니즘을 활용하고 있다.
        - useEffect를 활용해 사이드 이펙트를 처리하고 있다.
        - 몇 가지 복잡한 지점이 존재한다.
    - Async.test.js 파일 추가 및 구성
      - 새로운 테스트 suite를 추가
      - render와 screen 함수를 `@testing-library/react`로부터 가져온다.
      - 여기서 작성하려는 테스트는 post들이 올바르게 렌더링 되었는지를 테스트하는 것이 목적이다.
        - 이게 제일 먼저 작성해야 할 테스트
      - 첫 번째 테스트 코드 작성
        - 준비
          - Async 컴포넌트를 렌더링
        - 실행
          - 단순히 렌더링하는 것이 목적이기 때문에 이 단계는 필요 없다.
          - 그 다음엔 useEffect에 의해 자동으로 post들을 가져오게 되기 때문이다.
        - 단언 (가정 설정문)
          - list 아이템들이 렌더링 됐는지 확인
            - list 아이템들이 렌더링 됐다면 post를 올바로 가져온 것이기 때문이다.
            - post를 못 가져왔으면 list 아이템도 렌더링 되지 않았을 것이다.
          - screen을 활용해 list 아이템들이 렌더링 됐는지 확인
            - 액세스를 얻는 방법은 다양하지만 여기서는 역할(role)에 따라 액세스를 얻게 한다.
            - 역할(role)에 따라서 액세스를 얻게 되면 screen에 list 아이템이 있는지 알 수 있다.
            - list 아이템은 HTML 요소가 맡을 수 있는 역할(role)이기 때문이다.
            - 지원되는 role들에 대해 알아보고 싶다면 관련 [링크](https://www.w3.org/TR/html-aria/#docconformance)를 확인하면 된다.
            - getByRole을 사용할 수 있지만, 복수의 list 아이템을 기대하고 있으므로 getAllByRole을 사용해야 한다.
              - 특정된 역할에 대해 하나를 초과하는 아이템이 있다면 getByRole은 작동하지 않는다.
            - getAllByRole을 사용하는데, 여기서 role은 listitem이다.
              - 이 내용은 링크에 있는 문서에 내용이 나와 있다.
            - `const listItemElements = screen.getAllByRole("listitem");`
          - listItemElements 아이템의 배열이 비어있다면 어떤 아이템도 렌더링 되지 않은 것이며 이는 바람직한 결과가 아니다.
            - 빈 배열이 아닌지 확인하고자 길이가 0이 아닌지를 확인한다.
              - toHaveLength를 사용하면 배열의 길이를 확인할 수 있다.
            - 여기서 관심사는 배열의 길이가 0이 아닌가 하는 것일 뿐이기에, 이것이 내 테스트의 "기대"가 된다.
            - `expect(listItemElements).not.toHaveLength(0);`
    - 현재 이 상태로는 테스트가 실패한다.
      - 그 이유는 listitem이라는 역할을 지닌 액세스 가능한 요소를 못 찾았기 때문이다.
      - 테스트가 실패한 에러를 이해하려면 getAllByRole에 대해 이해해야 한다.
    - getAllByRole
      - query 메소드처럼 즉시 screen의 요소들을 찾으려고 한다.
      - 하지만 Async 컴포넌트에서 HTTP 요청을 보내려고 한다.
        - 이건 비동기 동작이다.
          - 따라서 post를 즉각 가져오지는 않는다.
          - 대신 컴포넌트가 렌더링 된다.
        - 처음에는 post가 존재하지 않는 빈 배열로 렌더링 되기 때문에 처음에는 listitem이 없다.
        - 첫 렌더링 사이클이 지나간 후에 effect가 즉시 실행된다.
          - 그 후에 요청이 전송되어 응답이 돌아오고 state가 업데이트되면 컴포넌트가 리렌더링된다.
          - 이 때 비로소 listitem이 존재하게 된다.
        - 초기 렌더링 사이클에는 listitem이 없다.
          - 초기에는 post가 없기 때문이다.
          - post 데이터를 가져오는 데에 몇 밀리초 혹은 몇 초의 시간이 걸리기 때문이다.
          - 이게 문제가 되는 것이다.
      - getAllByRole을 사용하면 screen의 아이템들을 즉시 가져오게 되는데 초기에는 아무것도 없다.
        - 이 문제를 회피할 간단한 방법이 있다.
        - getAllByRole 대신 findAllByRole을 사용하면 된다.
    - findAllByRole
      - findAllByRole 이라던가 get 쿼리 대신 사용하는 find 쿼리들은 promise를 반환한다는 것이다.
      - React testing library는 과정이 성공할 때까지 screen을 여러 차례 재평가할 것이다.
      - 그러므로 findAllByRole은 HTTP 요청이 성공할 때까지 기다린다.
      - findAllByRole에 대한 세 번째 인자도 특정할 수 있다.
        - 두 번째 인자는 exact 등을 설정할 수 있게 해준다.
        - 세 번째 인자는 또 다른 객체로서 timeout 기간을 정할 수 있다.
          - default는 1초이다.
          - 1초 후에도 아이템이 존재하지 않는다면 여전히 실패한다.
        - 가장 중요하게는 렌더링 된 컴포넌트를 즉시 찾는 게 아니라, 일정한 시간이 지난 후에 찾을 수 있는지를 따진다.
      - `const listItemElements = screen.findAllByRole("listitem");`
    - `screen.findAllByRole` 이 부분에서 빨간 물결 줄이 그어지는 이유는, promise를 반환하고 있기에 결과에 대한 작업하기 전에 기다려야 하기 때문이다.
      - 여기서의 결과는 promise이지 배열이 아니기 때문이다.
      - 다행히도 테스트 코드는 비동기일 수 있다.
        - async/await 키워드를 추가할 수 있다.
        - 달리 말하면 테스트는 promise를 반환할 수 있다.
        - 이후에 테스트 러너 jest는 promise가 해결되기를 기다릴 것이다.
          - 테스트가 끝날 때까지 기다린다.
      - async/await 키워드를 추가하면, 배열이므로 정상적으로 수행될 것이다.
    - 모든 테스트를 다시 실행해보면 모든 테스트에 통과하는 것을 확인할 수 잇다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/bd394bc96d1fb8cc0a53379fe03d7aad74b183d1)

  <br />

  - 모의 작업
    - 정의된 쿼리 덕에 데이터가 리렌더링 되기를 기다릴 수 있게 되었다.
      - 이 방법은 일반적으로 먹힌다.
      - 하지만 지금 이 방법은 최선은 아니다.
      - 이유는 HTTP 요청을 보내고 있기 때문이다.
        - 이 경우에는 API로부터 데이터를 가져오고 있다.
    - 개발 과정에서 흔히 그러하듯이 테스트를 실행할 때 일반적으로는 서버에 HTTP 요청을 전송하지는 않는다.
      - 요청을 전송하지 않는 이유는 첫 번째로, 많은 네트워크 트래픽을 일으켜서 서버가 요청들로 인해 과부하될 것이기 때문이다.
        - 특히 많은 요청에 대한 많은 테스트가 존재한다면 더욱 과부하될 것이다.
      - 두 번째로 데이터를 가져오지는 않지만, 일부 컴포넌트가 서버로 post 요청을 전송한다면 테스트로 인해 DB에 데이터가 삽입될 것이다.
        - 혹은 서버의 내용이 변경될 수도 있다.
        - post와 같은 종류의 요청이 전송되는 컴포넌트와 시나리오도 테스트해야 하기 때문이다.
        - 물론 테스트하면서 위와 같은 일이 생겨서는 안된다.
        - 서버의 내용을 변경시키는 요청을 보내서는 안된다.
    - 테스트를 작성할 때 보통 취하는 방식은 진짜 요청을 전송하지 않거나, 혹은 일종의 테스팅 서버로 요청을 전송하는 것이다.
      - 둘 다 가능한 방식이다.
      - 이 모의 작업에서는 애초에 요청을 전송하지 않는 첫 번째 방식을 사용해볼 것이다.
        - 이유는, 한 가지 중요한 사항이 있기 때문이다.
        - 테스트를 작성할 때는 내가 작성하지 않은 코드를 테스트해서는 안된다.
        - Async.js에서 fetch 함수가 올바로 작동하며 요청을 보내는지를 테스트해서는 안된다.
          - fetch 함수는 내가 작성한 것이 아니다.
            - 브라우저 내장이다.
            - 브라우저 벤더가 fetch 함수를 올바로 작성했다고 믿는 것이다.
          - 그러므로 fetch 함수가 성공적으로 요청을 전송하는지를 테스트해서는 안된다.
            - 대신 전송된 요청의 서로 다른 결과에 따라서 컴포넌트가 올바로 작동하는지 테스트해야 한다.
            - 즉, 응답 데이터를 받았을 때 컴포넌트가 올바로 작동하는지 테스트해야 한다.
            - 또한 에러가 발생했을 때도 제대로 작동하는지 확인해야 한다.
          - 요청 전송에 성공하는지는 테스트하지 않는다.
      - 브라우저에 내장된 fetch 함수를 소위 mock(더미) 함수로 대체해야 한다.
        - 내장 함수를 덮어쓰는 더미 함수를 사용하는 방법이다.
        - 내가 원하는 바를 수행하면서도 진짜 요청을 전송하지 않는 더미 함수를 쓰는 것이다.
        - 테스트 중에 컴포넌트가 실행될 때 내장된 진짜 함수가 아닌, mock 더미 함수가 사용된다.
    - fetch 함수를 더미 함수로 대체하는 방법
      - 이 방법은 흔한 시나리오이다.
        - fetch 뿐만이 아니라 로컬 스토리지에 대한 작업 등에서 흔히 등장하는 문제다.
        - ex) 스토리지에서의 변경을 야기해서는 안 되는 상황
      - 아주 흔한 시나리오이기 때문에 지금 사용하고 있는 테스팅 tool인 jest에도 이와 같은 함수를 흉내내는 내장 지원책이 존재한다.
        - 그래서 활용하기도 쉽다.
    - Async.test.js 파일에서 내장 fetch 함수를 나만의 다른 함수로 덮어쓰기
      - 덮어 쓰기 위해 window 객체로 간다.
        - window 객체에 fetch 메소드를 사용
        - 컴포넌트에서 `fetch()`를 호출하면, window.fetch 메소드를 사용하게 된다.
          - `window.fetch`
        - window 객체를 내가 정의한 새로운 함수로 설정할 수 있다.
          - 여기서 jest를 사용할 수 있다.
      - jest 객체
        - 테스팅 코드 내에서 전역적으로 활용 가능하다.
          - 테스트를 싱행하는 tool인 jest의 지원 덕에 활용이 가능하다.
        - jest 객체는 몇 가지 유틸리티 메소드를 갖는다.
          - 예로, fn 메소드가 있다.
            - fn의 기능은 더미 함수를 만들어준다.
            - 직접 함수를 만드는 것과 비교했을 때의 차이점은 더미 함수에는 활용 가능한 기능이 몇 가지 있다.
        - `window.fetch = jest.fn();`
        - 내장 fetch 함수를 더미 함수로 덮어 쓰게 되었다.
          - 물론 테스팅 코드 내에서만 이루어진다.
      - jest 객체를 통해 만든 더미 함수를 다시 사용해서 특수 메소드를 호출
        - 자동 완성이 지원되지는 않지만, mockResolvedValueOnce를 호출할 수 있다.
          - `window.fetch.mockResolvedValueOnce()`
        - 예시 코드는 fetch 함수가 호출되었을 때 결정되어야 하는 값을 설정할 수 있게 해준다.
          - fetch 함수는 코드에서 사용된 무언가로 결정되어야 한다.
            - fetch 함수가 호출되었을 때 인접한 메소드를 가진 객체로 결정되었다.
            - 현재 Async.js에서 그 결정된 값을 다루고 있다.
              - then 블록에서는 호출된 fetch 함수의 결정된 값을 활용하고 있다.
              - fetch 함수에 의해 반환된 promise 값을 다루고 있음
                - 그리고 해당 값에 대해 json을 호출하고 있다.
              - `.then((response) => response.json())`
        - 설정하려는 결정된 값은 객체로 설정한다.
          - promise에 의해 결정된 객체
            - `window.fetch.mockResolvedValueOnce({})`
          - mockResolvedValueOnce를 호출했을 때, 자동적으로 반환될 것이다.
          - json 속성이 있음을 명시
            - 컴포넌트에서 했듯이, 함수로 호출해도 된다.
          - json은 비동기 함수가 된다.
            - json이 새로운 promise를 반환하는데, 내장 fetch 함수에서도 마찬가지이기 때문이다.
            - 그러므로 더미 fetch 함수에서도 마찬가지로 promise를 반환해야 한다.
          - 반환해야 하는 값 중에 무엇을 시뮬레이션할지는 내가 정하면 된다.
            - 이 모의 작업의 경우 json이 호출됐을 때 배열을 반환한다.
            - Async.js에서의 fetch 함수에 있는 data는 해당 컴포넌트의 API 엔드포인트에 대한 배열이기 때문이다.
              - 모든 post는 id와 title을 가지게 된다.
          - 성공 케이스를 시뮬레이션하기 위해 최소 하나의 post를 갖는 배열을 반환
            - ex) id는 p1이며, title은 First post
            - `json: async () => [{ id: "p1", title: "First post" }],`
        ```
        window.fetch = jest.fn();
        window.fetch.mockResolvedValueOnce({
          json: async () => [{ id: "p1", title: "First post" }],
        });
        ```
        - 이 코드로 인해 내장 fetch 함수를 더미 fetch 함수로 덮어쓰게 된다.
          - 더미 함수에서 jest의 기능을 활용해서, promise가 반환해야 하는 실제 값을 설정했다.
    - 저장하고 테스트를 재실행하면 여전히 통과되는 것을 확인할 수 있다.
      - 하지만 이번에는 성공 케이스를 시뮬레이션했다.
      - 성공 케이스를 시뮬레이션하고 있으며, API에 요청을 전송하고 있지 않다.
        - 따라서 해당 API에 불필요한 요청을 보내 과부하가 걸리는 일도 생기기 않게 되었다.
        - 네트워크 트래픽 양도 감소하게 됐으며, 서버가 다운됐을 때 발생 가능한 잠재적 문제도 피할 수 있다.
          - 서버가 다운된 경우, 테스트가 실패할 것이다.
      - fetch 함수의 다양한 결과를 제어해서 테스트의 다양한 시나리오들을 시험해볼 수 있다.
        - 더미를 쓰는 것도 나쁘지 않다는 것을 말해주기 위해서 모의 작업을 진행한 것
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/0561132c611404d2872ce9479d26401b066e7fca)

  <br />

  - 요약 및 추가 자료
    - 이번 섹션에서 테스트와 React 앱 테스트에 관해 입문 단계만 배웠다.
    - 테스트라는 주제는 별도의 강의를 찍는 것도 가능한 주제라고 한다.
      - 하지만 이 강의는 그것이 목적이 아니고, React 강의이기 때문에 React 테스트를 입문 단계까지만 알려준 것이라고 함
      - 강의 커리큘럼에 깊게 배우는 테스트 강의를 집어넣을 수 없다고 한다.
    - 테스트에 대해 더 알고 싶다면 참고할 수 있는 튜토리얼이나 강의들이 존재하지만, 살펴볼 가치가 있는 것은 Jest 공식 문서이다.
      - 테스트를 실행하고, 결과를 가정해보는 데에 사용하는 tool인 Jest
    - React Testing Library 문서도 참고할 만하다.
    - [Jest](https://jestjs.io/)
      - 문서에 나오는 셋업 단계를 따를 필요는 없다.
        - React 프로젝트 내에 이미 셋업이 있기 때문이다.
      - Jest는 React만을 위한 tool이 아니다.
        - 범용 JS 테스팅 tool이다.
      - 서로 다른 방식으로 기대를 표현하는 다양한 매체에 대해 알아볼 수 있으며, 비동기 코드 테스트에 대해 알아볼 수도 있다.
        - promise가 완료되기를 기다리는 법도 나오고, 이번 섹션에서 활용했던 mock 함수에 대해서도 나온다.
        - mock 함수를 활용해 정규 함수를 흉내내는 다양한 방식을 알아볼 수 있다.
      - 앞에서 해보았던 promise를 흉내내는 것도 설명되어 있고, 전반적으로 제시된 가이드를 통해서 jest가 제공하는 다양한 예시와 기능을 살펴볼 수 있다.
    - [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
      - 이 문서를 통해서도 많은 걸 배울 수 있다.
      - 완비된 예시가 제시되어 있기 때문에 확인해보면 좋다.
      - 활용 가능한 API도 모두 소개되어 있고, Core API에서 서로 다른 쿼리 메소드를 확인할 수도 있다.
        - getBy, findBy, queryBy의 차이점에 관해서도 설명하고 있다.
      - 비동기 코드도 설명되어 있고, 이벤트 발생시키기에 대해서도 나와 있다.
      - React App Testing에 대해 깊이 알고 싶다면 자세히 살펴볼 가치가 있는 문서이다.
      - 강의에서는 **ecosystem** 부분을 강조하고 싶다고 한다.
        - 설치 가능한 확장 프로그램에 관해 설명하고 있는 부분이다.
        - 몇몇 확장 프로그램은 이미 React 앱의 default 프로젝트 셋업의 일부분이 됐다.
        - 예로, user-event 확장
        - 목록에는 없는 확장 하나를 강조하고 싶다고 한다.
          - react hooks testing library
    - [React Hooks Testing Library](https://github.com/testing-library/react-hooks-testing-library)
      - React Hook, 특히 커스텀 Hook 테스트를 간단하게 만들어준다고 한다.
      - 테스트하고 싶은 커스텀 Hook이 있을 때, 해당 확장을 사용하는 법을 여기서 설명하고 있다.
        - 커스텀 Hook도 테스트하는 것이 일반적이다.
        - 가능하면 전체 코드 베이스를 테스트하는 것이 맞기 때문이다.
    - 문서들을 통해서 심화 학습을 진행할 수 있다.
      - 이번 섹션에서는 테스트를 간단하게 입문, 소개만 해줬기 때문에 이를 통해 테스트의 전반적 작동 방식에 대해 이해하는 것이 중요하다.

# 오늘 느낀 점

- 테스트에 대해 마무리를 지었는데, 역시 비동기나 모의 작업에서 HTTP 요청에 관한 내용을 다룰 때, 쉽지 않다고 느껴졌다. 지금도 충분히 간단하고 쉬운 코드이지만 비동기에 대해서는 async/await 작업을 해줘야 하고, HTTP 요청에 대해서는 실제 요청이 전송되지 않고 mock로 작업을 해야 하는데, 만약 간단하지 않고 좀 더 복잡하고 많은 코드가 있는 프로젝트에서는 테스트 코드 또한 복잡하고 많은 양을 테스트 해야 할 것이다. 왜 강의에서 테스트 관련 내용으로 하나의 커리큘럼을 따로 짤 수 있다고 한 것인지 확실하게 이해가 되었다. 지금 배운 내용은 아주 기초적이고 입문 단계의 내용이지만, 이제 혼자서 프로젝트를 진행하게 되면 그 때 테스트를 추가해서 지금 배웠던 내용과 공식 문서 그리고 구글링을 통해 테스팅에 대한 내용을 추가하고, 부족한 부분은 공부하고 실습해보면서 내용을 추가해야 할 것 같다는 생각이 든다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
