# 오늘 한 일

### React 공부

- React App 테스트 (유닛 테스트)

  - 모듈 소개
    - 이번 섹션은 React 앱을 테스트하는 것에 관한 것으로, 테스트한다는 것이 혼란스럽게 들릴 수 있다.
      - 구축한 것은 항상 테스트 하지 않았나? 하고 말할 수 있다.
      - 하지만 이번 섹션은 자동화된 테스팅에 관한 것이다.
    - 내가 작성한 코드를 테스트하도록 하는 코드를 작성해보는 연습
      - 현대판 애플리케이션의 제작에 있어서 중요한 부분이다.
    - 이번 섹션을 통해서 자동화된 테스팅 입문
      - React 앱과 React 컴포넌트에 초점을 맞춰서 진행
    - 이번 섹션에서는 정확히 테스팅이란 무엇인지 그리고 왜 하는 것이고, 어떻게 하는 것인지 알아볼 예정이다.
      - 유닛 테스트라 불리는 중요한 개념에 대해서 무엇인지 이해하고, React 컴포넌트를 테스팅 하는 방법에 대한 예시들 및 React 앱의 기본 구성 요소들에 대해 살펴볼 것이다.

  <br />

  - 무엇을 & 왜
    - 코드를 작성하기에 앞서서 테스팅이란 것이 무엇일까?
      - 이미 강의 과정에서 많은 테스트들을 해봤는데, 이것들은 수동적인 테스팅이었다.
        - Manual Testing
        - 개발자로서 코드를 작성해서 특정 속성을 구현하거나 특정 문제를 해결하고 그런 다음 애플리케이션을 브라우저에서 먼저 보고 거기서 시험적으로 테스트한 것을 의미한다.
        - 개발자로서 항상 하는 것을 말한다.
        - 이것이 강의 과정에서 항상 해오던 것이다.
        - 아주 중요한데, 내가 보는 것이 사용자가 보게 될 내용이기 때문에 잘 다듬어서 작동하도록 해야 한다.
      - 수동적인 앱 테스팅은 오류 발생이 쉽다.
        - 최소한 이것이 내가 수행하는 유일한 유형의 테스트인 경우, 수동으로는 가능한 모든 조합과 시나리오를 테스트하기 어렵기 때문이다.
        - 만약 아주 복잡한 React 앱을 가지고 있어서 여러 페이지와 속성을 가지고 여기에 새로운 속성을 추가한다거나 기존의 속성에 대한 측면을 변경한다면 이 변경에 대한 테스트 또는 새로운 속성에 대한 테스트는 하겠지만 애플리케이션의 다른 모든 부분을 항상 테스트 하지는 않을 것이다.
        - 어떤 것을 변경한 것이 앱에서 다른 속성을 손상시킬 수 있다.
          - 모든 것을 테스팅 하는 것이 아니기 때문에 손상을 유발한 변경사항, 버그를 그냥 지나칠 수 있다.
          - 나중에 잡을 수도 있겠지만 잡게 된다는 보장도 없다.
          - 너무 늦게 잡아서 추가적인 작업을 해야할 수도 있다.
        - 이러한 이유 때문에 자동화된 테스팅을 하는 것이다.
      - 자동화 테스팅
        - Automated Testing
        - 이것이 수동 테스트를 대체하는 것은 아니다.
          - 수동 테스트는 언제나 매우 중요하다.
        - 수동 테스트에 자동화 테스팅를 추가하는 것이다.
        - 자동화된 테스팅은 추가적인 코드를 작성해서 애플리케이션의 메인 코드가 실행되면서 다른 코드를 테스트한다.
          - 이상하게 들릴 수 있지만, 이것이 표준 절차이다.
          - 최신 개발 분야에서 해야 하는 표준이다.
        - 자동화 테스팅의 장점은 전체 애플리케이션을 자동으로 테스트하는 코드를 작성하기 때문에, 어떤 것을 바꾸더라도 항상 모든 것을 테스트할 수 있다는 것이다.
          - 자동적으로 전체 애플리케이션을 테스트 한다.
          - 많은 시간이 걸리지도 않는다.
          - 테스트를 작성하고 이것은 앱의 서로 다른 개념 구성요소에 대한 테스트를 한다.
          - 코드를 변경할 때마다, 모든 개별 구성요소들을 다 같이 테스트한다.
          - 가끔씩 앱의 일부만을 테스트 하는 것이 아닌, 전체를 테스트
        - 매우 기술적이지만 모든 것을 상시 테스트할 수 있다.
        - 수동 테스팅과 함께하면 오류들을 훨씬 더 일찍 잡을 수 있고, 더 나은 코드를 작성해서 애플리케이션에 제공할 수 있다.

  <br />

  - 다양한 종류의 테스트 이해하기
    - 자동화된 테스팅을 이야기함에 있어서 살펴볼 수 있는 다른 종류의 테스팅이 있다는 것을 이해하는 것이 중요하다.
      - 단위 테스트, 통합 테스트, 전 구간 테스트
      - 이렇게 세 가지가 내가 작성할 수 있는 주요 테스트 유형이다.
    - 단위 테스트
      - 애플리케이션의 가장 작은 단위에 대한 테스트를 작성하는 것이다.
        - 함수들, 애플리케이션에서 사용하는 개별 함수들을 테스팅 하는 것이다.
      - React 앱의 경우엔 애플리케이션의 다른 컴포넌트와 독립적으로 일부 컴포넌트를 테스팅 하는 것이다.
      - 프로젝트에는 일반적으로 많은 단위 테스트가 포함된다.
        - 애플리케이션을 구성하는 모든 단위, 모든 함수 및 컴포넌트를 테스트 하기를 원하기 때문이다.
      - 단위 테스트는 가장 일반적이고, 중요한 종류의 테스트이다.
      - 아이디어는 단순히 모든 개별 단위를 자체적으로 테스트 하면 전체 애플리케이션도 작동한다는 것이다.
        - 하지만 전체 애플리케이션도 실제로 작동 하는지 확인하기 위해서 모든 단위들을 모아서 통합 테스트를 해볼 수 있다.
    - 통합 테스트
      - 여러 개의 구성 요소의 조합을 테스트한다.
        - 예로, 여러 구성 요소가 함께 작동 되는지를 확인할 수 있다.
      - 프로젝트에는 일반적으로 몇 가지 통합 테스트가 포함된다.
        - 하지만 단위 테스트만큼 많지는 않다.
      - 이번 섹션을 통해서 보면 알겠지만, React 앱을 테스팅 할 때 단위 테스트와 통합 테스트를 구별하는 것이 항상 쉬운 것은 아니다.
        - 흔히 컴포넌트를 테스트할 때 한 컴포넌트가 다른 컴포넌트들도 사용하기 때문이다.
        - 이번 섹션을 통해서 이것이 작동하는 것을 볼 것이다.
      - 일반적으로 통합 테스트도 매우 중요하다.
        - 하지만 단위 테스트 보다는 통합 테스트의 수가 적다.
    - 전 구간 테스트
      - 애플리케이션의 전체 워크플로우를 테스트하는 것이라 할 수 있다.
        - 전체 시나리오를 테스트
          - ex) 사용자가 로그인하고 특정 페이지로 이동하는 것과 같은 시나리오
        - 실제로 사람이 나의 웹 사이트에서 수행하는 작업을 재현하는 것을 목표로 한다.
        - 수동 테스트로도 하는 것을 단지 자동화하는 것이다.
      - 전 구간 테스트가 가장 중요한 테스트처럼 들릴지 모르지만, 확실히 중요하긴 하다.
        - 그렇기 때문에 전 구간 테스트를 실제로 작성하기도 한다.
        - 하지만 단위 테스트와 통합 테스트만큼 많지는 않다.
          - 단위 및 통합 테스트가 잘 작동한다면 전체적으로 앱이 잘 작동한다고 꽤 확신할 수 있기 때문이다.
          - 단위 및 통합 테스트가 단순히 더 테스트 하기도 쉽다.
          - 단위 및 통합 테스트가 보통 더 빠르고 집중적이다.
            - 그리고 가능한 모든 시나리오를 테스트하는 것이 훨씬 쉽다.
      - 전 구간 테스트도 중요하다.
        - 그러나 기본적으로 수동으로 수행하는 작업이기도 하므로, 전 구간 테스트 수가 더 적다.
    - 이번 섹션은 테스팅에 대한 입문하기 때문에 가장 중요한 유형의 테스트에 초점을 맞출 것이다.
      - 단위 테스트와 어느 정도 통합 테스트를 볼 것이다.
      - 모듈의 마지막에서는 원한다면 React 테스팅에 대해 더 자세히 알아볼 수 있도록, 내가 확인해 볼 수 있는 몇 가지 다른 리소스들도 짚어 줄 예정이다.

  <br />

  - 테스트 대상 및 테스트 방법
    - 테스트 작성을 시작할 때, 비교적 일찍 대답해야 하는 매우 중요한 두 가지 질문이 있다.
      - 무엇을 테스트할 지, 어떻게 테스트할 지
      - 어떻게 기술적으로 테스트할 지를 말하는 것이 아니다.
      - 코드가 다른 도구에 의해 실행되도록 하는 방법과 같다.
      - 여기서 말하는 것은 테스팅 코드에 어떤 종류의 코드를 넣어야 할 지를 말한다.
    - 무엇을 테스트할지
      - 단위 테스트에서 언급 했듯이 서로 다른 기본 구성 요소를 테스트 해보아야 한다.
        - 앱을 구성하는 구성 요소들을 말한다.
        - 정말 작은 구성 요소들을 테스트해야 한다.
        - 작고, 집중된 테스트로 각각 하나의 주요 사항만 테스트하는 것이다.
        - 여러 개의 집중된 테스트를 가짐으로써, 만약 실패한다면 실패한 분명한 이유를 알 수 있다.
          - 몇 가지 큰 테스트를 가지는 것보다는 이런 테스트는 여러 가지 이유로 실패할 수 있다.
    - 어떻게 테스트할지
      - 발생할 수 있는 성공 및 오류 사례를 테스트한다.
        - 사용자가 나의 앱과 상호작용 했을 때를 말한다.
      - 드물지만 가능한 시나리오와 결과도 테스트 해야 한다.
        - 코드를 작성하기 시작하면 더 명확해질 것이다.

  <br />

  - 기술 설정 및 관련 도구 이해하기
    - 테스트는 내가 작성한 코드를 테스트하는 코드라는 것을 알았는데, 그렇다면 이 코드를 어디에 작성하고 테스팅 코드를 어떻게 실행할까 ?
      - 이것을 위해서는 추가적인 도구와 설정이 필요하다.
      - 구체적으로 말하면 테스팅 코드를 실행하고 결과를 확인하기 위한 도구가 필요하다.
      - 몇 가지 결과를 성공으로 볼 수 있는지 또는 결과로 미루어 봤을 때 테스트가 실패했는지 여부를 판단하기 위한 도구가 필요하다.
        - 그리고 React 앱에서는 React 앱과 컴포넌트들을 렌더링하는 것을 시뮬레이팅 하는 방법이 필요하다.
        - 자동화된 테스트와 이것들과 상호 작용하도록 필요하다.
        - 브라우저를 시뮬레이팅 하는 것이라고 볼 수 있다.
    - jest
      - 테스팅 코드를 실행하고 결과를 확인하는 첫 번째 부분에 대해서는 보통 jest를 사용한다.
      - 테스팅 작업을 위한 유일한 도구는 아니지만 매우 인기 있다.
        - 특히 React에서 인기가 많다고 함
      - 사용하기도 쉽다.
    - React Testing Library
      - React 앱에서 컴포넌트를 렌더링하고 시뮬레이팅 하는 부분에 대해서는 요즘에는 React 테스팅 라이브러리를 주로 사용한다.
    - 두 가지 도구는 모두 이미 설치 및 설정이 되어 있다.
      - create-react-app으로 생성한 프로젝트에서 작업할 경우에 이미 존재
      - package.json
        - testing-library 패키지를 볼 수 있다.
          - 프로젝트의 일부이다.
          - 이것들을 따로 설치한 것이 아니다.
          - 새로 생성한 React 프로젝트의 일부이다.
          - creat-react-app으로 자동으로 생성된 것이다.
          - 바로 사용할 수 있다.
        - testing-library에서 jest는 보이지 않는다.
          - jest-dom 테스팅 라이브러리 하위 패키지만 보인다.
          - jest-dom 또한 프로젝트의 일부이다.
          - 다른 의존성 중 하나에 대한 의존성과 같다.
    - 첨부란의 프로젝트와 같이 새로운 프로젝트에서도 테스트를 실행할 수 있는 설정은 이미 다 되어 있다.

  <br />

  - 첫 번째 테스트 실행하기
    - 데모 프로젝트는 일반 React 프로젝트로 컴포넌트 코드는 많이 다르지 않고, index.js 파일만 약간 정리되어 있는 상태이다.
      - 그리고 App.test.js 파일은 삭제하지 않았다.
      - setupTests.js 파일 또한 마찬가지로 삭제하지 않았다.
      - App.test.js, setupTests.js
        - 지금까지 과정에서 사용한 적이 없는 파일이다.
        - 파일들이 필요하기 때문에 삭제하지 않은 것이다.
    - setupTests.js
      - 이름에서 알 수 있듯이 단지 설정하는 작업을 해준다.
      - 설정하는 작업만 하기 때문에 이 파일 안에는 아무것도 하지 않아도 된다.
    - App.test.js
      - 이 파일은 꽤 흥미로운데, 이 파일이 테스팅 코드를 포함하는 파일이다.
      - 바로 꺼내서 사용할 수 있다.
      - 테스트 관련 섹션인 이 섹션의 나중에 가서 나만의 테스팅 코드를 처음부터 작성할 예정이다.
      - 앱 컴포넌트를 테스트하기 위해 있는 파일인데, 테스팅 파일의 이름은 컴포넌트 파일과 같이 짓는 것이 관례이다.
        - 단지, 파일명에 test만 붙인다.
          - `App.js` - `App.test.js`
        - 정확히 말하면 `.test.js`를 확장자로 붙이는 것이다.
      - test 함수가 있는데, 두 개의 인자를 갖는다.
        - 첫 번째 인자는 테스트에 대한 설명이다.
          - 이건 내 마음대로 하면 된다.
          - 테스트 출력에서 이 테스트를 식별하는데 도움이 된다.
          - 하나 이상의 테스트가 있는 앱의 경우에 더 유용하다.
          - `test('renders learn react link', ...)`
        - 두 번째 인자는 함수이다.
          - 익명 함수로 이게 핵심
          - 실제 테스트와 코드를 포함하고 있다.
          - 이 코드가 테스트를 실행할 때 실행될 코드이다.
          - 이 안에는 몇 가지, 아직은 완전히 이해하지 못하는 것들을 해준다.
            - 곧 이해하게 될 것이다.
          ```
          () => {
            render(<App />);
            const linkElement = screen.getByText(/learn react/i);
            expect(linkElement).toBeInTheDocument();
          }
          ```
      - 마지막에는 테스팅 라이브러리에서 불러온 render 함수의 도움을 받아서 App 컴포넌트를 렌더링한다.
        - `render(<App />);`
      - 일부 요소를 가상의 화면이라 할 수 있는 것에 뿌려지도록 한다.
        - 시뮬레이팅 된 브라우저를 말한다. 거기서 App이 렌더링 된다.
        - 시뮬레이팅 된 브라우저에 몇 가지 요소를 뿌린다.
        - 요소를 식별할 때 그 안에서 렌더링되는 텍스트로 식별한다.
          - ex) `learn react`라는 텍스트를 찾는다.
          - 대소문자 구분 없다.
          - `/learn react/` 이건 정규 표현이다.
        - `const linkElement = screen.getByText(/learn react/i);`
      - 요소가 실제로 문서에 있는지를 확인한다.
        - 문서에 존재하는지를 확인한다.
        - `expect(linkElement).toBeInTheDocument();`
          - `toBeInTheDocument` 테스트는 요소를 찾지 못하는 경우 실패이고, 찾을 경우 성공이다.
    - App.js
      - Learn React라는 텍스트가 a 태그 안에 실제로 있다.
      - 대소문자 구분 없는 `/learn react/`라는 텍스트 요소를 찾을 때, 대소문자는 상관 없기 때문에 이 테스트는 성공하게 된다.
    - 테스트는 어떻게 실행될까 ?
      - 이를 위해서 스크립트가 존재한다.
        - 개발 서버 실행을 위해 스크립트가 있는 것처럼 테스트 스크립트가 존재한다.
        - 개발 서버를 실행시켜서 앱을 미리 보고 앱과 상호작용할 수 있도록 하는 것처럼 자동 테스트를 실행해서 이것이 작동 하는지 확인한다.
      - package.json에 테스트 스크립트가 있다.
        - `"test": "react-scripts test",`
      - 테스트 스크립트를 터미널 창에서 실행할 수 있다.
        - `npm test`
          - 이 명령어를 실행하면 된다.
          - npm start가 개발 서버를 시작했던 것처럼 npm test는 자동화된 테스트를 실행한다.
      - npm test를 실행 시 테스팅을 시작하는데, 바로 테스트를 실행하는 것은 아니다.
        - a 키를 눌러줘야 한다.
          - `Press a to run all tests.`
          - 찾는 모든 테스트를 실행하도록 a 키를 눌러줘야 함
        - a키를 누를 시 알아서 이름이 `.test.js`로 끝나는 파일을 찾아서 그 안에 테스트 함수로 정의 되어 있는 모든 테스트를 실행한다.
        - 테스트가 실행되고 나면 테스트 결과를 받게 된다.
          - 총 하나의 테스트를 실행한 것을 볼 수 있고, 하나의 테스트를 통과한 것도 볼 수 있다.
            - `Test Suites: 1 passed, 1 total`
            - `Tests:       1 passed, 1 total`
          - 모든 테스트가 무엇인지도 볼 수 있다.
            - 옆에 초록색 체크 표시가 되어 있다.
          - 테스트에 대한 설명 텍스트도 다시 볼 수 있다.
            - `renders learn react link`
            - 이것이 어떤 테스트를 성공했고 실패했는지 식별할 수 있도록 도와준다.
    - 테스트가 완료되고, `.js` 파일의 내용을 변경한 후 저장했을 경우
      - App.js 파일의 `Learn React` 텍스트를 지우고 `Learn more`로 바꿔서 저장하면 테스트가 자동으로 재실행된다.
        - 이유는 기본 설정으로 파일을 주시하고 변경 사항을 저장할 때마다, 테스트를 재실행하기 때문이다.
      - 재실행된 테스트에서 테스트가 실패했다고 뜨는 것을 확인할 수 있다.
        - `Test Suites: 1 failed, 1 total`
        - `Tests:       1 failed, 1 total`
        - 결과 내용에서 좀 위로 올라가서 확인해보면 더 많은 정보를 볼 수 있다.
          - 테스트가 실패했다는 것을 빨간 X표시로 확인할 수 있다.
          - 왜 실패했는지 설명도 되어있다.
            - ex) `/learn react/`로 되어 잇는 텍스트 요소를 찾을 수 없음
            - Unable to find an element with the text: /learn react/i.
          - 그 다음 렌더링된 실제 내용의 결과물을 볼 수 있다.
            - 해당 텍스트를 찾기 위해서 보았던 부분과 실패한 부분을 확인할 수 있다.
            - 이 내용은 App.js 파일의 내용을 보여준다.
          - 테스팅 코드를 볼 수 있다.
            - 실패한 줄을 볼 수 있는데, 이 경우엔 `.getByText()` 부분이 된다.
              - `const linkElement = screen.getByText(/learn react/i);`
              - 이 부분이 실패한 것
      - 개발자로서 테스트를 다시 조정하거나 아니면 원래대로 텍스트를 되돌려서 테스트가 다시 통과하도록 할 수 있다.
      - 현재 이 예시는 약간 멍청한 예시로, 단지 기본 예시일 뿐이다.
        - 하지만 이것이 테스트 이면의 개념이고 테스트가 작동하는 방식이다.
    - 테스팅 모드는 개발 서버 종료와 마찬가지로 Ctrl + C 를 눌러서 빠져나갈 수 있다.
      - 이렇게 빠져나오면 더 이상 파일을 주시하지 않게 된다.
      - 다시 테스트하려면 npm test로 진행하면 된다.
    - 여기까지 테스트 기본 내용으로 이제 이 뒤의 내용은 좀 더 깊게 들어가는 내용으로 진행된다.

  <br />

  - 첫 번째 테스트 작성하기
    - 좀 더 깊게 들어가기 위해 새 컴포넌트 생성
      - 복잡하지 않은 가짜 컴포넌트 Greeting.js 파일 생성
      - Greeting 컴포넌트에서 기본적인 구성 추가
        - 함수 생성, 내보내기
        - div, h2, p로 함수 구성
        - 정적인 아웃풋을 가진 가짜 컴포넌트로 구성
          - state, props도 없다.
    - App.js 에서 Greeting.js 사용
      - Greeting을 import하고, header나 다른 것들을 삭제하고, Greeting 컴포넌트를 렌더링
    - App.test.js 에서 구성
      - 사실 App.test.js에서의 테스트가 지금은 실패할 거란 걸 암시하는데, "/learn react/" 텍스트로는 어떠한 element도 찾지 못할 것이기 때문이다.
        - 하지만 이건 시작 코드에 불과하므로 괜찮다.
      - 테스트 코드를 코멘트 아웃
        - App.test.js에서의 테스트가 더 이상 필요하지 않기 때문이다.
        - 대신 추가한 컴포넌트인 Greeting 컴포넌트, 즉 사용자 지정 컴포넌트의 첫 번째 테스트를 직접 작성해보는 연습
      - App.test.js에서 테스트를 작성해서 Greeting 컴포넌트를 렌더링 하든가 아니면 App 컴포넌트를 렌더링할 수 있지만, 전통적인 방식은 테스트를 내가 테스트하고자 하는 것에 가급적 가깝게 작성하는 것이다.
        - 만약 Greeting 컴포넌트를 테스트하고 싶다면, 따로 Greeting.test.js 파일을 만들어서 그 안에다가 테스트를 작성한다.
    - Greeting.test.js
      - 여기에서 글로벌하게 사용할 수 있는 테스트 함수를 사용해서 테스트를 작성해준다.
        - 불러올 필요 없이 사용이 가능하다.
      - 테스트를 서술해주면 된다.
        - 여기 들어가는 텍스트는 내가 정하면 되지만, 대개는 테스트가 하는 일을 간단하게 작성하고 싶어한다.
      - Greeting.js에서 작성한 "Hello World!"가 잘 나오는지 테스트
        - App.test.js에서 테스트했던 것과 비슷하며 나중에는 조금 더 복잡해질 것이다.
        - 첫 번째 인자
          - `test("renders Hello World as a text")`로 작성
        - 두 번째 인자
          - 테스트를 작성할 때 일반적으로 세 가지 과정을 거친다.
          - 세 가지 A를 사용해 테스트를 작성한다.
            - 첫 번째 A는 "준비"(Arrange)를 의미한다.
              - 테스트를 설정하고자 하는 걸 한다.
              - ex) 테스트하고자 하는 컴포넌트를 렌더링하길 원한다.
              - 요구된다면 추가적인 설정도 할 수 있다.
            - 두 번째는 "실행"(Act)이다.
              - 실제로 테스트하고자 하는 걸 한다.
              - ex) 버튼 클릭을 시뮬레이션 해보고 싶다면 두 번째 단계로 테스트를 실행한다.
                - 지금 여기서 할 건 아니지만, 나중에 테스트에서 자주 하게 될 것이다.
                - 나중에 이 섹션에서도 해볼 것이다.
            - 마지막 단계이지만 중요한 세 번째는 결과를 "단언"(Assert)하는 것이다.
              - ex) 브라우저상에서 보이는 output을 검토한다. 그 다음에 나의 예상과 같은지 본다.
          - 테스트로 세 가지 A를 풀어보기
            - 준비
              - Greeting 컴포넌트를 렌더링
              - 그러기 위해 단순히 App.test.js로써 테스트하고자 하는 컴포넌트를 불러온다.
              - 형제 파일인 Greeting.js 파일에서 Greeting을 불러온다.
                - `import Greeting from "./Greeting"`
              - testing-libraries/react에서 불러와야 하는 render를 호출할 수 있다.
                - `import { render } from "@testing-library/react"`
              - 이렇게 하고 컴포넌트를 렌더링
                - 더 정확히 말하면 JSX 코드를 전달하는 것이다.
                - 컴포넌트 element를 생성하는 작업
                - `render(<Greeting />)`
              - 여기까지가 준비 부분이다.
                - 다른 게 더 요구된다면 여기에 더 할 수도 있지만, 현재는 이게 전부
              ```
              test("renders Hello World as a text", () => {
                // 준비 단계 (Arrage)
                render(<Greeting />)
              })
              ```
            - 실행
              - 흥미를 느낄 수 있는 주요 액션을 수행하고 싶지만, 여기에는 기본적으로 아무것도 없다고 봐야 한다.
              ```
              test("renders Hello World as a text", () => {
                // 실행 단계 (Act)
                // 현재는 아무 것도 없다.
              });
              ```
            - 단언
              - 단언을 하기 위해 컴포넌트 콘텐트가 렌더링 됐는지, 말하자면 가상 DOM을 조사하는 작업이 필요하다.
              - 그리고 "Hello World"가 텍스트로 렌더링 되는지 테스트하기 위해 해당 텍스트를 element를 선택해서 그러한 element를 찾는다면 테스트가 성공한 것이고 못 찾는다면 테스트가 실패한 것을 알 수 있다.
              - 렌더링 된 가상 DOM 또는 가상 화면에 액세스할 수 있게 해주는 screen을 import
                - `import { render, screen } from "@testing-library/react";`
              - 그 다음 screen을 사용해서 화면에서 element들을 찾을 수 있다.
                - 이를 위해 사용할 수 있는 여러 가지 함수가 있는데, get 함수, find 함수, 그리고 query 함수가 있다.
                - 함수들의 주요 차이점은 함수들이 에러를 냈을 때, promise를 반환하느냐 아니냐의 차이다.
                - ex) get 함수가 에러를 발생시켜서 element를 찾을 수 없다면 query 함수 말고 find 함수가 promise를 반환할 것이다. 결국 화면상에 element가 나타나게 된다.
              - 텍스트로 element를 갖고 screen.getByText를 사용해서 여기에 찾으려는 텍스트를 정의해준다.
                - 일반적인 표현을 사용해도 되는데, 그 이유는 App.test.js에서 사용된 경우이기 때문이다.
                - 쉽게 변할 수 없는 문자열을 사용해도 된다.
                - 일반적인 표현보다는 조금 덜 유연하긴 하지만, 전체 문자열을 사용하고 싶다고 해도 전혀 문제될 게 없다.
                - `screen.getByText("Hello World")`
              - 두 번째 매개변수를 getByText로 전달하고 `exact:` 부분을 true나 false로 설정해야 한다.
                - false로 하면, 예를 들어 감싸는 것은 상관없고 하위 문자열과도 매치될 것이다.
                - 여기서 `exact:` 부분은 필요 없고 기본값이므로 따로 해야 할 게 없다.
                - 설정해야 한다면 아래 예시와 같이 하면 된다.
                  - `screen.getByText("Hello World", { exact: false });`
              - getByText가 element를 반환하도록 해준다.
                - element를 찾지 못하면 에러가 발생하기 때문에 상수로 구성해준다.
                - `const helloWorldElement = screen.getByText("Hello World");`
              - 실제 단언 구성
                - element가 존재하는지 확인할 수 있다.
                - 글로벌하게 사용할 수 있으며, 테스트 결과값을 전달할 수 있는 expect 함수를 가져오는데, expect 함수는 숫자든 문자열이든 뭐든 될 수 있으며 이 경우에는 HTML element, DOM 노드가 된다.
                  - `expect(helloWorldElement);`
                - 그 다음 expect 함수의 결과에 여러 가지 matcher 함수가 있는데, toBeInTheDocument 함수는 여기에 있을 것으로 예상하는(helloWorldElement) HTML element가 문서 안에 있는지 확인하는 함수이다.
                  - 추가로 matcher 함수인 toBeInTheDocument에 .not을 추가해 반대로 확인할 수도 있다.
                    - `expect(helloWorldElement).not.toBeInTheDocument();`
                  - 만약 element가 문서 안에 없기를 바란다면 텍스트로 된 query 함수를 사용하면 된다.
                    - `queryByText`
                    - element가 발견되지 않으면 getByText는 실패하게 된다.
                  - 여기에서는 문서 안에 있는지를 확인하고 싶기 때문에 toBeInTheDocument를 사용해서 확인한다.
                    - `expect(helloWorldElement).toBeInTheDocument();`
              ```
              test("renders Hello World as a text", () => {
                // 단언 단계 (Assert)
                const helloWorldElement = screen.getByText("Hello World");
                expect(helloWorldElement).toBeInTheDocument();
              });
              ```
      - 결과적으로 App.text.js에서 했던 테스트와 기본적으로 같다.
    - npm test를 실행
      - 두 개의 테스트가 보이는 것을 확인할 수 있는데 사실 둘 다 실패했다.
        - App.test.js 실패
          - 이유는 적어도 하나 이상의 테스트가 있어야 하는데 지금은 빈 파일이기 때문이다.
          - 에러를 피하고자 App.test.js를 삭제
      - Greeting.test.js 다시 시도
        - 다시 실행해도 다른 테스트도 실패한다.
          - "Hello World" 텍스트가 있는 element를 못 찾았기 때문이다.
          - 이유는 h2 태그에 "Hello World!"로 느낌표가 있기 때문이다.
        - 박스 밖에서 정확히 매치하는 걸 찾기 때문에 실패한 것인데, 조금의 여유를 주기 위해 `{ exact: false }`를 넣던지, 또는 텍스트에 느낌표를 추가해 정확한 매치를 찾게 할 수 있다.
          - `const helloWorldElement = screen.getByText("Hello World", { exact: false });`
          - `const helloWorldElement = screen.getByText("Hello World!");`
    - 나만의 첫 번째 테스트를 어떻게 작성하느냐에 대한 내용이었는데, 앞에서 본 것과 기본적으로 내용이 같았다.
      - 하지만 일반적으로 테스트를 어떻게 쓰는지 배울 수 있었고, 이 내용을 알고 있으면 이제 더 깊게 배울 수 있다고 한다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/1e984ee7567a56d1f53f7b04eca9907dd5a8a4e5)

  <br />

  - 테스트 suite와 함께 테스트 그룹화하기

    - 첫 번째 사용자 지정 테스트는 작성되었고, 테스트를 몇 개 더 작성하기 전에 `Test Suites`와 `Tests`에 대한 내용
    - 애플리케이션 규모가 커질수록 수십 개 또는 수백, 수천 개의 테스트를 갖게 될 텐데, 이러한 다수의 다른 테스트를 서로 다른 테스트 suite에 넣어서 그룹화하고 정리하곤 한다.
      - 예로, 애플리케이션 내의 하나의 특징 또는 하나의 컴포넌트에 속하는 모든 테스트는 한 테스트 suite 그룹에 들어간다.
      - 그리고 글로벌한 describe 함수를 사용해 테스트 suite를 생성하는데, test 함수처럼 이것 또한 글로벌하게 사용할 수 있는 함수이다.
    - describe 함수

      - 두 개의 매개변수가 온다.
      - 첫 번째 매개변수에는 설명이 온다.
        - 서로 다른 테스트들이 어디에 속할지에 관한 카테고리 설명에 해당한다.
        - ex) `describe("<Greeting />")`
        - ex) `describe("Greeting component")`
        - 확실히 말하면 예시의 "Greeting component"에 속하는 테스트들을 얘기하는 것이다.
      - 두 번째 매개변수는 익명의 함수가 온다.

        - 이 함수에는 자체 테스트 코드를 쓰지 않고, 다른 테스트들을 넣는다.

        ```
        describe("Greeting component", () => {
          test("renders Hello World as a text", () => {
            // 준비 단계 (Arrage)
            render(<Greeting />);

            // 실행 단계 (Act)
            // 현재는 아무 것도 없다.

            // 단언 단계 (Assert)
            const helloWorldElement = screen.getByText("Hello World!");
            expect(helloWorldElement).toBeInTheDocument();
          });
        });
        ```

        - 이렇게 테스트를 이 함수에 추가해준다.

    - 하나의 suite에 하나의 테스트가 온다.
      - suite를 여러 개 가질 수도 있으며, suite마다 테스트도 여러 개 가질 수 있다.
    - 저장하면 설명 텍스트가 아직도 있는 것을 확인할 수 있는데, 테스트 그룹 이름, 테스트 suite 이름 하에 들어가 있으며 하나의 테스트 suite와 하나의 테스트가 있는 것을 확인할 수 있다.
      - 전처럼 분명한 세트 suite가 없다면 자동으로 suite 하나를 갖게 될 테지만, 지금은 명확하게 이름 붙여진 suite가 있다.
      - 이게 괜찮은 방법인 게, 애플리케이션이 점점 커질수록 테스트들을 그룹화하고 싶어질 것이기 때문이다.
    - 자세한 코드 [깃허브](https://github.com/jeongsangtae/react-complete-training-unit-test/commit/488d8fbd936a54540723f1f5507ebf2a7d738e0e)

# 오늘 느낀 점

- 오늘 갑자기 Redux를 대체하는 Context API 강의가 없어져서 Unit Test에 대한 내용을 들었는데, 이제까지 내가 테스트 하던 방식은 수동적인 테스팅 방식이었다. 하지만 강의의 내용은 테스트 코드를 작성하고 자동으로 테스팅을 하는 내용이었는데, 현재까지는 생각보다 어려운 내용은 아니라고 생각이 되었다. 물론 입문 단계의 자동화 테스팅을 연습하는 것이기 때문에 더 깊게 들어가거나 테스팅해야 할 내용이 많아지면 어려울 수도 있지만, 기본적인 테스팅은 어떤 방식으로 작동하는지 좀 알 거 같다는 생각이 든다. 그리고 테스팅에 종류도 여러 가지 있는데 이 테스트들에 대해 제대로 배워서 나중에 프로젝트 구성을 할 때, 자동화 테스팅을 사용할 수 있도록 할 생각이다.

- Redux를 대체하는 React Hook 섹션에 대한 문의를 남겨놓았기 때문에 문의 답변을 좀 기다려봐야 할 것 같고, 만약 강의를 복구해준다면 다시 듣거나, 그냥 Context API를 사용하는 내용이라면 패스하고 자동화 테스트에 대한 내용을 계속 듣을 생각이다.

<br />

# 내일 할 일

- React 공부 및 React 프로젝트 조금씩 진행하기

<br />

# 앞으로 해야 할 일

- React, NextJS 공부

- React 프로젝트 제작 (영화 추천 사이트)

- 거래 명세서 프로젝트 제작 (React, Python, MySQL)

- Python으로 웹 스크래퍼 만들어보기 (조금 뒤로 밀림)

- Python, PHP 공부할 거 찾아보기 (조금 뒤로 밀림)

- Python 셀레니움, 브라우저 드라이버에 대해 한번 찾아보기 (조금 뒤로 밀림)

- Python 데이터 분석도 한번 봐보기 (조금 뒤로 밀림)
