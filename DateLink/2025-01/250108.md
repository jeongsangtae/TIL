# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- Zustand에서 구성한 내용에 대한 설명 및 정리
  - 현재 상태 정리, Zustand와 액션 실행 흐름
    - 로그인 과정에서 실행되는 주요 코드 흐름
      - Login 컴포넌트에서 login 액션 호출
        - 로그인 버튼을 클릭하면 login 액션이 실행
        - login 액션 내부에서 비동기로 verifyUser와 refreshTokenExp를 호출
          - 이로 인해 verifyUser는 login 실행 중간에 호출됨
      - verifyUser 액션이 상태 업데이트
        - 서버로부터 사용자 정보를 받아 Zustand 상태를 업데이트
        - `set()`를 통해 `isLoggedIn`과 `userInfo` 상태가 변경되면, Zustand의 상태를 구독하고 있는 컴포넌트들이 다시 렌더링됨
      - `useAuthStore.getState().verifyUser()`는 언제 실행되는가?
        - 명시적으로 호출될 때 실행됨
        - 로그인 컴포넌트의 렌더링 시점과는 무관하며, 특정 시점에서 명시적으로 코드를 호출해야 함
  - `useAuthStore.getState().verifyUser();`가 필요한 이유
    - 문제
      - SideBar 컴포넌트에서 isLoggedIn과 userInfo를 추가했지만 보이지 않음
    - login 액션을 실행했을 때
      - verifyUser는 login 액션 내부에서 호출됨
      - 비동기 작업이므로, set()을 통해 Zustand 상태가 업데이트되기 전에 SideBar 컴포넌트가 이미 초기 상태로 렌더링됨
        - 초기 상태는 isLoggedIn: false, userInfo: null
      - 이후 Zustand의 상태가 업데이트되더라도 SideBar 컴포넌트의 UI가 즉시 업데이트되지 않을 수 있음
    - 해결
      - `useAuthStore.getState().verifyUser();`를 추가해서 해결
      - 로그인 과정 초기에 명시적으로 호출하면, Zustand 상태가 먼저 업데이트되고 React 컴포넌트가 최신 상태를 반영하도록 강제할 수 있음
      - 이 과정에서 verifyUser를 실행해 상태를 즉시 업데이트한 후 컴포넌트가 렌더링되므로 데이터가 정상적으로 보이게 됨
  - 내가 이해한 내용과 수정할 부분
    - 내가 이해한 내용
      - 로그인 과정에서 `useAuthStore.getState().verifyUser();`가 먼저 실행됨
      - 그다음 Zustand의 login 액션이 실행
      - 이후 SideBar 등 다른 컴포넌트에서 데이터가 정상적으로 보임
    - 이해한 내용에서 수정해야 할 부분
      - 일부 맞지만, `useAuthStore.getState().verifyUser();`가 실행되는 시점은 명시적으로 호출했을 때 실행됨
      - 따라서 자동으로 실행되는 것이 아닌, 코드에서 특정 위치에 `useAuthStore.getState().verifyUser();`를 추가하지 않으면 이 액션은 실행되지 않음
      - login 액션 실행 중간에서 verifyUser가 호출되는 것은 맞지만, 이 호출은 비동기로 진행되므로 상태 업데이트 전에 UI가 렌더링될 가능성이 있음
  - SideBar 컴포넌트에서 데이터가 정상적으로 출력되는 원리
    - `useAuthStore.getState().verifyUser();`를 명시적으로 호출하면 Zustand 상태가 즉시 업데이트됨
    - React는 Zustand 상태를 구독하고 있으므로, 상태 변경을 감지해 컴포넌트를 다시 렌더링함
    - 이후 login 액션에서도 verifyUser를 호출하지만, 이 호출은 이미 상태가 최신으로 업데이트된 이후이므로 추가로 영향을 미치지 않음
  - 결론
    - `useAuthStore.getState().verifyUser();`는 Zustand의 현재 상태에서 verifyUser를 강제로 호출하여 상태를 즉시 업데이트하도록 하는 코드
    - React 컴포넌트가 초기 상태로 렌더링되기 전에 호출해 상태를 업데이트하면, 컴포넌트가 최신 상태를 반영하게 됨
    - `useAuthStore.getState().verifyUser();` 코드는 자동 실행되지 않으며, 명시적으로 호출해야 작동함
    - 로그인 컴포넌트가 렌더링되기 전에 실행되는 것은 아니며, 로그인 버튼 클릭 후 특정 시점에 실행됨

<br />

- `useAuthStore.getState().verifyUser()` 코드 실행 시점 정리
  - 파일이 처음 import될 때 실행
    - JS에서 최상위 레벨의 코드는 모듈이 로드될 때 바로 실행
    - 어떤 컴포넌트에서 useAuthStore를 import만 해도 이 코드가 실행됨
    - 동작은 특정 액션을 실행시키기 전에 애플리케이션 상태를 초기화하거나 사용자 인증 상태를 확인하려는 목적으로 사용
  - 실행 시점과 순서
    - 프로젝트가 실행되고 useAuthStore를 import하는 순간, 자동으로 실행
    - 이 과정에서 `useAuthStore.getState().verifyUser()`가 호출되어 사용자의 인증 상태를 확인
    - 사용자가 로그인 버튼을 누르기 전에, 브라우저가 해당 파일을 로드하는 시점에 실행
  - 로그인 버튼 클릭 시
    - 사용자가 로그인 버튼을 클릭하면 login 액션이 호출
    - login 액션 내부에서는 `await get().verifyUser();` 코드로 verifyUser를 명시적으로 호출
    - 이 때 verifyUser가 다시 실행되어 사용자 정보를 업데이트
  - 순서 정리
    - 앱 초기화
      - useAuthStore가 import되며 `useAuthStore.getState().verifyUser()`가 실행
      - 사용자가 로그인 상태인지 확인 후 isLoggedIn과 userInfo를 설정
    - 사용자가 로그인 버튼 클릭
      - login 액션이 호출
      - login 액션 내부에서 verifyUser를 호출해 다시 인증 상태를 확인하고 필요한 정보를 업데이트
  - 핵심 정리
    - `useAuthStore.getState().verifyUser()`는 자동으로 실행되는 게 아니라, 파일이 import될 때 실행되는 초기화 코드
    - login 액션 내부에서 verifyUser를 명시적으로 호출
    - 두 번 호출되는 이유는 애플리케이션이 초기화될 때 인증 상태를 미리 확인하고, 로그인 후 다시 한 번 인증 상태를 갱신
  - 최종 정리
    - `useAuthStore.getState().verifyUser()`는 웹 애플리케이션이 처음 로드될 때 실행됨
      - 이 코드는 전역 스코프에서 실행되므로, useAuthStore가 포함된 파일이 처음 import될 때 한 번만 실행
      - 즉, 페이지를 처음 열었을 때 인증 상태를 확인하고, 상태를 업데이트하려고 시도
      - 유효한 인증 정보가 없다면 로그인 유무는 false, 사용자 정보는 null
    - 사용자가 로그인 정보를 입력하고 로그인 버튼을 클릭하면 login 액션이 호출
      - login 액션 내부에서 verifyUser가 호출되므로, 사용자가 로그인한 후에 상태가 업데이트됨
    - 두 번 호출됨
      - 첫 번째 호출
        - 애플리케이션 초기화 시, 페이지가 처음 로드될 때 `useAuthStore.getState().verifyUser()`가 실행되어 인증 상태 확인
        - 이 호출에서는 사용자 데이터가 없으면 로그인 유무는 false, 사용자 정보는 null
        - 하지만, 로그인한 정보가 남아서 쿠키에 저장되어 있으면 그대로 인증이 유지되어 로그인 유무는 true, 사용자 정보는 가지고 있는 정보를 전달
      - 두 번째 호출
        - 로그인 이후 login 액션 내부에서 verifyUser가 호출
        - 사용자가 로그인한 후 인증 상태와 사용자 정보를 다시 확인하고 업데이트
    - `useAuthStore.getState().verifyUser()`는 명시적으로 호출될 때만 실행
      - 페이지가 처음 로드될 때 실행됨
      - 애플리케이션 초기화 시 실행되는 이유는 전역 스코프에 해당 코드가 있기 때문임
      - 이후에는 다른 컴포넌트에서 useAuthStore를 import한다고 해서 자동으로 실행되지 않음
        - 명시적으로 호출되거나, login 같은 액션 내부에서 호출될 때만 실행

<br />

- 로그인 흐름과 비동기 작업 그리고 상태 업데이트
  - 사용자가 로그인 버튼을 클릭하면 login 액션이 호출되고, 이 액션은 비동기 작업을 포함함
    - 비동기 작업은 실행되는데 시간이 걸리기 때문에, 렌더링은 초기 상태인 `isLoggedIn: false, userInfo: null` 내용이 먼저 전달됨
    - verifyUser 같은 비동기 작업이 실행되기 전 또는 완료되기 전에, 컴포넌트는 이미 Zustand의 현재 상태를 가져와 렌더링을 시작함
    - 만약 이전에 로그인한 정보가 로컬 스토리지 또는 서버에 남아있다면 isLoggedIn, userInfo를 업데이트하고 이 내용이 전달됨
  - 비동기 작업이 완료되면 상태가 업데이트되고, 다시 렌더링됨
    - 비동기 작업이 끝난 뒤, Zustand의 set 함수가 호출되어 상태가 변경됨
    - Zustand는 상태 변화를 감지하고, 상태를 구독하는 컴포넌트들에게 자동으로 업데이트된 상태를 전달
    - 이로 인해 컴포넌트가 최신 상태로 재렌더링됨
    - 최종적으로 올바른 데이터가 화면에 표시됨
  - 이 과정은 "두 번 전달"이라기보다는, 초기 상태에서 상태 업데이트 후 재렌더링이라는 흐름으로 이해할 수 있음
    - 초기 상태 전달은 비동기 작업의 특성상 불가피함
    - 비동기 작업 완료 후의 상태 업데이트는 최종 데이터를 반영하는 단계
    - 결과적으로 "두 번 전달"이 틀린 것은 아니지만, 기술적으로는 두 번 다른 상태를 전달하는 것이 아닌, 상태가 한 번 변경되었기 때문에 재렌더링된다는 의미
    - "두 번 전달"이 틀린 말이 아니며, Zustand의 동작을 "두 번 전달"로 이해해도 전혀 문제 없음
    - 초기에 상태를 한 번 전달하고 상태 업데이트 후 다시 전달하기 때문에 두 번 전달도 맞는 말임

# 오늘 느낀 점

- 구성한 코드에 대해 이해가 안가는 부분이 있어서 관련 내용을 찾아보고, 추가로 ChatGPT에게 질문도 해서 이제는 코드가 어떤식으로 동작하는지 이해가 좀 되는 것 같다. 처음에 전역 초기화하는 코드가 대체 언제, 어떤 트리거로 실행이 되는지 이해를 하지 못했는데, 내용을 좀 풀어서 설명을 들으니 이제는 완벽하게 이해가 되었다고 생각이 된다. 처음에 페이지에 접속하면 구성한 Zustand 내용이 import될 때 한 번 실행되고, 그 다음 로그인하면 그 때 다시 실행되면서 상태가 업데이트되어 재렌더링되는 방식으로 작동하는데, 사실 어려운 내용이 아니었는데 설명이 뭔가 너무 복잡하게 되어 있어 있고 계속 명시적으로 호출될 때만 실행된다고 해서 언제 명시적으로 호출되는 지 그 부분이 궁금했는데 이제 깔끔하게 해결이 된 것 같다.

- 로그인 유지는 되는 것을 확인했기 때문에 토큰 만료 시간 관련 useEffect를 구성해서, 토큰이 만료되면 로그아웃이 되는데 그 내용이 새로고침했을 때 적용되는 것이 아닌, 실시간으로 적용이 되도록 구성을 해 줘야 할 것 같다. 아니면 반대로 한 번 로그인하면 로그아웃을 따로 하지 않는 이상 계속 토큰을 갱신하는 방식도 생각을 하고 있는데 현재 디스코드가 이 같은 방식으로 세션 토큰을 갱신해서 사용자가 로그아웃하지 않는 이상 계속 로그인 상태를 유지하기 때문에 이번에 구성하는 프로젝트는 별도의 로그아웃을 하지 않는 이상 로그인을 유지하는 것은 어떨지 좀 생각을 해 봐야 한다. 현재 구성한 내용에서 리프레쉬 토큰 만료 시간을 따로 없애고, 액세스 토큰만 주기적으로 갱신되도록 변경하면 해결이 될 것 같긴한데, 아직 생각만 해 본 상태고 확실하진 않기 때문에 어떤 방식으로 진행할 지 조금 생각을 해 본 후에 결정하고, 그 다음 코드 구성을 해 봐야 할 것 같다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
