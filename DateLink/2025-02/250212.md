# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- 데이터 정규화 관련 내용 정리
  - 정규화 관련 내용을 정리하는 이유
    - 닉네임 정보를 편의성 때문에 여러 컬렉션에서 중복 저장하려는데, 이 경우 데이터 정규화 원칙에 어긋나므로 관련 내용을 정리해 데이터 정규화
  - 데이터 정규화와 성능 관계
    - 데이터 정규화
      - 데이터를 중복 없이 테이블 또는 컬렉션 간에 관계를 맺어 저장
      - 데이터 일관성이 유지되며, 수정 시 한 곳만 변경하면 됨
      - 하지만, 조인(lookup)이 필요해 조회 성능이 낮아질 수 있음
    - 비정규화
      - 중복을 허용하고 한 컬렉션에 데이터를 함께 저장
      - 조회 속도가 빠르지만, 중복된 데이터를 여러 곳에서 관리해야 함
      - 수정 시 여러 컬렉션을 업데이트해야 하는 부담이 있음
    - ex) 닉네임 같은 내용을 여러 컬렉션에 저장하는 경우
      - 여러 컬렉션에서 동일한 닉네임을 저장하면, 조회 성능은 향상됨
        - 닉네임으로 직접 검색 가능
      - 데이터 일관성 유지가 어려움
        - 닉네임 변경 시 모든 컬렉션 업데이트 필요
  - 부분 정규화
    - 자주 조회하는 데이터는 중복 저장하고, 변경 가능성이 높은 데이터는 참조
      - ex) 닉네임을 여러 컬렉션에 저장 (조회 최적화)
      - ex) 닉네임 변경 로그를 따로 관리하거나, 주기적으로 동기화
    - 하이브리드 전략
      - 닉네임은 별도 users 컬렉션에 저장하고, 자주 조회하는 컬렉션에는 캐싱 형태로 포함
      - 변경 시에는 users 컬렉션을 업데이트하고, 다른 컬렉션은 비동기적으로 업데이트
  - 신경써야 할 부분
    - 닉네임이 자주 변경되지 않는다면 중복 저장이 성능적으로 유리
    - 변경이 잦다면 users 컬렉션 참조 방식이 관리에 유리
    - 조회 성능이 중요한 경우, 닉네임 필드에 인덱싱 적용
    - 변경이 일어날 때 트랜잭션 또는 이벤트 기반 업데이트 고려
  - 실무에서는 어떤식으로 처리 ?
    - 완전한 정규화
      - 데이터 정합성을 최우선으로 생각
      - 데이터 정합성이 깨질 일이 없고, 스토리지 절약
      - 조회할 때마다 추가 쿼리 필요하고 데이터가 많아질수록 조회 성능이 느려질 수 있음
      - 실무에서는 작은 규모의 프로젝트라면 이 방식 사용 가능
    - 부분 정규화
      - 성능과 정합성을 적당히 타협
      - 조회 성능이 빠르고 닉네임 같은 내용만 비정규화, 이메일 같은 중요한 정보는 정규화 유지
      - 닉네임이 변경되면 중복 사용된 컬렉션도 업데이트해야 하며, 닉네임 동기화 로직을 따로 관리해야 함
      - 실무에서는 SNS, 커뮤니티 같은 경우 이 방식 사용이 많고, 닉네임 변경이 그렇게 자주 발생하지 않기 때문에 감당할 수 있는 수준이면 가능
    - 비정규화
      - 성능을 최우선으로 생각
      - 조회 성능이 가장 빠르고 DB 부하가 적음
      - 데이터 정합성 문제가 생길 수 있고, 중복 데이터가 많아질수록 스토리지 낭비
      - 실무에서는 규모가 큰 서비스에서는 거의 사용하지 않고, 조회 성능이 극도로 중요한 경우에는 캐싱(DB가 아닌 Redis 같은 데 저장)과 함께 사용
  - 결론
    - 데이터 정합성과 성능은 반비례 관계로, 정규화를 지키면 성능이 떨어지고 비정규화를 하면 데이터 정합성이 깨질 위험이 있음
    - 실무에서도 보통 완전한 정규화보다는 조회 성능을 고려하면서도 정합성을 적당히 유지하려고 부분 정규화 방식이 자주 사용
    - 내 경우, 일부 내용만 부분 정규화하는 쪽이 성능과 정합성을 적당히 타협해 구성할 수 있다고 생각됨

<br />

- 친구 목록에 존재하는지 확인하는 로직 추가
  - 이미 친구인 사용자에게 다시 친구 요청을 시도하면, 해당 정보를 확인해 일치하는 사용자를 찾고 만약 일치하는 사용자가 있을 경우, 에러 메시지와 함께 요청이 전달되지 않도록 해 주는 로직 추가
  - 백엔드
    - friend-routes
      - 친구 요청 라우터
        - friends 컬렉션에서 requester.id에 요청 보낸 사용자 \_id 또는 친구 추가할 사용자 \_id를 확인하고, receiver.id 내용도 마찬가지로 요청 보낸 사용자 \_id, 친구 추가할 사용자 \_id를 확인해 비교하고 일치하는 사용자를 찾도록 구성
        - 위 내용에서 찾은 사용자가 있다면 요청을 중단하고, 에러 메시지를 전달하도록 구성
  - 프론트엔드에서 전달한 정보를 확인해 일치하는 사용자가 있는지 찾고, 만약 일치하는 사용자가 존재한다면 친구 요청을 중단하고 에러 메시지가 전달되도록 구성한 후에 확인한 결과, 이미 친구인 사용자에게 친구 요청을 보내면 에러 메시지가 출력되고 친구 요청이 되지 않은 것을 확인할 수 있었다.
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/283380c3bccf4fcf6589ca8bb820b4a156a07749)

# 오늘 느낀 점

- 정규화와 관련된 내용을 정리해 주고, 이미 친구인 사용자에게 다시 친구 요청을 시도하면 오류 메시지와 함께 친구 요청이 전달되지 않도록 내용을 구성해 주었다. 여기에 추가로 친구 요청, 수락 등 내용이 양방향으로 실시간 반영되도록 socket.io 관련 로직을 구성하려고 했으나 제대로 진행하지 못했기 때문에 이와 관련된 내용을 추가해 줘야 하고, 구성한 내용을 테스트하면서 발견한 몇몇 문제들을 해결해 줘야 한다. 로그인하지 않은 상태에서 다이렉트 채팅방 관련 내용들이 보여지는데 이 내용들이 보여지지 않도록 로그인 관련 조건부 내용을 추가해야 하고, 친구와 관련된 내용에서 모두, 대기 중, 친구 추가하기 버튼 클릭 시 토글 함수가 재사용되어 다른 내용이 닫히고 해당 항목 내용이 보여지도록 구성을 변경해 줘야 한다. 추가로 처음에 페이지 접속 시에 로그인과 회원가입 관련된 내용만 보여지는 페이지로 접속되고, 그 다음 로그인을 하면 채팅방 관련된 내용이 보여지는 페이지로 이동되도록 라우터 구성을 수정해 줘야 하고, 여기에 추가로 만약 리프레쉬 토큰 즉, 이전에 로그인했던 정보가 남아있다면 바로 채팅방 관련된 페이지로 접속되도록 하는 구조도 추가를 해 줘야 할 것 같다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

- 친구 관련된 내용을 좀 다듬어야 함 (코드를 깔끔하게 보이도록 수정 필요)

- 친구 목록 출력 및 추가된 친구와 대화를 나눌 수 있는 다이렉트 채팅방

- 그룹 채팅방 초대하는 기능

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
