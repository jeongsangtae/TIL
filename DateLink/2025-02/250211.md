# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- 이미 친구 요청을 보냈거나 확인하는 로직 수정 및 본인 계정으로 친구 요청 못하도록 조건부 로직 추가
  - 이미 친구 요청을 보냈다면 반대쪽에서 중복 요청을 하지 못하도록 관련 로직을 수정하고, 로그인한 사용자가 본인 계정 이메일로 친구 요청을 하려고 할 때, 오류 메시지를 전달하고 요청이 진행되지 않도록 구성
  - 백엔드
    - friend-routes
      - 친구 요청 라우터
        - 로그인한 사용자가 본인 계정 이메일로 친구 요청을 했을 때 차단하고 막는 로직 추가
          - 요청 보낸 사용자의 \_id와 친구 추가할 사용자 \_id를 확인해 동일할 경우 멈추고, 에러 메시지를 전달
        - 이미 친구 요청을 보냈는지 확인하는 로직 수정
          - 한쪽이 이미 친구 요청을 보낸 경우, 반대쪽에서 중복 요청을 못 하도록 구성
          - 이전에 구성한 내용은 요청자가 요청자 \_id를 확인하고, 받은 사람은 받은 사람 \_id를 확인했으나 내용을 수정해, 요청자가 요청자 \_id와 받은 사람 \_id를 모두 확인하고, 마찬가지로 받은 사람이 요청자 \_id와 받은 사람 \_id를 모두 확인해 중복 요청을 못하도록 수정
  - 구성한 내용을 테스트한 결과, 이미 친구 요청이 되어있는 상태라면 반대쪽에서 친구 요청을 시도해도 오류 메시지와 함께 요청이 전달되지 않는 것을 확인했고, 로그인한 사용자가 본인 계정 이메일로 친구 요청을 하려고 하면 이 내용도 오류 메시지와 함께 요청이 전달되지 않는 것을 확인할 수 있었다.
    - 추가로, 다시 테스트해 보며 한 가지 문제가 있는 것을 확인했는데, 이미 친구가 된 상대방한테 다시 친구 요청을 보내면 그대로 요청이 전달되어 대기중 항목에 보여지는 것을 확인했기 때문에 이와 관련된 내용을 수정해야 함
    - 친구 목록과 관련된 컬렉션에서 해당 항목이 중복되는지 확인하고, 중복된다면 요청이 전송되지 않도록 구성하면 될 것 같음
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/e55a2043f3c9afa5504db67c903a7ac58586b929)

<br />

- 친구 목록 조회하는 액션, 라우터 로직 추가 및 친구 목록 출력
  - 친구 목록을 화면에 출력하기 위해 친구 목록과 관련된 액션 내용과 백엔드 라우터 로직을 구성하고, 해당 내용을 서로 연결한 후에 친구 목록 데이터를 전달해 출력이 되도록 구성
  - 백엔드
    - friend-routes
      - 친구 목록 조회하는 GET 라우터 추가
        - 액세스 토큰을 통해 사용자 정보를 가져오도록 구성
        - 사용자 정보가 유효한지 확인하고, 정상적으로 불러오지 못할 경우 에러 메시지 출력
        - 가져온 사용자 정보 \_id 내용에 new ObjectId를 사용해 변환
        - 친구 목록 조회하는 로직
          - friends 컬렉션에서 requester.id 또는 receiver.id 내용과 변환된 사용자 \_id를 비교해, 일치하는 항목을 찾도록 구성
        - 조회한 친구 목록을 프론트엔드로 전달하고, 오류 발생 시에 에러 메시지를 출력
        - deletedCount 체크하는 코드를 추가
          - deleteOne이 실행된 후, 이미 삭제되었거나 존재하지 않는 친구 요청 \_id를 전달했을 수 있기 때문에 확인하는 로직 추가
        - 친구 요청이 삭제되면 해당 메시지를 프론트엔드로 전달하고, 반대로 오류 발생 시에 오류 메시지 전달
  - 프론트엔드
    - friendStore
      - 친구 목록 조회하는 action 추가
        - fetch 함수
          - fetch 함수 추가
          - credentials 내용만 추가
        - 조회 실패했을 때, 오류 메시지 전달 코드
        - set을 추가하고, friends 상태가 넘어온 응답 데이터로 업데이트되도록 구성
    - Friends
      - useAuthStore에서 userInfo 상태를 불러오도록 구성
      - useFriendStore에서 추가로 friends 상태와 loadFriend 액션을 불러오도록 구성
      - userInfo 내용의 \_id를 별도의 변수에 저장
        - userId로 사용
      - friends 데이터를 미리 정제하기 위한 변수 추가
        - 로그인한 사용자 정보를 제외하고 친구 정보만 정제하도록 구성
        - friends 데이터에 map 함수를 사용하고 조건에 따라 재배열되도록 구성
        - userId(로그인한 사용자 \_id)가 requester.id와 일치하는 경우
          - 로그인한 사용자가 요청을 보낸 경우이기 때문에, 친구는 receiver에 있으므로 receiver 정보를 가져오도록 구성
        - userId(로그인한 사용자 \_id)가 requester.id와 일치하지 않는 경우
          - 로그인한 사용자가 요청을 받은 경우이기 때문에, 친구는 requester에 있으므로 requester 정보를 가져오도록 구성
      - 정제한 데이터를 map 함수로 재배열하고, Friend 컴포넌트에 id, nickname prop으로 전달하도록 구성
    - Friend
      - prop으로 전달받은 nickname 내용이 화면에 출력되도록 구성
  - 친구 목록 조회와 관련된 로직을 프론트엔드와 백엔드에서 각각 구성하고 서로 연결해 테스트한 결과, 친구로 저장된 사용자 닉네임이 화면에 출력되어 보여지는 것을 확인할 수 있었다.
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/25cc56cad8098652dacf1f8d234814c48ee93f11)

# 오늘 느낀 점

- 친구 요청이 이미 전송된 상태라면 반대쪽에서 다시 요청을 할 수 없도록 해 주었고, 로그인한 사용자가 본인 이메일을 입력해 친구 추가하려고 할 때 오류 메시지와 함께 친구 요청이 전달되지 않도록 구성을 해 주었다. 친구 요청과 관련해 빠진 내용이 있는데, 이미 친구가 된 사용자 이메일을 다시 입력하고 친구 요청하면 오류 메시지와 함께 요청이 전달되지 않는 것이 맞는 구조지만, 현재는 다시 요청이 전송되고 있기 때문에 이미 친구가 된 사용자는 적당한 메시지와 함께 친구 요청이 전달되지 않도록 추가 수정이 필요하다. 그리고 친구 목록을 불러와 화면에 출력하는 것도 문제없이 이루어지기 때문에, 이제는 친구 요청이나 수락 등 여러 내용에 socket.io 관련 로직을 추가해 이 내용들이 양방향으로 실시간 반영이 되도록 구성을 해 줘야 한다. 추가로, 데이터 정규화 관련된 내용을 또 잊어버리고 정리하지 않았기 때문에 꼭 기억해 정리해 줘야 하고, 닉네임 변경 업데이트가 실시간으로 반영되도록 코드를 구성해 줘야 한다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

- 정규화 정리

- 친구 관련된 내용을 좀 다듬어야 함 (코드를 깔끔하게 보이도록 수정 필요)

- 친구 목록 출력 및 추가된 친구와 대화를 나눌 수 있는 다이렉트 채팅방

- 그룹 채팅방 초대하는 기능

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
