# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- 새로운 메시지 액션 사용하는 위치 수정 및 소켓 확인하는 테스트 코드 추가
  - 메시지 수신 이벤트 연결이 소켓에 연결될 때 바로 실행하는 것이 아닌, 방 참여가 이루어질 때 실행되도록 newMessage 액션 실행 위치를 수정해 주었고, 소켓이 정상적으로 초기화되어 실행되는지 확인하는 콘솔 로그와 newMessage 액션에 약간의 지연 시간을 추가해 정상적으로 소켓이 초기화되고 실행되는지 확인하는 테스트 코드 추가
  - 프론트엔드
    - chatStore
      - 소켓이 정상적으로 초기화되었는지 확인하는 콘솔 로그 추가
      - connect 액션 관련 주석 처리한 코드 삭제
    - socketStore
      - 메시지 수신 이벤트 내용인 newMessage 액션 내용을 connect 액션에서 joinGroupChat 액션으로 이동
    - Chats
      - newMessage 액션 주석 처리
        - joinGroupChat 액션에서 함께 실행
      - setTimeout을 추가해 newMessage 액션을 지연시켜 실행하는 테스트 코드 추가
        - 테스트한 후에 주석 처리
  - 메시지 수신 이벤트 내용이 방 참여가 이루어질 때 실행되도록 수정한 내용은 문제없이 작동하는 것을 확인했고, newMessage 액션 내용에 약간의 지연 시간을 추가하면 소켓이 정상적으로 초기화된 후 실행되는 것을 확인했고, 새로고침을 한 후에 메시지를 추가하면 추가한 메시지가 실시간 반영되어 출력되는 것을 확인할 수 있었다.
    - useEffect에서 newMessage 액션에 지연 시간을 추가하지 않고 실행하면, 새로고침 후에 정상적으로 메시지 수신 이벤트가 연결되지 않아서 메시지 내용이 실시간 반영되지 않았지만, 지연 시간을 추가한 후에 테스트하면 소켓이 정상적으로 초기화되고 실행되어 메시지 수신 이벤트가 연결되므로 추가한 메시지 내용이 실시간 반영됨
    - setTimeout을 추가해 구성한 내용은 일시적 지연 시키는 방법으로 올바른 방법이 아니기 때문에 주석 처리하고, 만약 비동기 방식으로 지연시키려면 조금 깔끔하지 못한 코드 구성이 추가됨
    - 이제까지 newMessage 액션이 useEffect에서 실행될 때, 새로고침하면 정상적으로 연결되지 않던 이유는 socket 초기화가 되지 않아서, socket이 없다고 판단되어 중간에 return으로 코드가 종료되어서 발생한 문제
    - 추가한 메시지가 실시간 반영되도록 여러 방법을 생각해 봤는데, 이 방법에 대해서는 따로 추가 정리하고 확실하게 어떤 방법과 구조로 진행할 지 정해야 함
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/558ed606cc579865d126d2ec600d7b18191ebad0)

<br />

- 메시지 수신 이벤트 연결을 위한 여러 방법 정리 (새로고침 시에 발생하는 실시간 반영 관련 문제)
  - 발생하는 문제
    - 새로고침 후에 메시지를 추가하면, 실시간 반영되지 않고 DB에 메시지만 저장됨
    - 다른 방으로 이동해 메시지를 추가하면 실시간 반영되어 출력되며, 새로고침 시에만 문제가 발생
  - 원인
    - useEffect에서 newMessage 액션을 추가하고 실행하면, socket 초기화가 이뤄지지않은 상태로 동작해 메시지 수신 이벤트가 연결되지 않고 메시지가 추가되어 실시간 반영이 되지 않음
  - 시도한 방법
    - useSocketStore Zustand의 connect 액션에 newMessage 액션을 추가해 함께 실행되도록 하는 방법
      - connect 액션에서 로컬 스토리지에 저장된 currentRoom 정보를 가져올 때 joinGroupChat 액션이 실행되며, `useChatStore.getState().newMessage();` 내용도 함께 실행되도록 구성
      - 이 방법은 초기에 방 참여를 하면 newMessage 액션이 실행되지 않아서 메시지 수신 이벤트가 연결되지 않기 때문에 useEffect에 newMessage 액션을 추가해 구성해야 함
      - 해당 방법으로 시도하면, 새로고침하고 메시지를 추가해도 실시간 반영되어 메시지가 보이기 때문에 문제가 없음
    - useSocketStore Zustand의 joinGroupChat 액션에 newMessage 액션을 추가해 함께 실행되도록 하는 방법
      - joinGroupChat 액션에 `useChatStore.getState().newMessage()`를 추가해서 joinGroupChat 액션이 실행되면 함께 실행되도록 구성
      - 이 방법은 초기에 방 참여를 하면 newMessage 액션이 함께 실행되기 때문에, useEffect에 newMessage 액션을 추가할 필요가 없음
      - 해당 방법도 새로고침하고 메시지를 추가하면 실시간 반영되어 메시지가 보여짐
    - newMessage 액션에 setTimeout을 추가해 약간 지연시켜서 socket 초기화 후 실행하는 방법
      - useEffect에 구성된 newMessage 액션에 setTimeout을 추가해 약간 지연시켜서 실행되도록 구성
      - 이 방법은 setTimeout으로 인해 약간 지연되어, socket이 초기화 된 후 실행되기 때문에 새로고침하고 메시지를 추가하면 실시간 반영되어 메시지가 보여짐
  - 고려할만한 방법
    - newMessage 액션 내용을 useSocketStore Zustand로 옮겨서 관리하는 방법
      - 장점
        - socket 관련 이벤트가 한 곳에서 관리되니까 useSocketStore가 소켓 관련 상태를 전적으로 관리할 수 있음
        - useSocketStore에서 newMessage 액션을 구성해 사용하기 때문에 useChatStore와 useSocketStore 간 의존성이 낮아짐
      - 단점
        - newMessage가 채팅 관련 로직인데 useSocketStore로 가는 것이 맞는지 의문
          - 채팅 관련 이벤트인 newMessage가 원래 useChatStore에서 관리되는데, 이를 useSocketStore로 옮기면 역할이 섞이는 느낌이 들 수 있음
        - 유지보수 시 헷갈릴 가능성이 높음
          - 채팅 관련 이벤트인데, 왜 useSocketStore에 있지 라는 의문이 들 수도 있음
      - 결론
        - 소켓과 관련된 이벤트를 한 곳에서 관리하는 건 좋지만, newMessage는 채팅의 핵심 로직이기 때문에 useChatStore에 두는 게 더 적절해 보임
        - 역할이 다소 섞일 수 있어서 권장하지 않음
    - joinGroupChat 실행 시 newMessage가 함께 실행되도록 하는 방법
      - 장점
        - 가독성이 좋고, 코드가 깔끔함
        - 불필요한 setTimeout 없이 자연스럽게 동작함
        - useEffect에서 joinGroupChat만 실행하니까 추후 유지보수가 쉬움
        - 의존성 문제? 사실상 크게 문제 없음
          - useSocketStore에서 `useChatStore.getState().newMessage()`를 가져와 사용하는 것 자체는 크게 문제될 게 없음
          - 완전한 의존성 분리가 이상적이긴 하지만, 이 정도는 큰 문제 없이 충분히 관리 가능
      - 단점
        - Zustand 간 의존성이 약간 증가함
          - 의존성을 최소화하면서도 현실적인 코드 유지보수가 가능하다면, 이 정도는 감수할 수 있음
      - 결론
        - 현재 코드 구조에서 가장 깔끔하고 유지보수가 쉬운 방법
        - Zustand 간 약간의 의존성은 있지만, 이 정도는 감수해도 될 수준
        - 가독성이 좋고, setTimeout 같은 임시 방편 없이 해결되므로 추천
    - setTimeout 같은 비동기 내용을 추가해, 소켓 연결될 때까지 대기한 후 실행하는 방법
      - 장점
        - useChatStore와 useSocketStore 간 의존성이 낮아짐
        - 비동기적으로 socket이 연결될 때까지 대기하기 때문에, socket이 없는 상태에서 실행될 가능성이 없음
          - socket이 확실히 연결된 후에만 newMessage가 실행됨
      - 단점
        - 코드가 지저분해지고 가독성이 떨어짐
        - setTimeout을 반복적으로 호출하는 구조 자체가 불필요한 코드 실행을 유발할 수 있음
        - 소켓 연결이 지연될 때 불필요한 setTimeout이 계속 실행됨
          - 네트워크 문제로 연결이 지연되면, setTimeout이 여러번 더 실행될 수도 있음
      - 결론
        - 구조적으로는 맞지만, 코드가 복잡해지고 불필요한 연산이 발생하므로 추천하지 않음
        - 비동기적으로 socket을 기다리는 게 필요하다면, 차라리 useEffect에서 socket.on("connect") 이벤트를 감지하는 방식이 더 좋음
    - 최종 결론
      - 2번 방식이 가장 현실적인 선택
        - 코드가 가장 깔끔하고 유지보수하기 좋음
        - Zustand 간의 의존성이 조금 있지만, 현재 구조에서는 문제될 수준이 아님
        - setTimeout 같은 불필요한 로직 없이 소켓 연결과 채팅 로직이 자연스럽게 실행됨
        - 오히려 지나치게 분리하려고 하면 코드가 더 복잡해질 수 있음
  - joinGroupChat 실행 시 newMessage 액션이 함께 실행되도록 하는 방법에서 고려해야 할 문제들
    - 의존성 증가 문제
      - 네이밍과 역할을 고려하면 괜찮음
      - joinGroupChat은 방 입장을 담당하는 액션이지만, 방 입장 시 메시지를 받을 준비를 하는 것도 자연스러운 흐름
      - 즉, joinGroupChat이 실행될 때 newMessage 액션을 함께 실행하는 것은 논리적으로 어색하지 않음
    - useChatStore를 직접 호출하는 문제
      - 현재 구조에서는 크게 문제 없음
      - Zustand에서 `useChatStore.getState().newMessage()`를 호출하는 것은, 단순히 하나의 상태(스토어)에서 다른 상태(스토어)를 참조하는 패턴
      - Redux 같은 라이브러리에서는 이런 방식이 강하게 권장되지 않지만, Zustand는 비교적 자유롭기 때문에 이 정도는 허용 가능함
      - 오히려 joinGroupChat을 호출한 후 다른 곳에서 newMessage 액션을 따로 실행해야 한다면 코드가 더 복잡해질 수 있음
    - 유지보수성 문제
      - 현재 구조에서는 괜찮음
      - 만약 joinGroupChat이 여러 곳에서 호출되는데 일부는 newMessage 액션이 필요 없고 일부만 필요하다면 분리하는 것이 맞음
        - 지금 구조에서는 방에 입장하면 메시지 수신 이벤트 등록이 항상 필요하니까 자연스럽게 포함되는 게 나음
      - 추후에 다이렉트 채팅과 관련된 내용이 추가되면 joinGroupChat을 변경해 joinRoom 하나로 통합하고 재사용될 수 있도록 구성하거나, 다이렉트 채팅 관련 액션을 구성하고 newMessage 액션을 추가해 사용하면 됨

# 오늘 느낀 점

- 새로고침하고 새로운 메시지를 추가하면 실시간 반영이 되도록 하는 여러 방법을 테스트해 봤는데, 결과적으로 다른 방법으로 테스트한 내용보다 이전에 사용하던 방법이 훨씬 깔끔하고 유지보수하기 좋다고 생각되어, 기존 방식대로 유지를 할 생각이다. 그리고 기존 코드 내용은 의존성 부분이나 결합도 부분에서 걱정이 되었는데, 그 부분은 크게 문제될 수준이 아닌 것 같아서 setTimeout같은 불필요한 로직을 추가하는 것보다는 현재 구조로 유지하는 것이 더 적합하다고 생각이 된다. 메시지 수신 이벤트 관련된 내용은 얼추 마무리가 되었기 때문에, 이제 방 나가기 기능과 새로운 메시지가 추가되었을 때 알림이 뜨도록 하는 기능 그리고 메시지가 추가된 후에 입력창 초기화하는 기능까지 추가를 해 줘야 할 것 같다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

- 방 나가기 기능

- 새로운 메시지 추가되었을 때 알림 뜨는 기능

- 친구 관련된 내용을 좀 다듬어야 함 (코드를 깔끔하게 보이도록 수정 필요)

- 친구 관련된 내용에서 타입 정의 및 코드 정리 필요

- 소켓 관련 내용에서도 타입 정의 필요

- 그룹 채팅방에서 채팅 메시지가 추가되면 전역적으로 알 수 있도록 알림이 떠야 하고, 그 알림 관리를 소켓 Zustand에서 할 수 있도록 구성 필요

- 추가된 친구와 대화를 나눌 수 있는 다이렉트 채팅방

- 그룹 채팅방 초대하는 기능

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
