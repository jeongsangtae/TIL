# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- some 함수
  - 정의
    - JS의 배열 메서드로, 배열의 요소 중 하나라도 주어진 조건을 만족하면 true를 반환하고, 그렇지 않으면 false를 반환하는 함수
    - 빈 배열에서는 항상 false를 반환
  - some과 every 차이
    - some 함수는 하나라도 조건 만족하면 true
    - every 함수는 모든 조건 만족해야 true
  - 프로젝트에서 사용되는 용도
    - some 함수를 사용해 중복된 \_id가 존재하는지 체크
    - 중복된 메시지가 있다면 기존 상태를 그대로 유지
      - 새로운 메시지를 추가하지 않음
    - 중복된 메시지가 없으면 새 메시지를 기존 배열에 추가
    - 같은 메시지가 중복해서 추가되는 것을 방지

<br />

- useState와 Zustand 여러 차이점 비교
  - 상태 업데이트 차이
    - useState
      - 상태를 직접 관리하고, 상태가 변경될 때마다 컴포넌트가 재렌더링
      - 상태가 정확히 변경될 때만 렌더링이 일어남
    - Zustand
      - 상태를 업데이트할 때 set()을 통해 상태를 변경하고, 이 과정에서 렌더링을 트리거하는 방식
      - 상태가 변경될 때마다 구독하고 있는 컴포넌트들이 렌더링되므로, 예상치 못한 중복 렌더링이 발생할 수 있음
  - 상태 관리 방식 차이
    - useState
      - 상태를 변경할 때 항상 새로운 배열을 생성함
      - 이전 상태를 반영해 업데이트를 하는 경우, 기존 배열을 복사한 후 새로운 요소를 추가하기 때문에 React의 상태 변경 감지 시스템이 이를 감지하고 리렌더링을 트리거
      - 내부적으로 불변성을 유지하기 때문에, 이전 상태가 변경되지 않았다면 이전 상태를 유지할 수 있음
    - Zustand
      - useState와 달리, 상태가 내부적으로 Proxy를 통해 관리됨
      - 이전 상태를 반영해 업데이트를 하는 경우, 새로운 배열을 만들긴 하지만, Zustand의 내부 상태 관리 방식에서 기존 값과 같다면 리렌더링을 안할 수도 있음
      - 기존 메시지와 중복되는 경우 추가되지 않을 수도 있는데, 기존 메시지가 Proxy 객체라면 some 함수 같은 배열 메서드로 비교할 때 중복 검사가 예상과 다르게 동작할 가능성이 있음
      - useState 상태 업데이트와 달리 새로운 객체를 반환해야 하는데, 만약 이전과 같은 값을 반환하면 상태가 변경되지 않았다고 판단하여 리렌더링이 일어나지 않을 수 있음
  - 간단 정리
    - useState는 상태 변경을 자동으로 감지하지만, Zustand는 내부적으로 Proxy를 사용해 상태를 관리하기 때문에 직접 비교할 필요가 있음
    - useState에서는 이전 상태를 반영해 업데이트하는 코드로도 충분했지만, Zustand에서는 내부에서 중복을 확인하고 새로운 객체를 반환해야 상태가 정상적으로 업데이트됨
    - 중복 메시지 방지를 위해 some 함수를 이용해 중복 확인 후 추가하는 방식이 적절함

<br />

- 재사용 타입 정의 추가 및 빠진 타입 정의 추가
  - 재사용될 수 있는 타입은 재사용 타입 정의 파일에 내용을 추가해 주었고, 채팅과 관련된 컴포넌트들 내에서 타입 정의가 제대로 이루어지지 않아서 타입 정의와 관련된 에러가 발생하기 때문에 부족한 타입 정의 내용을 추가
  - 프론트엔드
    - GroupChatDetails
      - useParams를 통해 가져오는 roomId에 대한 타입 정의 추가
        - string으로 타입 정의
    - chatStore
      - socket.io-client에서 io 외에 Socket도 가져오도록 수정
      - 재사용 타입인 ChatMessage도 함께 불러오도록 수정
      - ChatStore 타입 정의 수정
        - socket에 대한 타입 정의를 Socket 또는 null이 들어오도록 수정
          - null로만 정의하면 타입 에러가 발생하기 때문에 Socket도 포함
        - messages 타입 정의는 새롭게 추가한 재사용 타입인 ChatMessage가 사용되도록 수정
          - string으로만 정의하면 타입 에러가 발생하고, 더 명확하고 자세한 ChatMessage로 타입 정의
        - chatData와 sendMessage는 일반 함수가 아닌, 비동기 함수로 타입 정의
      - 새로운 메시지가 추가될 때 메시지 목록에 추가되는 코드의 newMessage에 대한 타입 정의 수정
        - messages에 대한 타입 정의가 ChatMessage로 변경되었기 때문에, newMessage 또한 string이 아닌, ChatMessage로 타입 정의되도록 수정
      - 테스트를 위해 추가했던 console.log 및 사용하지 않고 주석 처리된 코드 삭제
        - socket.io 연결 테스트를 위한 testButton 액션 포함
    - Chats
      - 재사용 타입인 RoomId를 불러오고, roomId prop에 사용해 타입 정의
      - connect, chatData 액션 내용이 실행되는 useEffect에 roomId가 undefined일 때 API 요청을 보내지 않도록 if문 추가해 확인하도록 구성
    - Chat
      - 재사용 타입인 ChatMessage를 불러오고, message prop에 Pick를 사용해 ChatMessage 타입에서 message만 추출해 타입 정의
    - ChatInput
      - 재사용 타입인 RoomId를 불러오고, roomId prop에 사용해 타입 정의
      - testButton 액션을 삭제해서 더이상 사용하지 않기 때문에 제거
      - inputChangeHandler 함수의 event 타입 정의
        - 내용 변경과 관련된 event이기 때문에 `ChangeEvent<HTMLTextAreaElement>`로 event 타입 정의
      - sendMessageHandler 함수의 event 타입 정의
        - 입력한 내용을 마우스 클릭으로 전송시키기 때문에 `MouseEvent<HTMLButtonElement>`로 event 타입 정의
      - sendMessage 액션으로 전달하는 roomId와 userInfo가 존재하는지 확인하는 if문 추가
        - 타입 에러를 방지하기 위해 if문 추가
        - roomId와 userInfo가 존재하지 않으면 함수 실행을 멈추고 에러 메시지를 출력하도록 처리
      - textarea에 구성한 rows 속성이 숫자 타입이 되도록 {1}로 변경
        - 타입 안정성을 고려해 {1} 이런식으로 구성하는 것이 더 권장됨
      - socket.io 테스트 버튼 삭제
    - types
      - useParams를 통해 가져오는 내용인 roomId에 대한 타입 정의를 재사용할 수 있도록 RoomId 인터페이스 추가
        - string 타입으로 정의하고, roomId를 선택적으로 만들어서 useParams에서 반환된 undefined 값도 정상적으로 전달될 수 있도록 구성
      - 채팅 메시지와 관련된 내용에 대한 타입 정의를 재사용할 수 있도록 ChatMessage 인터페이스 추가
        - 모든 항목이 string으로 사용되도록 타입 정의
  - 재사용 타입 정의를 추가하고 빠진 타입 정의도 구성해 준 후에 확인한 결과, 채팅과 관련된 내용에서 타입 에러가 발생하지 않는 것을 확인할 수 있었고, 코드들 또한 이전과 동일하게 작동하는 것을 확인할 수 있었다.
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/6e7b6799e3ad50ec77cb6f23becc350791546ae4)

# 오늘 느낀 점

- some 함수 그리고 useState와 Zustand의 상태 관리 차이를 비교하고 채팅 관련 구성에서 빠진 타입 정의를 추가해 주면서 채팅 메시지 입출력에 관한 내용은 마무리가 된 것 같다. 이제 모든 그룹 채팅방, 메시지, 사용자 정보를 삭제하고 사용자 생성 시에 닉네임 뒤에 태그가 달리도록 구성을 해 줘야 하고, 추가로 그룹 채팅방 삭제 또는 사용자 삭제 시에 그 내용과 관련된 모든 내용이 삭제가 되도록 구성을 해 줘야 한다. 우선은 추가하려고 생각했던 사용자 닉네임 뒤에 태그부터 추가를 하고, 그 다음 삭제와 관련된 내용에서 관련 내용이 모두 삭제되는 코드를 추가할 생각을 했는데, 이 내용은 결국 다른 내용이 추가되면 삭제 내용에서 또 추가 작업을 해야 하기 때문에 조금 뒤로 미루고 우선 친구 추가 또는 검색과 관련된 내용을 구성해 볼 생각이다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

- 사용자 생성 시 닉네임 뒤에 태그 내용

- 친구 추가를 위해 검색 모달 및 친구 추가 모달

- 친구 목록 출력 및 추가된 친구와 대화를 나눌 수 있는 다이렉트 채팅방

- 그룹 채팅방 초대하는 기능

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
