# 오늘 한 일

### React + TypeScript 프로젝트 제작 (React, TypeScript, ExpressJS, MongoDB로 만드는 실시간 통신 애플리케이션)

- verifyUser 액션에 socket 연결 내용 추가 및 친구 요청에서 socket 관련 내용 테스트
  - 인증 관련 Zustand의 verifyUser 액션에 socket 연결과 관련된 내용을 추가해 새로고침 시에 socket 연결이 해지되지 않도록 구성해 주고, 친구 요청과 관련된 socket 연결을 테스트해 보기 위해 내용을 수정
  - 백엔드
    - app
      - 친구 요청과 관련된 별도의 socket 연결 내용을 추가
        - "/friend" 경로로 설정
        - 소켓 연결 시에 콘솔에 메시지 출력
        - 친구 요청이 넘어오면 요청 보내는 사용자와 입력한 사용자 이메일을 전달 받고, 해당 이메일들을 콘솔에 출력
        - 친구 요청 소켓 연결 해제 시에 콘솔에 메시지 출력
      - 관련 내용을 구성해 테스트하려고 했으나, 설정 미흡으로 제대로 테스트 불가능
  - 프론트엔드
    - authStore
      - verifyUser 액션 내용 수정
        - useSocketStore를 불러오고, getState를 사용해 connect 액션을 직접 가져와서 실행되도록 구성
        - 해당 내용을 추가함으로써, 새로고침 시에 socket 연결이 해제되지 않고 유지됨
    - friendStore
      - 주석 처리했던 connect 내용을 테스트하기 위해 주석을 풀고 내용을 수정했으나, 설정 미흡으로 제대로 테스트가 불가능하기에 다시 주석 처리
  - 인증 관련 Zustand의 verifyUser 액션에 추가한 내용이 정상적으로 작동하여, 새로고침을 시도하면 socket이 다시 연결되는 것을 확인했고, 친구 요청과 관련된 socket 연결은 코드를 구성하던 중에 설정이나 구조가 잘못된 것 같아서 우선 코드 구성을 중단하였고, 그로 인해 제대로 테스트해 보지 못했기 때문에 다시 제대로 확인하고 코드를 구성해 테스트해 봐야 함
    - 친구 요청과 관련된 socket을 별도로 연결하고 이후에 해제하는 것은 구조도 좀 이상하고, 친구 요청을 수신 받는 이벤트 관련된 알림 구성이 이상하게 진행되기 때문에, 좀 더 관련 내용을 찾아보거나 구조를 짜본 후에 확실하게 정하고 진행을 해야 함
  - [코드 내용](https://github.com/jeongsangtae/float-chat/commit/e99c479592f874ccbfa5609cdf529e646d897568)

<br />

- 실시간 내용 구현을 위한 socket.io 연결과 관련된 여러 내용 정리
  - 독립된 소켓 Zustand 구성과 통합된 소켓 Zustand 구성
    - 각 기능별로 소켓을 따로 연결하는 방법 (독립된 Zustand 스토어)
      - 구성
        - 친구 요청 관련 소켓 관리
        - 그룹 채팅 소켓 관리
        - 다이렉트 채팅 소켓 관리
      - 장점
        - 필요할 때만 연결해서 불필요한 소켓 연결을 방지
        - 각각의 기능이 독립적이므로 관리하기 쉬움
      - 단점
        - 여러 개의 소켓을 관리해야 해서 복잡도가 증가
        - 소켓이 여러 개라 서버 부하 증가 가능성
      - 이 방법은 각각의 기능이 완전히 독립적이고, 필요할 때만 연결하고 싶을 때 적합함
    - 하나의 소켓에서 모든 기능을 관리하는 방법 (통합된 Zustand 스토어)
      - 구성
        - 하나의 Zustand에서 모든 소켓 연결을 관리
        - 로그인할 때 소켓을 연결하고, 로그아웃할 때 해제
      - 장점
        - 소켓을 하나만 유지하므로 서버 부하를 줄일 수 있음
        - 새로운 기능을 추가할 때도 쉽게 확장 가능
      - 단점
        - 필요 없는 기능도 항상 연결될 수 있어서 리소스 낭비 가능
        - 특정 기능만 필요할 때 소켓 이벤트를 on/off 해야 하는 경우 복잡해질 수 있음
      - 이 방법은 로그인 시 소켓을 유지하면서, 실시간 데이터를 계속 받아야 할 때 적합함
    - 간단 정리
      - 채팅방에서만 메시지를 받아야 한다면?
        - 각 기능별로 소켓을 따로 연결하는 방법
        - 채팅방에 들어갔을 때만 소켓을 연결하고 나가면 해제
      - 채팅방이 아니어도 메시지를 받아야 한다면?
        - 하나의 소켓에서 모든 기능을 처리하는 방법
        - 로그인할 때 소켓을 연결하고, 로그아웃할 때 해제
      - 추가로, 하나의 소켓에서 모든 기능을 처리하는 방법을 선택하더라도 채팅방에 들어갈 때만 특정 이벤트를 활성화할 수도 있음
        - 소켓 연결 자체는 유지하지만, 필요한 이벤트만 on/off하는 방식으로 가능
  - 디스코드처럼 실시간 알림과 채팅을 관리하는 서비스를 목표로 한다면?
    - 로그인 상태에서는 실시간으로 알림을 받고, 비로그인 상태에서도 새로운 요청이나 메시지를 저장했다가, 로그인 후 알림을 띄우는 방식이 필요
    - 목표 기능 정리
      - 실시간 알림
        - 친구 요청, 그룹 채팅, 다이렉트 메시지를 실시간으로 받을 수 있어야 함
        - 앱 어디서든 알림이 떠야 함 (채팅방에 있지 않아도)
        - 페이지 이동이나 특정 뷰에서 사라지는 게 아니라, 항상 유지되는 방식
      - 비로그인 상태에서 들어온 데이터 저장
        - 비로그인 상태에서도 새로운 친구 요청 또는 메시지를 저장해야 함
        - 로그인 후, 이전 데이터를 기반으로 알림을 띄워야 함
    - 소켓 관리 구조
      - 각 기능별로 소켓을 따로 연결하는 방식
        - 친구 요청 소켓, 그룹 채팅 소켓, 다이렉트 메시지 소켓 같은 내용을 기능별로 따로 관리하고, 필요할 때만 on/off
      - 하나의 소켓에서 모든 기능을 관리하는 방식
        - 로그인하면 하나의 소켓을 유지
        - 친구 요청 수신, 그룹 채팅 메시지 수신, 다이렉트 메시지 수신 같은 모든 이벤트를 한 곳에서 처리
      - 디스코드 같은 서비스라면, 하나의 소켓을 유지하면서 이벤트를 관리하는 게 유리함
    - 비로그인 상태에서 들어온 알림 저장하는 방법
      - 로컬 스토리지 활용
        - 로그인하기 전에는 소켓을 사용할 수 없으니, 로컬 스토리지에 데이터를 저장해두고, 로그인 후 불러오는 방식
  - 여러 테스트를 해 본 후 결론
    - 각 기능별로 소켓을 따로 연결하는 방법
      - 그룹 채팅과 관련된 내용은 그대로 유지
      - 친구 요청과 관련된 내용은 따로 소켓을 연결해 구성
        - 이 방법은 친구 요청 내용에 접속해야 소켓 연결이 되고, 알림을 받을 수 있음
        - 결국, 친구 요청을 받은 사용자가 친구 요청 내용에 접속해야 이벤트를 받기 때문에 알림과 관련된 내용에서 문제가 생김
        - 전역적으로 연결되는 소켓이 없어서 제대로 작동할 수 없는 구조
      - 각 기능별로 소켓을 따로 연결하는 방법은 구조가 불편한 구조로 이루어지고, 원하는 동작이 이루어지지 않을 가능성이 높음
    - 하나의 소켓에서 모든 기능을 관리하는 방법
      - 로그인 시에 소켓과 연결되는 부분까지 구현
        - 로그인하면 소켓과 연결되고, 콘솔에서 연결 관련 메시지를 출력
      - 소켓 연결을 전역적으로 유지하면 친구 요청 내용에 접속하지 않아도 이벤트를 받을 수 있고, 어디에 있든 소켓을 통해 친구 요청이나 그룹 채팅 메시지 알림 등 내용을 받을 수 있음
      - 친구 요청 알림을 단순히 소켓으로만 전송하면 상대방이 소켓 연결이 안 되어 있을 때 알림을 받을 수 없기 때문에, 친구 요청을 DB에 저장한 후 상대방이 로그인하면 해당 요청을 불러오는 방식도 가능
        - 로그인하면 바로 알림을 받을 수 있도록 구현 필요
      - 전역적 소켓 연결이 좋은 점
        - 친구 요청 내용에 있지 않아도 이벤트를 받을 수 있음
          - 새롭게 추가해 보았던 방식은 친구 요청 내용에 접속해야 소켓이 연결되기 때문에, 다른 페이지에 있으면 알림을 못 받음
        - 다른 실시간 기능도 쉽게 확장 가능
          - ex) 채팅 알림, 여러 알림 등
        - 소켓을 한 번만 연결하고 유지할 수 있음
          - 로그인할 때 한 번 연결하고 앱이 종료될 때까지 유지하면 불필요한 연결/해제 반복을 방지할 수 있음
      - 그룹 채팅, 다이렉트 채팅에서 개별 채팅방 소켓 연결에 대한 문제점
        - 결론부터 말하면, 소켓을 2중으로 연결할 필요 없이 하나의 소켓으로 해결 가능
        - 한 개의 전역 소켓을 유지하면서, 채팅방 입장 시 특정 방에 참여(join)하는 방식을 사용하면 됨
        - 새로운 소켓을 만들 필요 없이 기존 소켓을 그대로 활용
        - 해결 방법 정리
          - 로그인할 때 전역 소켓을 연결
            - 전체적인 알림, 친구 요청, 새로운 채팅 알림 등을 처리
          - 채팅방에 입장하면 기존 소켓을 이용해 특정 방에 join
            - 채팅방에서 실시간 메시지를 주고받음
          - 채팅방을 나가면 leave 처리
            - 필요하면 이벤트 리스너 정리
        - 로그인 시 한 개의 전역 소켓만 연결되고, 채팅방에 들어가면 기존 소켓을 이용해 특정 방에 입장할 수 있고, 새로운 소켓을 만들지 않기 때문에 소켓 연결이 중복되지 않으며, 채팅방에서 나가면 방을 떠나지만 소켓 연결은 유지할 수 있고, 필요하면 다른 실시간 기능도 같은 소켓에서 처리 가능함
    - 최종적으로 하나의 소켓에서 모든 기능을 관리하는 것이 훨씬 관리하기 편하고 확장할 수 있는 여지도 있기 때문에 하나의 소켓으로 관리할 계획

# 오늘 느낀 점

- 로그인하고 새로고침하면 소켓 연결이 해제되는 문제가 생겼지만, 코드 수정을 통해 이제는 새로고침해도 소켓 연결이 해제되지 않고 다시 연결되는 것을 확인했다. 그리고 각 기능별로 소켓을 연결하기 위해, 친구 요청과 관련된 소켓을 별도로 구성해 연결하는 코드를 구성해 보았지만, 깔끔하게 구성이 되지도 않고 친구 요청을 시도하면 알림 내용을 소켓으로 상대방에게 전송해야 하는데, 이 구조가 제대로 구성도 되지 않고 불편한 구조를 가지고 있어서 결국, 하나의 소켓에서 모든 기능을 관리하는 방법이 최선이라고 생각되어 이 구조로 내용을 구성해야 할 것 같다. 관련된 내용도 정리했기 때문에 한 번 더 살펴본 후에, 친구 요청을 시도하면 그에 대한 알림이 상대방에게 표시되도록 구성을 해 볼 생각이다.

<br />

# 내일 할 일

- 실시간 통신 애플리케이션 (Float Chat) 프로젝트 진행

- Zustand 내용 구성

- 친구 관련된 내용을 좀 다듬어야 함 (코드를 깔끔하게 보이도록 수정 필요)

- 친구 목록 출력 및 추가된 친구와 대화를 나눌 수 있는 다이렉트 채팅방

- 그룹 채팅방 초대하는 기능

<br />

# 앞으로 해야 할 일

- React, TypeScript 공부

- React 상태 관리 도구인 Zustand 공부

- 실시간 통신 애플리케이션 프로젝트 제작
